'use strict';

var node_fs = require('node:fs');
var node_path = require('node:path');
var createDebug = require('debug');
var node_module = require('node:module');
var bson = require('bson');
var os = require('node:os');
var process = require('node:process');
var realmConstants_json = require('realm/realm-constants.json');
var node_url = require('node:url');
var fetch = require('node-fetch');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var bson__namespace = /*#__PURE__*/_interopNamespaceDefault(bson);

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const fs = {
    isAbsolutePath() {
        throw new Error("Not supported on this platform");
    },
    joinPaths() {
        throw new Error("Not supported on this platform");
    },
    removeFile() {
        throw new Error("Not supported on this platform");
    },
    setDefaultDirectoryPath() {
        throw new Error("Not supported on this platform");
    },
    getDefaultDirectoryPath() {
        throw new Error("Not supported on this platform");
    },
    exists() {
        throw new Error("Not supported on this platform");
    },
    copyBundledRealmFiles() {
        throw new Error("Not supported on this platform");
    },
    removeDirectory() {
        throw new Error("Not supported on this platform");
    },
    ensureDirectoryForFile() {
        throw new Error("Not supported on this platform");
    },
    /*
    readDirectory() {
      throw new Error("Not supported on this platform");
    },
    */
    removeRealmFilesFromDirectory() {
        throw new Error("Not supported on this platform");
    },
};
function inject$2(injected) {
    Object.freeze(Object.assign(fs, injected));
}

////////////////////////////////////////////////////////////////////////////
const debug$3 = createDebug("realm");
function extendDebug(namespace) {
    return debug$3.extend(namespace);
}

// Wrapped types
class Float {
    value;
    constructor(value) {
        this.value = value;
    }
    valueOf() {
        return this.value;
    }
}

////////////////////////////////////////////////////////////////////////////
const nodeRequire = typeof require === "function" ? require : node_module.createRequire((typeof document === 'undefined' ? require('u' + 'rl').pathToFileURL(__filename).href : (document.currentScript && document.currentScript.src || new URL('bundle.node.js', document.baseURI).href)));
const nativeModule = nodeRequire("../generated/ts/realm.node");

if (!nativeModule) {
  throw new Error(
    "Could not find the Realm binary. Please consult our troubleshooting guide: https://www.mongodb.com/docs/realm-sdks/js/latest/#md:troubleshooting-missing-binary",
  );
}

// We know that node always has real WeakRefs so just use them.
const WeakRef = global.WeakRef;

const NativeBigIntSupport = Object.freeze({
  add(a, b) {
    return a + b;
  },
  equals(a, b) {
    return a == b;
  }, // using == rather than === to support number and string RHS!
  isInt(a) {
    return typeof a === "bigint";
  },
  numToInt(a) {
    return BigInt(a);
  },
  strToInt(a) {
    return BigInt(a);
  },
  intToNum(a) {
    return Number(a);
  },
});

const Int64 = NativeBigIntSupport; // Node always supports BigInt

// Copied from lib/utils.js.
// TODO consider importing instead.
// Might be slightly faster to make dedicated wrapper for 1 and 2 argument forms, but unlikely to be worth it.
function _promisify(nullAllowed, func) {
  return new Promise((resolve, reject) => {
    func((...cbargs) => {
      // Any errors in this function should flow into the Promise chain, rather than out to the caller,
      // since callers of async callbacks aren't expecting exceptions.
      try {
        if (cbargs.length < 1 || cbargs.length > 2) throw Error("invalid cbargs length " + cbargs.length);
        let error = cbargs[cbargs.length - 1];
        if (error) {
          reject(error);
        } else if (cbargs.length == 2) {
          const result = cbargs[0];
          if (!nullAllowed && (result === null || result === undefined)) {
            throw new Error("Unexpected null or undefined successful result");
          }
          resolve(result);
        } else {
          resolve();
        }
      } catch (err) {
        reject(err);
      }
    });
  });
}

const _Helpers_Symbol = Symbol("Realm.Helpers.external_pointer");
const _native_Helpers_get_table = nativeModule.Helpers_get_table;
const _native_Helpers_get_keypath_mapping = nativeModule.Helpers_get_keypath_mapping;
const _native_Helpers_results_append_query = nativeModule.Helpers_results_append_query;
const _native_Helpers_make_object_notifier = nativeModule.Helpers_make_object_notifier;
const _native_Helpers_set_binding_context = nativeModule.Helpers_set_binding_context;
const _native_Helpers_get_or_create_object_with_primary_key =
  nativeModule.Helpers_get_or_create_object_with_primary_key;
const _native_Helpers_make_network_transport = nativeModule.Helpers_make_network_transport;
const _native_Helpers_delete_data_for_object = nativeModule.Helpers_delete_data_for_object;
const _native_Helpers_is_empty_realm = nativeModule.Helpers_is_empty_realm;
const _native_Helpers_base64_decode = nativeModule.Helpers_base64_decode;
const _native_Helpers_make_logger_factory = nativeModule.Helpers_make_logger_factory;
const _native_Helpers_make_logger = nativeModule.Helpers_make_logger;
const _native_Helpers_simulate_sync_error = nativeModule.Helpers_simulate_sync_error;
const _native_Helpers_consume_thread_safe_reference_to_shared_realm =
  nativeModule.Helpers_consume_thread_safe_reference_to_shared_realm;
const _native_Helpers_file_exists = nativeModule.Helpers_file_exists;
const _native_Helpers_erase_subscription = nativeModule.Helpers_erase_subscription;
const _native_Helpers_get_results_description = nativeModule.Helpers_get_results_description;
const _native_Helpers_feed_buffer = nativeModule.Helpers_feed_buffer;
const _native_Helpers_make_ssl_verify_callback = nativeModule.Helpers_make_ssl_verify_callback;
class Helpers {
  constructor(ptr) {
    this[_Helpers_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Helpers)) throw new TypeError("Expected a Helpers");
    const out = self[_Helpers_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Helpers");
    return out;
  }

  static getTable(r, key) {
    return _native_Helpers_get_table(r, key);
  }
  static getKeypathMapping(r) {
    return _native_Helpers_get_keypath_mapping(r);
  }
  static resultsAppendQuery(results, query) {
    return _native_Helpers_results_append_query(results, query);
  }
  static makeObjectNotifier(r, o) {
    return _native_Helpers_make_object_notifier(r, o);
  }
  static setBindingContext(r, methods) {
    return _native_Helpers_set_binding_context(r, methods);
  }
  static getOrCreateObjectWithPrimaryKey(t, pk) {
    return _native_Helpers_get_or_create_object_with_primary_key(t, pk);
  }
  static makeNetworkTransport(runRequest) {
    return _native_Helpers_make_network_transport(runRequest);
  }
  static deleteDataForObject(realm, object_type) {
    return _native_Helpers_delete_data_for_object(realm, object_type);
  }
  static isEmptyRealm(realm) {
    return _native_Helpers_is_empty_realm(realm);
  }
  static base64Decode(input) {
    return _native_Helpers_base64_decode(input);
  }
  static makeLoggerFactory(log) {
    return _native_Helpers_make_logger_factory(log);
  }
  static makeLogger(log) {
    return _native_Helpers_make_logger(log);
  }
  static simulateSyncError(session, code, message, type, is_fatal) {
    return _native_Helpers_simulate_sync_error(session, code, message, type, is_fatal);
  }
  static consumeThreadSafeReferenceToSharedRealm(tsr) {
    return _native_Helpers_consume_thread_safe_reference_to_shared_realm(tsr);
  }
  static fileExists(path) {
    return _native_Helpers_file_exists(path);
  }
  static eraseSubscription(subs, sub_to_remove) {
    return _native_Helpers_erase_subscription(subs, sub_to_remove);
  }
  static getResultsDescription(results) {
    return _native_Helpers_get_results_description(results);
  }
  static feedBuffer(ws, buffer) {
    return _native_Helpers_feed_buffer(ws, buffer);
  }
  static makeSslVerifyCallback(callback) {
    return _native_Helpers_make_ssl_verify_callback(callback);
  }
}
const _Logger_Symbol = Symbol("Realm.Logger.external_pointer");
const _native_Logger_set_default_logger = nativeModule.Logger_set_default_logger;
const _native_Logger_set_default_level_threshold = nativeModule.Logger_set_default_level_threshold;
class Logger {
  constructor(ptr) {
    this[_Logger_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Logger)) throw new TypeError("Expected a Logger");
    const out = self[_Logger_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Logger");
    return out;
  }

  static setDefaultLogger(logger) {
    return _native_Logger_set_default_logger(logger);
  }
  static setDefaultLevelThreshold(level) {
    return _native_Logger_set_default_level_threshold(level);
  }
}
const _ConstTableRef_Symbol = Symbol("Realm.ConstTableRef.external_pointer");
const _native_ConstTableRef_get_column_type = nativeModule.ConstTableRef_get_column_type;
const _native_ConstTableRef_get_link_target = nativeModule.ConstTableRef_get_link_target;
const _native_ConstTableRef_get_object = nativeModule.ConstTableRef_get_object;
const _native_ConstTableRef_try_get_object = nativeModule.ConstTableRef_try_get_object;
const _native_ConstTableRef_query = nativeModule.ConstTableRef_query;
const _native_ConstTableRef_find_primary_key = nativeModule.ConstTableRef_find_primary_key;
const _native_ConstTableRef_get_key = nativeModule.ConstTableRef_get_key;
const _native_ConstTableRef_Symbol_iterator = nativeModule.ConstTableRef_Symbol_iterator;
class ConstTableRef {
  constructor(ptr) {
    this[_ConstTableRef_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ConstTableRef)) throw new TypeError("Expected a ConstTableRef");
    const out = self[_ConstTableRef_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ConstTableRef");
    return out;
  }

  getColumnType(column) {
    return _native_ConstTableRef_get_column_type(this[_ConstTableRef_Symbol], column);
  }

  getLinkTarget(column) {
    return _native_ConstTableRef_get_link_target(this[_ConstTableRef_Symbol], column);
  }

  getObject(key) {
    return _native_ConstTableRef_get_object(this[_ConstTableRef_Symbol], key);
  }

  tryGetObject(key) {
    return _native_ConstTableRef_try_get_object(this[_ConstTableRef_Symbol], key);
  }

  query(query_string, args, mapping) {
    return _native_ConstTableRef_query(this[_ConstTableRef_Symbol], query_string, args, mapping);
  }

  findPrimaryKey(pk) {
    return _native_ConstTableRef_find_primary_key(this[_ConstTableRef_Symbol], pk);
  }

  get key() {
    return _native_ConstTableRef_get_key(this[_ConstTableRef_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_ConstTableRef_Symbol_iterator(this[_ConstTableRef_Symbol]);
  }
}
const _native_TableRef_create_object = nativeModule.TableRef_create_object;
const _native_TableRef_remove_object = nativeModule.TableRef_remove_object;
const _native_TableRef_get_link_target = nativeModule.TableRef_get_link_target;
const _native_TableRef_clear = nativeModule.TableRef_clear;
class TableRef extends ConstTableRef {
  static _extract(self) {
    if (!(self instanceof TableRef)) throw new TypeError("Expected a TableRef");
    const out = self[_ConstTableRef_Symbol];
    if (!out) throw new TypeError("received an improperly constructed TableRef");
    return out;
  }

  createObject() {
    return _native_TableRef_create_object(this[_ConstTableRef_Symbol]);
  }

  removeObject(key) {
    return _native_TableRef_remove_object(this[_ConstTableRef_Symbol], key);
  }

  getLinkTarget(column) {
    return _native_TableRef_get_link_target(this[_ConstTableRef_Symbol], column);
  }

  clear() {
    return _native_TableRef_clear(this[_ConstTableRef_Symbol]);
  }
}
const _Obj_Symbol = Symbol("Realm.Obj.external_pointer");
const _native_Obj_get_any = nativeModule.Obj_get_any;
const _native_Obj_set_any = nativeModule.Obj_set_any;
const _native_Obj_get_linked_object = nativeModule.Obj_get_linked_object;
const _native_Obj_get_backlink_count = nativeModule.Obj_get_backlink_count;
const _native_Obj_get_backlink_view = nativeModule.Obj_get_backlink_view;
const _native_Obj_create_and_set_linked_object = nativeModule.Obj_create_and_set_linked_object;
const _native_Obj_is_valid = nativeModule.Obj_is_valid;
const _native_Obj_get_table = nativeModule.Obj_get_table;
const _native_Obj_get_key = nativeModule.Obj_get_key;
class Obj {
  constructor(ptr) {
    this[_Obj_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Obj)) throw new TypeError("Expected a Obj");
    const out = self[_Obj_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Obj");
    return out;
  }

  getAny(column) {
    return _native_Obj_get_any(this[_Obj_Symbol], column);
  }

  setAny(column, value) {
    return _native_Obj_set_any(this[_Obj_Symbol], column, value);
  }

  getLinkedObject(column) {
    return _native_Obj_get_linked_object(this[_Obj_Symbol], column);
  }

  getBacklinkCount() {
    return _native_Obj_get_backlink_count(this[_Obj_Symbol]);
  }

  getBacklinkView(src_table, src_col_key) {
    return _native_Obj_get_backlink_view(this[_Obj_Symbol], src_table, src_col_key);
  }

  createAndSetLinkedObject(column) {
    return _native_Obj_create_and_set_linked_object(this[_Obj_Symbol], column);
  }

  get isValid() {
    return _native_Obj_is_valid(this[_Obj_Symbol]);
  }

  get table() {
    return _native_Obj_get_table(this[_Obj_Symbol]);
  }

  get key() {
    return _native_Obj_get_key(this[_Obj_Symbol]);
  }
}
const _Transaction_Symbol = Symbol("Realm.Transaction.external_pointer");
class Transaction {
  constructor(ptr) {
    this[_Transaction_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Transaction)) throw new TypeError("Expected a Transaction");
    const out = self[_Transaction_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Transaction");
    return out;
  }
}
const _ObjectStore_Symbol = Symbol("Realm.ObjectStore.external_pointer");
class ObjectStore {
  constructor(ptr) {
    this[_ObjectStore_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjectStore)) throw new TypeError("Expected a ObjectStore");
    const out = self[_ObjectStore_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjectStore");
    return out;
  }
}
const _Timestamp_Symbol = Symbol("Realm.Timestamp.external_pointer");
const _native_Timestamp_make = nativeModule.Timestamp_make;
const _native_Timestamp_get_seconds = nativeModule.Timestamp_get_seconds;
const _native_Timestamp_get_nanoseconds = nativeModule.Timestamp_get_nanoseconds;
class Timestamp {
  constructor(ptr) {
    this[_Timestamp_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Timestamp)) throw new TypeError("Expected a Timestamp");
    const out = self[_Timestamp_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Timestamp");
    return out;
  }

  static make(seconds, nanoseconds) {
    return _native_Timestamp_make(seconds, nanoseconds);
  }

  get seconds() {
    return _native_Timestamp_get_seconds(this[_Timestamp_Symbol]);
  }

  get nanoseconds() {
    return _native_Timestamp_get_nanoseconds(this[_Timestamp_Symbol]);
  }
}
const _Geospatial_Symbol = Symbol("Realm.Geospatial.external_pointer");
const _native_Geospatial_make_from_circle = nativeModule.Geospatial_make_from_circle;
const _native_Geospatial_make_from_box = nativeModule.Geospatial_make_from_box;
const _native_Geospatial_make_from_polygon = nativeModule.Geospatial_make_from_polygon;
class Geospatial {
  constructor(ptr) {
    this[_Geospatial_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Geospatial)) throw new TypeError("Expected a Geospatial");
    const out = self[_Geospatial_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Geospatial");
    return out;
  }

  static makeFromCircle(circle) {
    return _native_Geospatial_make_from_circle(circle);
  }
  static makeFromBox(box) {
    return _native_Geospatial_make_from_box(box);
  }
  static makeFromPolygon(polygon) {
    return _native_Geospatial_make_from_polygon(polygon);
  }
}
const _ObjLink_Symbol = Symbol("Realm.ObjLink.external_pointer");
const _native_ObjLink_get_table_key = nativeModule.ObjLink_get_table_key;
const _native_ObjLink_get_obj_key = nativeModule.ObjLink_get_obj_key;
class ObjLink {
  constructor(ptr) {
    this[_ObjLink_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjLink)) throw new TypeError("Expected a ObjLink");
    const out = self[_ObjLink_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjLink");
    return out;
  }

  get tableKey() {
    return _native_ObjLink_get_table_key(this[_ObjLink_Symbol]);
  }

  get objKey() {
    return _native_ObjLink_get_obj_key(this[_ObjLink_Symbol]);
  }
}
const _KeyPathMapping_Symbol = Symbol("Realm.KeyPathMapping.external_pointer");
class KeyPathMapping {
  constructor(ptr) {
    this[_KeyPathMapping_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof KeyPathMapping)) throw new TypeError("Expected a KeyPathMapping");
    const out = self[_KeyPathMapping_Symbol];
    if (!out) throw new TypeError("received an improperly constructed KeyPathMapping");
    return out;
  }
}
const _Query_Symbol = Symbol("Realm.Query.external_pointer");
const _native_Query_get_table = nativeModule.Query_get_table;
const _native_Query_get_description = nativeModule.Query_get_description;
class Query {
  constructor(ptr) {
    this[_Query_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Query)) throw new TypeError("Expected a Query");
    const out = self[_Query_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Query");
    return out;
  }

  get table() {
    return _native_Query_get_table(this[_Query_Symbol]);
  }

  get description() {
    return _native_Query_get_description(this[_Query_Symbol]);
  }
}
const _SortDescriptor_Symbol = Symbol("Realm.SortDescriptor.external_pointer");
class SortDescriptor {
  constructor(ptr) {
    this[_SortDescriptor_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SortDescriptor)) throw new TypeError("Expected a SortDescriptor");
    const out = self[_SortDescriptor_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SortDescriptor");
    return out;
  }
}
const _TableView_Symbol = Symbol("Realm.TableView.external_pointer");
class TableView {
  constructor(ptr) {
    this[_TableView_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof TableView)) throw new TypeError("Expected a TableView");
    const out = self[_TableView_Symbol];
    if (!out) throw new TypeError("received an improperly constructed TableView");
    return out;
  }
}
const _Results_Symbol = Symbol("Realm.Results.external_pointer");
const _native_Results_size = nativeModule.Results_size;
const _native_Results_index_of = nativeModule.Results_index_of;
const _native_Results_index_of_obj = nativeModule.Results_index_of_obj;
const _native_Results_get_obj = nativeModule.Results_get_obj;
const _native_Results_get_any = nativeModule.Results_get_any;
const _native_Results_sort_by_names = nativeModule.Results_sort_by_names;
const _native_Results_snapshot = nativeModule.Results_snapshot;
const _native_Results_max = nativeModule.Results_max;
const _native_Results_min = nativeModule.Results_min;
const _native_Results_average = nativeModule.Results_average;
const _native_Results_sum = nativeModule.Results_sum;
const _native_Results_clear = nativeModule.Results_clear;
const _native_Results_add_notification_callback = nativeModule.Results_add_notification_callback;
const _native_Results_from_table = nativeModule.Results_from_table;
const _native_Results_from_table_view = nativeModule.Results_from_table_view;
const _native_Results_is_valid = nativeModule.Results_is_valid;
const _native_Results_get_query = nativeModule.Results_get_query;
const _native_Results_get_object_type = nativeModule.Results_get_object_type;
const _native_Results_get_type = nativeModule.Results_get_type;
let Results$1 = class Results {
  constructor(ptr) {
    this[_Results_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Results)) throw new TypeError("Expected a Results");
    const out = self[_Results_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Results");
    return out;
  }

  size() {
    return _native_Results_size(this[_Results_Symbol]);
  }

  indexOf(value) {
    return _native_Results_index_of(this[_Results_Symbol], value);
  }

  indexOfObj(obj) {
    return _native_Results_index_of_obj(this[_Results_Symbol], obj);
  }

  getObj(index) {
    return _native_Results_get_obj(this[_Results_Symbol], index);
  }

  getAny(index) {
    return _native_Results_get_any(this[_Results_Symbol], index);
  }

  sortByNames(order) {
    return _native_Results_sort_by_names(this[_Results_Symbol], order);
  }

  snapshot() {
    return _native_Results_snapshot(this[_Results_Symbol]);
  }

  max(column) {
    return _native_Results_max(this[_Results_Symbol], column);
  }

  min(column) {
    return _native_Results_min(this[_Results_Symbol], column);
  }

  average(column) {
    return _native_Results_average(this[_Results_Symbol], column);
  }

  sum(column) {
    return _native_Results_sum(this[_Results_Symbol], column);
  }

  clear() {
    return _native_Results_clear(this[_Results_Symbol]);
  }

  addNotificationCallback(cb, keyPaths) {
    return _native_Results_add_notification_callback(this[_Results_Symbol], cb, keyPaths);
  }
  static fromTable(r, table) {
    return _native_Results_from_table(r, table);
  }
  static fromTableView(r, table) {
    return _native_Results_from_table_view(r, table);
  }

  get isValid() {
    return _native_Results_is_valid(this[_Results_Symbol]);
  }

  get query() {
    return _native_Results_get_query(this[_Results_Symbol]);
  }

  get objectType() {
    return _native_Results_get_object_type(this[_Results_Symbol]);
  }

  get type() {
    return _native_Results_get_type(this[_Results_Symbol]);
  }
};
const _Realm_Symbol = Symbol("Realm.Realm.external_pointer");
const _native_Realm_begin_transaction = nativeModule.Realm_begin_transaction;
const _native_Realm_commit_transaction = nativeModule.Realm_commit_transaction;
const _native_Realm_cancel_transaction = nativeModule.Realm_cancel_transaction;
const _native_Realm_update_schema = nativeModule.Realm_update_schema;
const _native_Realm_compact = nativeModule.Realm_compact;
const _native_Realm_convert = nativeModule.Realm_convert;
const _native_Realm_verify_open = nativeModule.Realm_verify_open;
const _native_Realm_close = nativeModule.Realm_close;
const _native_Realm_get_shared_realm = nativeModule.Realm_get_shared_realm;
const _native_Realm_get_synchronized_realm = nativeModule.Realm_get_synchronized_realm;
const _native_Realm_get_schema_version = nativeModule.Realm_get_schema_version;
const _native_Realm_config = nativeModule.Realm_config;
const _native_Realm_schema = nativeModule.Realm_schema;
const _native_Realm_schema_version = nativeModule.Realm_schema_version;
const _native_Realm_is_in_transaction = nativeModule.Realm_is_in_transaction;
const _native_Realm_is_in_migration = nativeModule.Realm_is_in_migration;
const _native_Realm_is_closed = nativeModule.Realm_is_closed;
const _native_Realm_sync_session = nativeModule.Realm_sync_session;
const _native_Realm_get_latest_subscription_set = nativeModule.Realm_get_latest_subscription_set;
const _native_Realm_DOLLAR_addr = nativeModule.Realm_DOLLAR_addr;
const _native_Realm_DOLLAR_resetSharedPtr = nativeModule.Realm_DOLLAR_resetSharedPtr;
let Realm$1 = class Realm {
  constructor(ptr) {
    this[_Realm_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Realm)) throw new TypeError("Expected a Realm");
    const out = self[_Realm_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Realm");
    return out;
  }

  beginTransaction() {
    return _native_Realm_begin_transaction(this[_Realm_Symbol]);
  }

  commitTransaction() {
    return _native_Realm_commit_transaction(this[_Realm_Symbol]);
  }

  cancelTransaction() {
    return _native_Realm_cancel_transaction(this[_Realm_Symbol]);
  }

  updateSchema(schema, version, migration_function, initialization_function, in_transaction) {
    return _native_Realm_update_schema(
      this[_Realm_Symbol],
      schema,
      version,
      migration_function,
      initialization_function,
      in_transaction,
    );
  }

  compact() {
    return _native_Realm_compact(this[_Realm_Symbol]);
  }

  convert(config) {
    return _native_Realm_convert(this[_Realm_Symbol], config);
  }

  verifyOpen() {
    return _native_Realm_verify_open(this[_Realm_Symbol]);
  }

  close() {
    return _native_Realm_close(this[_Realm_Symbol]);
  }
  static getSharedRealm(config) {
    return _native_Realm_get_shared_realm(config);
  }
  static getSynchronizedRealm(config) {
    return _native_Realm_get_synchronized_realm(config);
  }
  static getSchemaVersion(config) {
    return _native_Realm_get_schema_version(config);
  }

  get config() {
    return _native_Realm_config(this[_Realm_Symbol]);
  }

  get schema() {
    return _native_Realm_schema(this[_Realm_Symbol]);
  }

  get schemaVersion() {
    return _native_Realm_schema_version(this[_Realm_Symbol]);
  }

  get isInTransaction() {
    return _native_Realm_is_in_transaction(this[_Realm_Symbol]);
  }

  get isInMigration() {
    return _native_Realm_is_in_migration(this[_Realm_Symbol]);
  }

  get isClosed() {
    return _native_Realm_is_closed(this[_Realm_Symbol]);
  }

  get syncSession() {
    return _native_Realm_sync_session(this[_Realm_Symbol]);
  }

  get latestSubscriptionSet() {
    return _native_Realm_get_latest_subscription_set(this[_Realm_Symbol]);
  }

  get $addr() {
    return _native_Realm_DOLLAR_addr(this[_Realm_Symbol]);
  }

  $resetSharedPtr() {
    return _native_Realm_DOLLAR_resetSharedPtr(this[_Realm_Symbol]);
  }
};
const _RealmCoordinator_Symbol = Symbol("Realm.RealmCoordinator.external_pointer");
const _native_RealmCoordinator_clear_all_caches = nativeModule.RealmCoordinator_clear_all_caches;
class RealmCoordinator {
  constructor(ptr) {
    this[_RealmCoordinator_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof RealmCoordinator)) throw new TypeError("Expected a RealmCoordinator");
    const out = self[_RealmCoordinator_Symbol];
    if (!out) throw new TypeError("received an improperly constructed RealmCoordinator");
    return out;
  }

  static clearAllCaches() {
    return _native_RealmCoordinator_clear_all_caches();
  }
}
const _ObjectNotifier_Symbol = Symbol("Realm.ObjectNotifier.external_pointer");
const _native_ObjectNotifier_add_callback = nativeModule.ObjectNotifier_add_callback;
class ObjectNotifier {
  constructor(ptr) {
    this[_ObjectNotifier_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ObjectNotifier)) throw new TypeError("Expected a ObjectNotifier");
    const out = self[_ObjectNotifier_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ObjectNotifier");
    return out;
  }

  addCallback(cb, keyPaths) {
    return _native_ObjectNotifier_add_callback(this[_ObjectNotifier_Symbol], cb, keyPaths);
  }
}
const _NotificationToken_Symbol = Symbol("Realm.NotificationToken.external_pointer");
const _native_NotificationToken_unregister = nativeModule.NotificationToken_unregister;
const _native_NotificationToken_for_object = nativeModule.NotificationToken_for_object;
class NotificationToken {
  constructor(ptr) {
    this[_NotificationToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof NotificationToken)) throw new TypeError("Expected a NotificationToken");
    const out = self[_NotificationToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed NotificationToken");
    return out;
  }

  unregister() {
    return _native_NotificationToken_unregister(this[_NotificationToken_Symbol]);
  }
  static forObject(notifier, token) {
    return _native_NotificationToken_for_object(notifier, token);
  }
}
const _IndexSet_Symbol = Symbol("Realm.IndexSet.external_pointer");
const _native_IndexSet_Symbol_iterator = nativeModule.IndexSet_Symbol_iterator;
class IndexSet {
  constructor(ptr) {
    this[_IndexSet_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof IndexSet)) throw new TypeError("Expected a IndexSet");
    const out = self[_IndexSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed IndexSet");
    return out;
  }

  [Symbol.iterator]() {
    return _native_IndexSet_Symbol_iterator(this[_IndexSet_Symbol]);
  }
}
const _Collection_Symbol = Symbol("Realm.Collection.external_pointer");
const _native_Collection_get_any = nativeModule.Collection_get_any;
const _native_Collection_as_results = nativeModule.Collection_as_results;
const _native_Collection_get_object_schema = nativeModule.Collection_get_object_schema;
const _native_Collection_size = nativeModule.Collection_size;
const _native_Collection_is_valid = nativeModule.Collection_is_valid;
let Collection$1 = class Collection {
  constructor(ptr) {
    this[_Collection_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Collection)) throw new TypeError("Expected a Collection");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Collection");
    return out;
  }

  getAny(ndx) {
    return _native_Collection_get_any(this[_Collection_Symbol], ndx);
  }

  asResults() {
    return _native_Collection_as_results(this[_Collection_Symbol]);
  }

  get objectSchema() {
    return _native_Collection_get_object_schema(this[_Collection_Symbol]);
  }

  get size() {
    return _native_Collection_size(this[_Collection_Symbol]);
  }

  get isValid() {
    return _native_Collection_is_valid(this[_Collection_Symbol]);
  }
};
const _native_List_move = nativeModule.List_move;
const _native_List_remove = nativeModule.List_remove;
const _native_List_remove_all = nativeModule.List_remove_all;
const _native_List_swap = nativeModule.List_swap;
const _native_List_delete_all = nativeModule.List_delete_all;
const _native_List_insert_any = nativeModule.List_insert_any;
const _native_List_insert_embedded = nativeModule.List_insert_embedded;
const _native_List_set_any = nativeModule.List_set_any;
const _native_List_make = nativeModule.List_make;
let List$1 = class List extends Collection$1 {
  static _extract(self) {
    if (!(self instanceof List)) throw new TypeError("Expected a List");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed List");
    return out;
  }

  move(source_ndx, dest_ndx) {
    return _native_List_move(this[_Collection_Symbol], source_ndx, dest_ndx);
  }

  remove(ndx) {
    return _native_List_remove(this[_Collection_Symbol], ndx);
  }

  removeAll() {
    return _native_List_remove_all(this[_Collection_Symbol]);
  }

  swap(ndx1, ndx2) {
    return _native_List_swap(this[_Collection_Symbol], ndx1, ndx2);
  }

  deleteAll() {
    return _native_List_delete_all(this[_Collection_Symbol]);
  }

  insertAny(list_ndx, value) {
    return _native_List_insert_any(this[_Collection_Symbol], list_ndx, value);
  }

  insertEmbedded(ndx) {
    return _native_List_insert_embedded(this[_Collection_Symbol], ndx);
  }

  setAny(list_ndx, value) {
    return _native_List_set_any(this[_Collection_Symbol], list_ndx, value);
  }
  static make(r, parent, col) {
    return _native_List_make(r, parent, col);
  }
};
const _native_Set_insert_any = nativeModule.Set_insert_any;
const _native_Set_remove_any = nativeModule.Set_remove_any;
const _native_Set_remove_all = nativeModule.Set_remove_all;
const _native_Set_delete_all = nativeModule.Set_delete_all;
const _native_Set_make = nativeModule.Set_make;
let Set$1 = class Set extends Collection$1 {
  static _extract(self) {
    if (!(self instanceof Set)) throw new TypeError("Expected a Set");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Set");
    return out;
  }

  insertAny(val) {
    return _native_Set_insert_any(this[_Collection_Symbol], val);
  }

  removeAny(val) {
    return _native_Set_remove_any(this[_Collection_Symbol], val);
  }

  removeAll() {
    return _native_Set_remove_all(this[_Collection_Symbol]);
  }

  deleteAll() {
    return _native_Set_delete_all(this[_Collection_Symbol]);
  }
  static make(r, parent, col) {
    return _native_Set_make(r, parent, col);
  }
};
const _native_Dictionary_contains = nativeModule.Dictionary_contains;
const _native_Dictionary_add_key_based_notification_callback =
  nativeModule.Dictionary_add_key_based_notification_callback;
const _native_Dictionary_insert_any = nativeModule.Dictionary_insert_any;
const _native_Dictionary_insert_embedded = nativeModule.Dictionary_insert_embedded;
const _native_Dictionary_try_get_any = nativeModule.Dictionary_try_get_any;
const _native_Dictionary_remove_all = nativeModule.Dictionary_remove_all;
const _native_Dictionary_try_erase = nativeModule.Dictionary_try_erase;
const _native_Dictionary_make = nativeModule.Dictionary_make;
const _native_Dictionary_get_keys = nativeModule.Dictionary_get_keys;
const _native_Dictionary_get_values = nativeModule.Dictionary_get_values;
const _native_Dictionary_Symbol_iterator = nativeModule.Dictionary_Symbol_iterator;
let Dictionary$1 = class Dictionary extends Collection$1 {
  static _extract(self) {
    if (!(self instanceof Dictionary)) throw new TypeError("Expected a Dictionary");
    const out = self[_Collection_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Dictionary");
    return out;
  }

  contains(key) {
    return _native_Dictionary_contains(this[_Collection_Symbol], key);
  }

  addKeyBasedNotificationCallback(cb, keyPaths) {
    return _native_Dictionary_add_key_based_notification_callback(this[_Collection_Symbol], cb, keyPaths);
  }

  insertAny(key, value) {
    return _native_Dictionary_insert_any(this[_Collection_Symbol], key, value);
  }

  insertEmbedded(key) {
    return _native_Dictionary_insert_embedded(this[_Collection_Symbol], key);
  }

  tryGetAny(key) {
    return _native_Dictionary_try_get_any(this[_Collection_Symbol], key);
  }

  removeAll() {
    return _native_Dictionary_remove_all(this[_Collection_Symbol]);
  }

  tryErase(key) {
    return _native_Dictionary_try_erase(this[_Collection_Symbol], key);
  }
  static make(r, parent, col) {
    return _native_Dictionary_make(r, parent, col);
  }

  get keys() {
    return _native_Dictionary_get_keys(this[_Collection_Symbol]);
  }

  get values() {
    return _native_Dictionary_get_values(this[_Collection_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_Dictionary_Symbol_iterator(this[_Collection_Symbol]);
  }
};
const _GoogleAuthCode_Symbol = Symbol("Realm.GoogleAuthCode.external_pointer");
const _native_GoogleAuthCode_make = nativeModule.GoogleAuthCode_make;
class GoogleAuthCode {
  constructor(ptr) {
    this[_GoogleAuthCode_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GoogleAuthCode)) throw new TypeError("Expected a GoogleAuthCode");
    const out = self[_GoogleAuthCode_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GoogleAuthCode");
    return out;
  }

  static make(code) {
    return _native_GoogleAuthCode_make(code);
  }
}
const _GoogleIdToken_Symbol = Symbol("Realm.GoogleIdToken.external_pointer");
const _native_GoogleIdToken_make = nativeModule.GoogleIdToken_make;
class GoogleIdToken {
  constructor(ptr) {
    this[_GoogleIdToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GoogleIdToken)) throw new TypeError("Expected a GoogleIdToken");
    const out = self[_GoogleIdToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GoogleIdToken");
    return out;
  }

  static make(token) {
    return _native_GoogleIdToken_make(token);
  }
}
const _AppCredentials_Symbol = Symbol("Realm.AppCredentials.external_pointer");
const _native_AppCredentials_facebook = nativeModule.AppCredentials_facebook;
const _native_AppCredentials_anonymous = nativeModule.AppCredentials_anonymous;
const _native_AppCredentials_apple = nativeModule.AppCredentials_apple;
const _native_AppCredentials_google_auth = nativeModule.AppCredentials_google_auth;
const _native_AppCredentials_google_id = nativeModule.AppCredentials_google_id;
const _native_AppCredentials_custom = nativeModule.AppCredentials_custom;
const _native_AppCredentials_username_password = nativeModule.AppCredentials_username_password;
const _native_AppCredentials_function = nativeModule.AppCredentials_function;
const _native_AppCredentials_api_key = nativeModule.AppCredentials_api_key;
class AppCredentials {
  constructor(ptr) {
    this[_AppCredentials_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AppCredentials)) throw new TypeError("Expected a AppCredentials");
    const out = self[_AppCredentials_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AppCredentials");
    return out;
  }

  static facebook(access_token) {
    return _native_AppCredentials_facebook(access_token);
  }
  static anonymous(reuse_anonymous_credentials) {
    return _native_AppCredentials_anonymous(reuse_anonymous_credentials);
  }
  static apple(id_token) {
    return _native_AppCredentials_apple(id_token);
  }
  static googleAuth(id_token) {
    return _native_AppCredentials_google_auth(id_token);
  }
  static googleId(id_token) {
    return _native_AppCredentials_google_id(id_token);
  }
  static custom(token) {
    return _native_AppCredentials_custom(token);
  }
  static usernamePassword(username, password) {
    return _native_AppCredentials_username_password(username, password);
  }
  static function(serialized_payload) {
    return _native_AppCredentials_function(serialized_payload);
  }
  static apiKey(api_key) {
    return _native_AppCredentials_api_key(api_key);
  }
}
const _SyncUserSubscriptionToken_Symbol = Symbol("Realm.SyncUserSubscriptionToken.external_pointer");
class SyncUserSubscriptionToken {
  constructor(ptr) {
    this[_SyncUserSubscriptionToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncUserSubscriptionToken)) throw new TypeError("Expected a SyncUserSubscriptionToken");
    const out = self[_SyncUserSubscriptionToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncUserSubscriptionToken");
    return out;
  }
}
const _SyncUser_Symbol = Symbol("Realm.SyncUser.external_pointer");
const _native_SyncUser_session_for_on_disk_path = nativeModule.SyncUser_session_for_on_disk_path;
const _native_SyncUser_subscribe = nativeModule.SyncUser_subscribe;
const _native_SyncUser_unsubscribe = nativeModule.SyncUser_unsubscribe;
const _native_SyncUser_all_sessions = nativeModule.SyncUser_all_sessions;
const _native_SyncUser_is_logged_in = nativeModule.SyncUser_is_logged_in;
const _native_SyncUser_identity = nativeModule.SyncUser_identity;
const _native_SyncUser_provider_type = nativeModule.SyncUser_provider_type;
const _native_SyncUser_access_token = nativeModule.SyncUser_access_token;
const _native_SyncUser_refresh_token = nativeModule.SyncUser_refresh_token;
const _native_SyncUser_device_id = nativeModule.SyncUser_device_id;
const _native_SyncUser_user_profile = nativeModule.SyncUser_user_profile;
const _native_SyncUser_identities = nativeModule.SyncUser_identities;
const _native_SyncUser_custom_data = nativeModule.SyncUser_custom_data;
const _native_SyncUser_sync_manager = nativeModule.SyncUser_sync_manager;
const _native_SyncUser_state = nativeModule.SyncUser_state;
class SyncUser {
  constructor(ptr) {
    this[_SyncUser_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncUser)) throw new TypeError("Expected a SyncUser");
    const out = self[_SyncUser_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncUser");
    return out;
  }

  sessionForOnDiskPath(path) {
    return _native_SyncUser_session_for_on_disk_path(this[_SyncUser_Symbol], path);
  }

  subscribe(observer) {
    return _native_SyncUser_subscribe(this[_SyncUser_Symbol], observer);
  }

  unsubscribe(token) {
    return _native_SyncUser_unsubscribe(this[_SyncUser_Symbol], token);
  }

  get allSessions() {
    return _native_SyncUser_all_sessions(this[_SyncUser_Symbol]);
  }

  get isLoggedIn() {
    return _native_SyncUser_is_logged_in(this[_SyncUser_Symbol]);
  }

  get identity() {
    return _native_SyncUser_identity(this[_SyncUser_Symbol]);
  }

  get providerType() {
    return _native_SyncUser_provider_type(this[_SyncUser_Symbol]);
  }

  get accessToken() {
    return _native_SyncUser_access_token(this[_SyncUser_Symbol]);
  }

  get refreshToken() {
    return _native_SyncUser_refresh_token(this[_SyncUser_Symbol]);
  }

  get deviceId() {
    return _native_SyncUser_device_id(this[_SyncUser_Symbol]);
  }

  get userProfile() {
    return _native_SyncUser_user_profile(this[_SyncUser_Symbol]);
  }

  get identities() {
    return _native_SyncUser_identities(this[_SyncUser_Symbol]);
  }

  get customData() {
    return _native_SyncUser_custom_data(this[_SyncUser_Symbol]);
  }

  get syncManager() {
    return _native_SyncUser_sync_manager(this[_SyncUser_Symbol]);
  }

  get state() {
    return _native_SyncUser_state(this[_SyncUser_Symbol]);
  }
}
const _UserProfile_Symbol = Symbol("Realm.UserProfile.external_pointer");
const _native_UserProfile_data = nativeModule.UserProfile_data;
class UserProfile {
  constructor(ptr) {
    this[_UserProfile_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UserProfile)) throw new TypeError("Expected a UserProfile");
    const out = self[_UserProfile_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UserProfile");
    return out;
  }

  data() {
    return _native_UserProfile_data(this[_UserProfile_Symbol]);
  }
}
const _AppSubscriptionToken_Symbol = Symbol("Realm.AppSubscriptionToken.external_pointer");
class AppSubscriptionToken {
  constructor(ptr) {
    this[_AppSubscriptionToken_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AppSubscriptionToken)) throw new TypeError("Expected a AppSubscriptionToken");
    const out = self[_AppSubscriptionToken_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AppSubscriptionToken");
    return out;
  }
}
const _App_Symbol = Symbol("Realm.App.external_pointer");
const _native_App_log_in_with_credentials = nativeModule.App_log_in_with_credentials;
const _native_App_log_out_user = nativeModule.App_log_out_user;
const _native_App_refresh_custom_data = nativeModule.App_refresh_custom_data;
const _native_App_link_user = nativeModule.App_link_user;
const _native_App_switch_user = nativeModule.App_switch_user;
const _native_App_remove_user = nativeModule.App_remove_user;
const _native_App_delete_user = nativeModule.App_delete_user;
const _native_App_usernamePasswordProviderClient = nativeModule.App_usernamePasswordProviderClient;
const _native_App_userAPIKeyProviderClient = nativeModule.App_userAPIKeyProviderClient;
const _native_App_push_notification_client = nativeModule.App_push_notification_client;
const _native_App_subscribe = nativeModule.App_subscribe;
const _native_App_unsubscribe = nativeModule.App_unsubscribe;
const _native_App_call_function = nativeModule.App_call_function;
const _native_App_make_streaming_request = nativeModule.App_make_streaming_request;
const _native_App_get_uncached_app = nativeModule.App_get_uncached_app;
const _native_App_clear_cached_apps = nativeModule.App_clear_cached_apps;
const _native_App_config = nativeModule.App_config;
const _native_App_current_user = nativeModule.App_current_user;
const _native_App_all_users = nativeModule.App_all_users;
const _native_App_sync_manager = nativeModule.App_sync_manager;
let App$1 = class App {
  constructor(ptr) {
    this[_App_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof App)) throw new TypeError("Expected a App");
    const out = self[_App_Symbol];
    if (!out) throw new TypeError("received an improperly constructed App");
    return out;
  }

  logInWithCredentials(credentials) {
    return _promisify(false, (_cb) => _native_App_log_in_with_credentials(this[_App_Symbol], credentials, _cb));
  }

  logOutUser(user) {
    return _promisify(false, (_cb) => _native_App_log_out_user(this[_App_Symbol], user, _cb));
  }

  refreshCustomData(user) {
    return _promisify(false, (_cb) => _native_App_refresh_custom_data(this[_App_Symbol], user, _cb));
  }

  linkUser(user, credentials) {
    return _promisify(false, (_cb) => _native_App_link_user(this[_App_Symbol], user, credentials, _cb));
  }

  switchUser(user) {
    return _native_App_switch_user(this[_App_Symbol], user);
  }

  removeUser(user) {
    return _promisify(false, (_cb) => _native_App_remove_user(this[_App_Symbol], user, _cb));
  }

  deleteUser(user) {
    return _promisify(false, (_cb) => _native_App_delete_user(this[_App_Symbol], user, _cb));
  }

  usernamePasswordProviderClient() {
    return _native_App_usernamePasswordProviderClient(this[_App_Symbol]);
  }

  userApiKeyProviderClient() {
    return _native_App_userAPIKeyProviderClient(this[_App_Symbol]);
  }

  pushNotificationClient(service_name) {
    return _native_App_push_notification_client(this[_App_Symbol], service_name);
  }

  subscribe(observer) {
    return _native_App_subscribe(this[_App_Symbol], observer);
  }

  unsubscribe(token) {
    return _native_App_unsubscribe(this[_App_Symbol], token);
  }

  callFunction(user, name, args, service_name) {
    return _promisify(true, (_cb) => _native_App_call_function(this[_App_Symbol], user, name, args, service_name, _cb));
  }

  makeStreamingRequest(user, name, args, service_name) {
    return _native_App_make_streaming_request(this[_App_Symbol], user, name, args, service_name);
  }
  static getUncachedApp(config, sync_client_config) {
    return _native_App_get_uncached_app(config, sync_client_config);
  }
  static clearCachedApps() {
    return _native_App_clear_cached_apps();
  }

  get config() {
    return _native_App_config(this[_App_Symbol]);
  }

  get currentUser() {
    return _native_App_current_user(this[_App_Symbol]);
  }

  get allUsers() {
    return _native_App_all_users(this[_App_Symbol]);
  }

  get syncManager() {
    return _native_App_sync_manager(this[_App_Symbol]);
  }
};
const _WatchStream_Symbol = Symbol("Realm.WatchStream.external_pointer");
const _native_WatchStream_next_event = nativeModule.WatchStream_next_event;
const _native_WatchStream_make = nativeModule.WatchStream_make;
const _native_WatchStream_state = nativeModule.WatchStream_state;
const _native_WatchStream_error = nativeModule.WatchStream_error;
class WatchStream {
  constructor(ptr) {
    this[_WatchStream_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof WatchStream)) throw new TypeError("Expected a WatchStream");
    const out = self[_WatchStream_Symbol];
    if (!out) throw new TypeError("received an improperly constructed WatchStream");
    return out;
  }

  nextEvent() {
    return _native_WatchStream_next_event(this[_WatchStream_Symbol]);
  }
  static make() {
    return _native_WatchStream_make();
  }

  get state() {
    return _native_WatchStream_state(this[_WatchStream_Symbol]);
  }

  get error() {
    return _native_WatchStream_error(this[_WatchStream_Symbol]);
  }
}
const _PushClient_Symbol = Symbol("Realm.PushClient.external_pointer");
const _native_PushClient_register_device = nativeModule.PushClient_register_device;
const _native_PushClient_deregister_device = nativeModule.PushClient_deregister_device;
let PushClient$1 = class PushClient {
  constructor(ptr) {
    this[_PushClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof PushClient)) throw new TypeError("Expected a PushClient");
    const out = self[_PushClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed PushClient");
    return out;
  }

  registerDevice(registration_token, sync_user) {
    return _promisify(false, (_cb) =>
      _native_PushClient_register_device(this[_PushClient_Symbol], registration_token, sync_user, _cb),
    );
  }

  deregisterDevice(sync_user) {
    return _promisify(false, (_cb) => _native_PushClient_deregister_device(this[_PushClient_Symbol], sync_user, _cb));
  }
};
const _UsernamePasswordProviderClient_Symbol = Symbol("Realm.UsernamePasswordProviderClient.external_pointer");
const _native_UsernamePasswordProviderClient_register_email =
  nativeModule.UsernamePasswordProviderClient_register_email;
const _native_UsernamePasswordProviderClient_retry_custom_confirmation =
  nativeModule.UsernamePasswordProviderClient_retry_custom_confirmation;
const _native_UsernamePasswordProviderClient_confirm_user = nativeModule.UsernamePasswordProviderClient_confirm_user;
const _native_UsernamePasswordProviderClient_resend_confirmation_email =
  nativeModule.UsernamePasswordProviderClient_resend_confirmation_email;
const _native_UsernamePasswordProviderClient_reset_password =
  nativeModule.UsernamePasswordProviderClient_reset_password;
const _native_UsernamePasswordProviderClient_send_reset_password_email =
  nativeModule.UsernamePasswordProviderClient_send_reset_password_email;
const _native_UsernamePasswordProviderClient_call_reset_password_function =
  nativeModule.UsernamePasswordProviderClient_call_reset_password_function;
class UsernamePasswordProviderClient {
  constructor(ptr) {
    this[_UsernamePasswordProviderClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UsernamePasswordProviderClient))
      throw new TypeError("Expected a UsernamePasswordProviderClient");
    const out = self[_UsernamePasswordProviderClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UsernamePasswordProviderClient");
    return out;
  }

  registerEmail(email, password) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_register_email(
        this[_UsernamePasswordProviderClient_Symbol],
        email,
        password,
        _cb,
      ),
    );
  }

  retryCustomConfirmation(email) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_retry_custom_confirmation(
        this[_UsernamePasswordProviderClient_Symbol],
        email,
        _cb,
      ),
    );
  }

  confirmUser(token, token_id) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_confirm_user(
        this[_UsernamePasswordProviderClient_Symbol],
        token,
        token_id,
        _cb,
      ),
    );
  }

  resendConfirmationEmail(email) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_resend_confirmation_email(
        this[_UsernamePasswordProviderClient_Symbol],
        email,
        _cb,
      ),
    );
  }

  resetPassword(password, token, token_id) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_reset_password(
        this[_UsernamePasswordProviderClient_Symbol],
        password,
        token,
        token_id,
        _cb,
      ),
    );
  }

  sendResetPasswordEmail(email) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_send_reset_password_email(
        this[_UsernamePasswordProviderClient_Symbol],
        email,
        _cb,
      ),
    );
  }

  callResetPasswordFunction(email, password, args) {
    return _promisify(false, (_cb) =>
      _native_UsernamePasswordProviderClient_call_reset_password_function(
        this[_UsernamePasswordProviderClient_Symbol],
        email,
        password,
        args,
        _cb,
      ),
    );
  }
}
const _UserApiKeyProviderClient_Symbol = Symbol("Realm.UserApiKeyProviderClient.external_pointer");
const _native_UserAPIKeyProviderClient_create_api_key = nativeModule.UserAPIKeyProviderClient_create_api_key;
const _native_UserAPIKeyProviderClient_fetch_api_key = nativeModule.UserAPIKeyProviderClient_fetch_api_key;
const _native_UserAPIKeyProviderClient_fetch_api_keys = nativeModule.UserAPIKeyProviderClient_fetch_api_keys;
const _native_UserAPIKeyProviderClient_delete_api_key = nativeModule.UserAPIKeyProviderClient_delete_api_key;
const _native_UserAPIKeyProviderClient_enable_api_key = nativeModule.UserAPIKeyProviderClient_enable_api_key;
const _native_UserAPIKeyProviderClient_disable_api_key = nativeModule.UserAPIKeyProviderClient_disable_api_key;
class UserApiKeyProviderClient {
  constructor(ptr) {
    this[_UserApiKeyProviderClient_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof UserApiKeyProviderClient)) throw new TypeError("Expected a UserApiKeyProviderClient");
    const out = self[_UserApiKeyProviderClient_Symbol];
    if (!out) throw new TypeError("received an improperly constructed UserApiKeyProviderClient");
    return out;
  }

  createApiKey(name, user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_create_api_key(this[_UserApiKeyProviderClient_Symbol], name, user, _cb),
    );
  }

  fetchApiKey(id, user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_fetch_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb),
    );
  }

  fetchApiKeys(user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_fetch_api_keys(this[_UserApiKeyProviderClient_Symbol], user, _cb),
    );
  }

  deleteApiKey(id, user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_delete_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb),
    );
  }

  enableApiKey(id, user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_enable_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb),
    );
  }

  disableApiKey(id, user) {
    return _promisify(false, (_cb) =>
      _native_UserAPIKeyProviderClient_disable_api_key(this[_UserApiKeyProviderClient_Symbol], id, user, _cb),
    );
  }
}
const _LoggerFactory_Symbol = Symbol("Realm.LoggerFactory.external_pointer");
class LoggerFactory {
  constructor(ptr) {
    this[_LoggerFactory_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof LoggerFactory)) throw new TypeError("Expected a LoggerFactory");
    const out = self[_LoggerFactory_Symbol];
    if (!out) throw new TypeError("received an improperly constructed LoggerFactory");
    return out;
  }
}
const _SyncManager_Symbol = Symbol("Realm.SyncManager.external_pointer");
const _native_SyncManager_immediately_run_file_actions = nativeModule.SyncManager_immediately_run_file_actions;
const _native_SyncManager_set_session_multiplexing = nativeModule.SyncManager_set_session_multiplexing;
const _native_SyncManager_set_log_level = nativeModule.SyncManager_set_log_level;
const _native_SyncManager_set_logger_factory = nativeModule.SyncManager_set_logger_factory;
const _native_SyncManager_set_user_agent = nativeModule.SyncManager_set_user_agent;
const _native_SyncManager_reconnect = nativeModule.SyncManager_reconnect;
const _native_SyncManager_path_for_realm = nativeModule.SyncManager_path_for_realm;
const _native_SyncManager_has_existing_sessions = nativeModule.SyncManager_has_existing_sessions;
class SyncManager {
  constructor(ptr) {
    this[_SyncManager_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncManager)) throw new TypeError("Expected a SyncManager");
    const out = self[_SyncManager_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncManager");
    return out;
  }

  immediatelyRunFileActions(original_name) {
    return _native_SyncManager_immediately_run_file_actions(this[_SyncManager_Symbol], original_name);
  }

  setSessionMultiplexing(allowed) {
    return _native_SyncManager_set_session_multiplexing(this[_SyncManager_Symbol], allowed);
  }

  setLogLevel(level) {
    return _native_SyncManager_set_log_level(this[_SyncManager_Symbol], level);
  }

  setLoggerFactory(factory) {
    return _native_SyncManager_set_logger_factory(this[_SyncManager_Symbol], factory);
  }

  setUserAgent(user_agent) {
    return _native_SyncManager_set_user_agent(this[_SyncManager_Symbol], user_agent);
  }

  reconnect() {
    return _native_SyncManager_reconnect(this[_SyncManager_Symbol]);
  }

  pathForRealm(config, custom_file_name) {
    return _native_SyncManager_path_for_realm(this[_SyncManager_Symbol], config, custom_file_name);
  }

  get hasExistingSessions() {
    return _native_SyncManager_has_existing_sessions(this[_SyncManager_Symbol]);
  }
}
const _ThreadSafeReference_Symbol = Symbol("Realm.ThreadSafeReference.external_pointer");
class ThreadSafeReference {
  constructor(ptr) {
    this[_ThreadSafeReference_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof ThreadSafeReference)) throw new TypeError("Expected a ThreadSafeReference");
    const out = self[_ThreadSafeReference_Symbol];
    if (!out) throw new TypeError("received an improperly constructed ThreadSafeReference");
    return out;
  }
}
const _AsyncOpenTask_Symbol = Symbol("Realm.AsyncOpenTask.external_pointer");
const _native_AsyncOpenTask_start = nativeModule.AsyncOpenTask_start;
const _native_AsyncOpenTask_cancel = nativeModule.AsyncOpenTask_cancel;
const _native_AsyncOpenTask_register_download_progress_notifier =
  nativeModule.AsyncOpenTask_register_download_progress_notifier;
const _native_AsyncOpenTask_DOLLAR_resetSharedPtr = nativeModule.AsyncOpenTask_DOLLAR_resetSharedPtr;
class AsyncOpenTask {
  constructor(ptr) {
    this[_AsyncOpenTask_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof AsyncOpenTask)) throw new TypeError("Expected a AsyncOpenTask");
    const out = self[_AsyncOpenTask_Symbol];
    if (!out) throw new TypeError("received an improperly constructed AsyncOpenTask");
    return out;
  }

  start() {
    return _promisify(false, (_cb) => _native_AsyncOpenTask_start(this[_AsyncOpenTask_Symbol], _cb));
  }

  cancel() {
    return _native_AsyncOpenTask_cancel(this[_AsyncOpenTask_Symbol]);
  }

  registerDownloadProgressNotifier(callback) {
    return _native_AsyncOpenTask_register_download_progress_notifier(this[_AsyncOpenTask_Symbol], callback);
  }

  $resetSharedPtr() {
    return _native_AsyncOpenTask_DOLLAR_resetSharedPtr(this[_AsyncOpenTask_Symbol]);
  }
}
const _SyncSession_Symbol = Symbol("Realm.SyncSession.external_pointer");
const _native_SyncSession_wait_for_upload_completion = nativeModule.SyncSession_wait_for_upload_completion;
const _native_SyncSession_wait_for_download_completion = nativeModule.SyncSession_wait_for_download_completion;
const _native_SyncSession_register_progress_notifier = nativeModule.SyncSession_register_progress_notifier;
const _native_SyncSession_unregister_progress_notifier = nativeModule.SyncSession_unregister_progress_notifier;
const _native_SyncSession_register_connection_change_callback =
  nativeModule.SyncSession_register_connection_change_callback;
const _native_SyncSession_unregister_connection_change_callback =
  nativeModule.SyncSession_unregister_connection_change_callback;
const _native_SyncSession_revive_if_needed = nativeModule.SyncSession_revive_if_needed;
const _native_SyncSession_force_close = nativeModule.SyncSession_force_close;
const _native_SyncSession_state = nativeModule.SyncSession_state;
const _native_SyncSession_connection_state = nativeModule.SyncSession_connection_state;
const _native_SyncSession_user = nativeModule.SyncSession_user;
const _native_SyncSession_config = nativeModule.SyncSession_config;
const _native_SyncSession_full_realm_url = nativeModule.SyncSession_full_realm_url;
const _native_SyncSession_DOLLAR_resetSharedPtr = nativeModule.SyncSession_DOLLAR_resetSharedPtr;
let SyncSession$1 = class SyncSession {
  constructor(ptr) {
    this[_SyncSession_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncSession)) throw new TypeError("Expected a SyncSession");
    const out = self[_SyncSession_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncSession");
    return out;
  }

  waitForUploadCompletion() {
    return _promisify(false, (_cb) => _native_SyncSession_wait_for_upload_completion(this[_SyncSession_Symbol], _cb));
  }

  waitForDownloadCompletion() {
    return _promisify(false, (_cb) => _native_SyncSession_wait_for_download_completion(this[_SyncSession_Symbol], _cb));
  }

  registerProgressNotifier(callback, direction, is_streaming) {
    return _native_SyncSession_register_progress_notifier(this[_SyncSession_Symbol], callback, direction, is_streaming);
  }

  unregisterProgressNotifier(token) {
    return _native_SyncSession_unregister_progress_notifier(this[_SyncSession_Symbol], token);
  }

  registerConnectionChangeCallback(callback) {
    return _native_SyncSession_register_connection_change_callback(this[_SyncSession_Symbol], callback);
  }

  unregisterConnectionChangeCallback(token) {
    return _native_SyncSession_unregister_connection_change_callback(this[_SyncSession_Symbol], token);
  }

  reviveIfNeeded() {
    return _native_SyncSession_revive_if_needed(this[_SyncSession_Symbol]);
  }

  forceClose() {
    return _native_SyncSession_force_close(this[_SyncSession_Symbol]);
  }

  get state() {
    return _native_SyncSession_state(this[_SyncSession_Symbol]);
  }

  get connectionState() {
    return _native_SyncSession_connection_state(this[_SyncSession_Symbol]);
  }

  get user() {
    return _native_SyncSession_user(this[_SyncSession_Symbol]);
  }

  get config() {
    return _native_SyncSession_config(this[_SyncSession_Symbol]);
  }

  get fullRealmUrl() {
    return _native_SyncSession_full_realm_url(this[_SyncSession_Symbol]);
  }

  $resetSharedPtr() {
    return _native_SyncSession_DOLLAR_resetSharedPtr(this[_SyncSession_Symbol]);
  }
};
const _SslVerifyCallback_Symbol = Symbol("Realm.SslVerifyCallback.external_pointer");
class SslVerifyCallback {
  constructor(ptr) {
    this[_SslVerifyCallback_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SslVerifyCallback)) throw new TypeError("Expected a SslVerifyCallback");
    const out = self[_SslVerifyCallback_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SslVerifyCallback");
    return out;
  }
}
const _SyncSubscriptionSet_Symbol = Symbol("Realm.SyncSubscriptionSet.external_pointer");
const _native_SyncSubscriptionSet_make_mutable_copy = nativeModule.SyncSubscriptionSet_make_mutable_copy;
const _native_SyncSubscriptionSet_get_state_change_notification =
  nativeModule.SyncSubscriptionSet_get_state_change_notification;
const _native_SyncSubscriptionSet_find_by_name = nativeModule.SyncSubscriptionSet_find_by_name;
const _native_SyncSubscriptionSet_find_by_query = nativeModule.SyncSubscriptionSet_find_by_query;
const _native_SyncSubscriptionSet_refresh = nativeModule.SyncSubscriptionSet_refresh;
const _native_SyncSubscriptionSet_version = nativeModule.SyncSubscriptionSet_version;
const _native_SyncSubscriptionSet_state = nativeModule.SyncSubscriptionSet_state;
const _native_SyncSubscriptionSet_error_str = nativeModule.SyncSubscriptionSet_error_str;
const _native_SyncSubscriptionSet_size = nativeModule.SyncSubscriptionSet_size;
const _native_SyncSubscriptionSet_Symbol_iterator = nativeModule.SyncSubscriptionSet_Symbol_iterator;
class SyncSubscriptionSet {
  constructor(ptr) {
    this[_SyncSubscriptionSet_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof SyncSubscriptionSet)) throw new TypeError("Expected a SyncSubscriptionSet");
    const out = self[_SyncSubscriptionSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed SyncSubscriptionSet");
    return out;
  }

  makeMutableCopy() {
    return _native_SyncSubscriptionSet_make_mutable_copy(this[_SyncSubscriptionSet_Symbol]);
  }

  getStateChangeNotification(notify_when) {
    return _promisify(false, (_cb) =>
      _native_SyncSubscriptionSet_get_state_change_notification(this[_SyncSubscriptionSet_Symbol], notify_when, _cb),
    );
  }

  findByName(name) {
    return _native_SyncSubscriptionSet_find_by_name(this[_SyncSubscriptionSet_Symbol], name);
  }

  findByQuery(query) {
    return _native_SyncSubscriptionSet_find_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }

  refresh() {
    return _native_SyncSubscriptionSet_refresh(this[_SyncSubscriptionSet_Symbol]);
  }

  get version() {
    return _native_SyncSubscriptionSet_version(this[_SyncSubscriptionSet_Symbol]);
  }

  get state() {
    return _native_SyncSubscriptionSet_state(this[_SyncSubscriptionSet_Symbol]);
  }

  get errorStr() {
    return _native_SyncSubscriptionSet_error_str(this[_SyncSubscriptionSet_Symbol]);
  }

  get size() {
    return _native_SyncSubscriptionSet_size(this[_SyncSubscriptionSet_Symbol]);
  }
  [Symbol.iterator]() {
    return _native_SyncSubscriptionSet_Symbol_iterator(this[_SyncSubscriptionSet_Symbol]);
  }
}
const _native_MutableSyncSubscriptionSet_clear = nativeModule.MutableSyncSubscriptionSet_clear;
const _native_MutableSyncSubscriptionSet_insert_or_assign_by_name =
  nativeModule.MutableSyncSubscriptionSet_insert_or_assign_by_name;
const _native_MutableSyncSubscriptionSet_insert_or_assign_by_query =
  nativeModule.MutableSyncSubscriptionSet_insert_or_assign_by_query;
const _native_MutableSyncSubscriptionSet_erase_by_name = nativeModule.MutableSyncSubscriptionSet_erase_by_name;
const _native_MutableSyncSubscriptionSet_erase_by_query = nativeModule.MutableSyncSubscriptionSet_erase_by_query;
const _native_MutableSyncSubscriptionSet_commit = nativeModule.MutableSyncSubscriptionSet_commit;
class MutableSyncSubscriptionSet extends SyncSubscriptionSet {
  static _extract(self) {
    if (!(self instanceof MutableSyncSubscriptionSet)) throw new TypeError("Expected a MutableSyncSubscriptionSet");
    const out = self[_SyncSubscriptionSet_Symbol];
    if (!out) throw new TypeError("received an improperly constructed MutableSyncSubscriptionSet");
    return out;
  }

  clear() {
    return _native_MutableSyncSubscriptionSet_clear(this[_SyncSubscriptionSet_Symbol]);
  }

  insertOrAssignByName(name, query) {
    return _native_MutableSyncSubscriptionSet_insert_or_assign_by_name(this[_SyncSubscriptionSet_Symbol], name, query);
  }

  insertOrAssignByQuery(query) {
    return _native_MutableSyncSubscriptionSet_insert_or_assign_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }

  eraseByName(name) {
    return _native_MutableSyncSubscriptionSet_erase_by_name(this[_SyncSubscriptionSet_Symbol], name);
  }

  eraseByQuery(query) {
    return _native_MutableSyncSubscriptionSet_erase_by_query(this[_SyncSubscriptionSet_Symbol], query);
  }

  commit() {
    return _native_MutableSyncSubscriptionSet_commit(this[_SyncSubscriptionSet_Symbol]);
  }
}
const _Scheduler_Symbol = Symbol("Realm.Scheduler.external_pointer");
class Scheduler {
  constructor(ptr) {
    this[_Scheduler_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof Scheduler)) throw new TypeError("Expected a Scheduler");
    const out = self[_Scheduler_Symbol];
    if (!out) throw new TypeError("received an improperly constructed Scheduler");
    return out;
  }
}
const _GenericNetworkTransport_Symbol = Symbol("Realm.GenericNetworkTransport.external_pointer");
class GenericNetworkTransport {
  constructor(ptr) {
    this[_GenericNetworkTransport_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof GenericNetworkTransport)) throw new TypeError("Expected a GenericNetworkTransport");
    const out = self[_GenericNetworkTransport_Symbol];
    if (!out) throw new TypeError("received an improperly constructed GenericNetworkTransport");
    return out;
  }
}
const _JsPlatformHelpers_Symbol = Symbol("Realm.JsPlatformHelpers.external_pointer");
const _native_JsPlatformHelpers_set_default_realm_file_directory =
  nativeModule.JsPlatformHelpers_set_default_realm_file_directory;
const _native_JsPlatformHelpers_default_realm_file_directory =
  nativeModule.JsPlatformHelpers_default_realm_file_directory;
const _native_JsPlatformHelpers_ensure_directory_exists_for_file =
  nativeModule.JsPlatformHelpers_ensure_directory_exists_for_file;
const _native_JsPlatformHelpers_copy_bundled_realm_files = nativeModule.JsPlatformHelpers_copy_bundled_realm_files;
const _native_JsPlatformHelpers_remove_realm_files_from_directory =
  nativeModule.JsPlatformHelpers_remove_realm_files_from_directory;
const _native_JsPlatformHelpers_remove_file = nativeModule.JsPlatformHelpers_remove_file;
const _native_JsPlatformHelpers_remove_directory = nativeModule.JsPlatformHelpers_remove_directory;
const _native_JsPlatformHelpers_get_cpu_arch = nativeModule.JsPlatformHelpers_get_cpu_arch;
class JsPlatformHelpers {
  constructor(ptr) {
    this[_JsPlatformHelpers_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof JsPlatformHelpers)) throw new TypeError("Expected a JsPlatformHelpers");
    const out = self[_JsPlatformHelpers_Symbol];
    if (!out) throw new TypeError("received an improperly constructed JsPlatformHelpers");
    return out;
  }

  static setDefaultRealmFileDirectory(dir) {
    return _native_JsPlatformHelpers_set_default_realm_file_directory(dir);
  }
  static defaultRealmFileDirectory() {
    return _native_JsPlatformHelpers_default_realm_file_directory();
  }
  static ensureDirectoryExistsForFile(file) {
    return _native_JsPlatformHelpers_ensure_directory_exists_for_file(file);
  }
  static copyBundledRealmFiles() {
    return _native_JsPlatformHelpers_copy_bundled_realm_files();
  }
  static removeRealmFilesFromDirectory(directory) {
    return _native_JsPlatformHelpers_remove_realm_files_from_directory(directory);
  }
  static removeFile(path) {
    return _native_JsPlatformHelpers_remove_file(path);
  }
  static removeDirectory(path) {
    return _native_JsPlatformHelpers_remove_directory(path);
  }
  static getCpuArch() {
    return _native_JsPlatformHelpers_get_cpu_arch();
  }
}
const _WeakSyncSession_Symbol = Symbol("Realm.WeakSyncSession.external_pointer");
const _native_WeakSyncSession_raw_dereference = nativeModule.WeakSyncSession_raw_dereference;
const _native_WeakSyncSession_weak_copy_of = nativeModule.WeakSyncSession_weak_copy_of;
class WeakSyncSession {
  constructor(ptr) {
    this[_WeakSyncSession_Symbol] = ptr;
  }
  static _extract(self) {
    if (!(self instanceof WeakSyncSession)) throw new TypeError("Expected a WeakSyncSession");
    const out = self[_WeakSyncSession_Symbol];
    if (!out) throw new TypeError("received an improperly constructed WeakSyncSession");
    return out;
  }

  rawDereference() {
    return _native_WeakSyncSession_raw_dereference(this[_WeakSyncSession_Symbol]);
  }
  static weakCopyOf(shared) {
    return _native_WeakSyncSession_weak_copy_of(shared);
  }
}
nativeModule.injectInjectables({
  Long: bson.Long,
  ArrayBuffer,
  Float,
  ObjectId: bson.ObjectId,
  UUID: bson.UUID,
  Decimal128: bson.Decimal128,
  EJSON_parse: bson.EJSON.parse,
  EJSON_stringify: bson.EJSON.stringify,
  Helpers,
  Logger,
  ConstTableRef,
  TableRef,
  Obj,
  Transaction,
  ObjectStore,
  Timestamp,
  Geospatial,
  ObjLink,
  KeyPathMapping,
  Query,
  SortDescriptor,
  TableView,
  Results: Results$1,
  Realm: Realm$1,
  RealmCoordinator,
  ObjectNotifier,
  NotificationToken,
  IndexSet,
  Collection: Collection$1,
  List: List$1,
  Set: Set$1,
  Dictionary: Dictionary$1,
  GoogleAuthCode,
  GoogleIdToken,
  AppCredentials,
  SyncUserSubscriptionToken,
  SyncUser,
  UserProfile,
  AppSubscriptionToken,
  App: App$1,
  WatchStream,
  PushClient: PushClient$1,
  UsernamePasswordProviderClient,
  UserApiKeyProviderClient,
  LoggerFactory,
  SyncManager,
  ThreadSafeReference,
  AsyncOpenTask,
  SyncSession: SyncSession$1,
  SslVerifyCallback,
  SyncSubscriptionSet,
  MutableSyncSubscriptionSet,
  Scheduler,
  GenericNetworkTransport,
  JsPlatformHelpers,
  WeakSyncSession,
});

////////////////////////////////////////////////////////////////////////////
IndexSet.prototype.asIndexes = function* () {
    for (const [from, to] of this) {
        let i = from;
        while (i < to) {
            yield i;
            i++;
        }
    }
};
Timestamp.fromDate = (d) => Timestamp.make(Int64.numToInt(Math.floor(d.valueOf() / 1000)), (d.valueOf() % 1000) * 1000000);
Timestamp.prototype.toDate = function () {
    return new Date(Number(this.seconds) * 1000 + this.nanoseconds / 1000000);
};
SyncSession$1.prototype.weaken = function () {
    try {
        return WeakSyncSession.weakCopyOf(this);
    }
    finally {
        this.$resetSharedPtr();
    }
};
WeakSyncSession.prototype.withDeref = function (callback) {
    const shared = this.rawDereference();
    try {
        return callback(shared);
    }
    finally {
        shared?.$resetSharedPtr();
    }
};
/** @internal */
class InvalidObjKey extends TypeError {
    constructor(input) {
        super(`Cannot convert '${input}' to an ObjKey`);
    }
}
/** @internal */
function stringToObjKey(input) {
    try {
        return Int64.strToInt(input);
    }
    catch {
        throw new InvalidObjKey(input);
    }
}
/** @internal */
function isEmptyObjKey(objKey) {
    // This relies on the JS representation of an ObjKey being a bigint
    return Int64.equals(objKey, -1);
}

////////////////////////////////////////////////////////////////////////////
const debug$2 = extendDebug("fs");
inject$2({
    isAbsolutePath(path) {
        return node_path.isAbsolute(path);
    },
    joinPaths(...segments) {
        return node_path.join(...segments);
    },
    removeFile(path) {
        debug$2("removeFile", path);
        if (node_fs.existsSync(path)) {
            node_fs.unlinkSync(path);
        }
    },
    removeDirectory(path) {
        debug$2("removeDirectory", path);
        node_fs.rmSync(path, { recursive: true, force: true });
    },
    ensureDirectoryForFile(path) {
        const parentPath = node_path.dirname(path);
        node_fs.mkdirSync(parentPath, { recursive: true });
    },
    setDefaultDirectoryPath(path) {
        debug$2("setDefaultDirectoryPath", path);
        return JsPlatformHelpers.setDefaultRealmFileDirectory(path);
    },
    getDefaultDirectoryPath() {
        return JsPlatformHelpers.defaultRealmFileDirectory();
    },
    exists(path) {
        debug$2("exists", path);
        return node_fs.existsSync(path);
    },
    copyBundledRealmFiles() {
        throw new Error("Realm for Node does not support this method.");
    },
    /*
    readDirectory(path) {
      return readdirSync(path, { encoding: "utf8", withFileTypes: true });
    },
    */
    removeRealmFilesFromDirectory(path) {
        debug$2("removeRealmFilesFromDirectory", path);
        for (const dirent of node_fs.readdirSync(path, { encoding: "utf8", withFileTypes: true })) {
            const direntPath = node_path.join(path, dirent.name);
            if (dirent.isDirectory() && dirent.name.endsWith(".realm.management")) {
                node_fs.rmSync(direntPath, { recursive: true, force: true });
            }
            else if (dirent.name.endsWith(".realm") ||
                dirent.name.endsWith(".realm.note") ||
                dirent.name.endsWith(".realm.lock") ||
                dirent.name.endsWith(".realm.fresh.lock") ||
                dirent.name.endsWith(".realm.log")) {
                node_fs.unlinkSync(direntPath);
            }
        }
    },
});

var version = "12.1.0";

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const deviceInfo = {
    create() {
        throw new Error("Not supported on this platform");
    },
};
function inject$1(injected) {
    Object.freeze(Object.assign(deviceInfo, injected));
}

////////////////////////////////////////////////////////////////////////////
inject$1({
    create() {
        return {
            sdk: "JS",
            sdkVersion: version,
            platform: os.type(),
            platformVersion: os.release(),
            deviceName: "unknown",
            deviceVersion: "unknown",
            cpuArch: os.arch(),
            frameworkName: typeof process.versions.electron === "string" ? "Electron" : "Node.js",
            frameworkVersion: process.versions.electron || process.version,
            bundleId: realmConstants_json.REALM_ANONYMIZED_BUNDLE_ID,
        };
    },
});

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const syncProxyConfig = {
    create() {
        throw new Error("proxyConfig is not supported on this platform");
    },
};
function inject(injected) {
    Object.freeze(Object.assign(syncProxyConfig, injected));
}

////////////////////////////////////////////////////////////////////////////
inject({
    create() {
        for (const envVar of ["HTTPS_PROXY", "https_proxy", "HTTP_PROXY", "http_proxy"]) {
            const proxyUrlAsString = process.env[envVar];
            if (proxyUrlAsString) {
                let type;
                const proxyUrl = new node_url.URL(proxyUrlAsString);
                const protocol = proxyUrl.protocol;
                if (protocol === "http:") {
                    type = 0 /* ProxyType.Http */;
                }
                else if (protocol === "https:") {
                    type = 1 /* ProxyType.Https */;
                }
                else {
                    throw new Error(`Expected either 'http' or 'https' as protocol for ${envVar} (got ${protocol})`);
                }
                const config = {
                    address: proxyUrl.hostname,
                    type,
                    port: parseInt(proxyUrl.port, 10),
                };
                return config;
            }
        }
        // no environment variable found, and we skip the proxy configuration
        return undefined;
    },
});

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
// Exports a globalThis which is polyfilled for iOS 11/12
// From https://github.com/zloirock/core-js/blob/v3.27.2/packages/core-js/internals/global.js
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const check = function (it) {
    return it && it.Math === Math && it;
};
/** @internal */
// eslint-disable-next-line no-restricted-globals
const safeGlobalThis = 
// eslint-disable-next-line no-restricted-globals
check(typeof globalThis === "object" && globalThis) ||
    // @ts-expect-error We're relying on an identifier that might not be there
    check(typeof window === "object" && window) ||
    // eslint-disable-next-line no-restricted-globals -- safe
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `self`
    check(typeof self === "object" && self) ||
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore allow `global`
    check(typeof global === "object" && global) ||
    // eslint-disable-next-line no-new-func -- fallback
    (function () {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore allow `this`
        return this;
    })() ||
    Function("return this")();

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * @copyright 2015 Toru Nagashima. All rights reserved.
 * See LICENSE file in root directory for full license.
 */
/**
 * @typedef {object} PrivateData
 * @property {EventTarget} eventTarget The event target.
 * @property {{type:string}} event The original event object.
 * @property {number} eventPhase The current event phase.
 * @property {EventTarget|null} currentTarget The current event target.
 * @property {boolean} canceled The flag to prevent default.
 * @property {boolean} stopped The flag to stop propagation.
 * @property {boolean} immediateStopped The flag to stop propagation immediately.
 * @property {Function|null} passiveListener The listener if the current listener is passive. Otherwise this is null.
 * @property {number} timeStamp The unix time.
 * @private
 */

/**
 * Private data for event wrappers.
 * @type {WeakMap<Event, PrivateData>}
 * @private
 */
const privateData = new WeakMap();

/**
 * Cache for wrapper classes.
 * @type {WeakMap<Object, Function>}
 * @private
 */
const wrappers = new WeakMap();

/**
 * Get private data.
 * @param {Event} event The event object to get private data.
 * @returns {PrivateData} The private data of the event.
 * @private
 */
function pd(event) {
    const retv = privateData.get(event);
    console.assert(
        retv != null,
        "'this' is expected an Event object, but got",
        event
    );
    return retv
}

/**
 * https://dom.spec.whatwg.org/#set-the-canceled-flag
 * @param data {PrivateData} private data.
 */
function setCancelFlag(data) {
    if (data.passiveListener != null) {
        if (
            typeof console !== "undefined" &&
            typeof console.error === "function"
        ) {
            console.error(
                "Unable to preventDefault inside passive event listener invocation.",
                data.passiveListener
            );
        }
        return
    }
    if (!data.event.cancelable) {
        return
    }

    data.canceled = true;
    if (typeof data.event.preventDefault === "function") {
        data.event.preventDefault();
    }
}

/**
 * @see https://dom.spec.whatwg.org/#interface-event
 * @private
 */
/**
 * The event wrapper.
 * @constructor
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Event|{type:string}} event The original event to wrap.
 */
function Event(eventTarget, event) {
    privateData.set(this, {
        eventTarget,
        event,
        eventPhase: 2,
        currentTarget: eventTarget,
        canceled: false,
        stopped: false,
        immediateStopped: false,
        passiveListener: null,
        timeStamp: event.timeStamp || Date.now(),
    });

    // https://heycam.github.io/webidl/#Unforgeable
    Object.defineProperty(this, "isTrusted", { value: false, enumerable: true });

    // Define accessors
    const keys = Object.keys(event);
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in this)) {
            Object.defineProperty(this, key, defineRedirectDescriptor(key));
        }
    }
}

// Should be enumerable, but class methods are not enumerable.
Event.prototype = {
    /**
     * The type of this event.
     * @type {string}
     */
    get type() {
        return pd(this).event.type
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get target() {
        return pd(this).eventTarget
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     */
    get currentTarget() {
        return pd(this).currentTarget
    },

    /**
     * @returns {EventTarget[]} The composed path of this event.
     */
    composedPath() {
        const currentTarget = pd(this).currentTarget;
        if (currentTarget == null) {
            return []
        }
        return [currentTarget]
    },

    /**
     * Constant of NONE.
     * @type {number}
     */
    get NONE() {
        return 0
    },

    /**
     * Constant of CAPTURING_PHASE.
     * @type {number}
     */
    get CAPTURING_PHASE() {
        return 1
    },

    /**
     * Constant of AT_TARGET.
     * @type {number}
     */
    get AT_TARGET() {
        return 2
    },

    /**
     * Constant of BUBBLING_PHASE.
     * @type {number}
     */
    get BUBBLING_PHASE() {
        return 3
    },

    /**
     * The target of this event.
     * @type {number}
     */
    get eventPhase() {
        return pd(this).eventPhase
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopPropagation() {
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.stopPropagation === "function") {
            data.event.stopPropagation();
        }
    },

    /**
     * Stop event bubbling.
     * @returns {void}
     */
    stopImmediatePropagation() {
        const data = pd(this);

        data.stopped = true;
        data.immediateStopped = true;
        if (typeof data.event.stopImmediatePropagation === "function") {
            data.event.stopImmediatePropagation();
        }
    },

    /**
     * The flag to be bubbling.
     * @type {boolean}
     */
    get bubbles() {
        return Boolean(pd(this).event.bubbles)
    },

    /**
     * The flag to be cancelable.
     * @type {boolean}
     */
    get cancelable() {
        return Boolean(pd(this).event.cancelable)
    },

    /**
     * Cancel this event.
     * @returns {void}
     */
    preventDefault() {
        setCancelFlag(pd(this));
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     */
    get defaultPrevented() {
        return pd(this).canceled
    },

    /**
     * The flag to be composed.
     * @type {boolean}
     */
    get composed() {
        return Boolean(pd(this).event.composed)
    },

    /**
     * The unix time of this event.
     * @type {number}
     */
    get timeStamp() {
        return pd(this).timeStamp
    },

    /**
     * The target of this event.
     * @type {EventTarget}
     * @deprecated
     */
    get srcElement() {
        return pd(this).eventTarget
    },

    /**
     * The flag to stop event bubbling.
     * @type {boolean}
     * @deprecated
     */
    get cancelBubble() {
        return pd(this).stopped
    },
    set cancelBubble(value) {
        if (!value) {
            return
        }
        const data = pd(this);

        data.stopped = true;
        if (typeof data.event.cancelBubble === "boolean") {
            data.event.cancelBubble = true;
        }
    },

    /**
     * The flag to indicate cancellation state.
     * @type {boolean}
     * @deprecated
     */
    get returnValue() {
        return !pd(this).canceled
    },
    set returnValue(value) {
        if (!value) {
            setCancelFlag(pd(this));
        }
    },

    /**
     * Initialize this event object. But do nothing under event dispatching.
     * @param {string} type The event type.
     * @param {boolean} [bubbles=false] The flag to be possible to bubble up.
     * @param {boolean} [cancelable=false] The flag to be possible to cancel.
     * @deprecated
     */
    initEvent() {
        // Do nothing.
    },
};

// `constructor` is not enumerable.
Object.defineProperty(Event.prototype, "constructor", {
    value: Event,
    configurable: true,
    writable: true,
});

// Ensure `event instanceof window.Event` is `true`.
if (typeof window !== "undefined" && typeof window.Event !== "undefined") {
    Object.setPrototypeOf(Event.prototype, window.Event.prototype);

    // Make association for wrappers.
    wrappers.set(window.Event.prototype, Event);
}

/**
 * Get the property descriptor to redirect a given property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to redirect the property.
 * @private
 */
function defineRedirectDescriptor(key) {
    return {
        get() {
            return pd(this).event[key]
        },
        set(value) {
            pd(this).event[key] = value;
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Get the property descriptor to call a given method property.
 * @param {string} key Property name to define property descriptor.
 * @returns {PropertyDescriptor} The property descriptor to call the method property.
 * @private
 */
function defineCallDescriptor(key) {
    return {
        value() {
            const event = pd(this).event;
            return event[key].apply(event, arguments)
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define new wrapper class.
 * @param {Function} BaseEvent The base wrapper class.
 * @param {Object} proto The prototype of the original event.
 * @returns {Function} The defined wrapper class.
 * @private
 */
function defineWrapper(BaseEvent, proto) {
    const keys = Object.keys(proto);
    if (keys.length === 0) {
        return BaseEvent
    }

    /** CustomEvent */
    function CustomEvent(eventTarget, event) {
        BaseEvent.call(this, eventTarget, event);
    }

    CustomEvent.prototype = Object.create(BaseEvent.prototype, {
        constructor: { value: CustomEvent, configurable: true, writable: true },
    });

    // Define accessors.
    for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (!(key in BaseEvent.prototype)) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, key);
            const isFunc = typeof descriptor.value === "function";
            Object.defineProperty(
                CustomEvent.prototype,
                key,
                isFunc
                    ? defineCallDescriptor(key)
                    : defineRedirectDescriptor(key)
            );
        }
    }

    return CustomEvent
}

/**
 * Get the wrapper class of a given prototype.
 * @param {Object} proto The prototype of the original event to get its wrapper.
 * @returns {Function} The wrapper class.
 * @private
 */
function getWrapper(proto) {
    if (proto == null || proto === Object.prototype) {
        return Event
    }

    let wrapper = wrappers.get(proto);
    if (wrapper == null) {
        wrapper = defineWrapper(getWrapper(Object.getPrototypeOf(proto)), proto);
        wrappers.set(proto, wrapper);
    }
    return wrapper
}

/**
 * Wrap a given event to management a dispatching.
 * @param {EventTarget} eventTarget The event target of this dispatching.
 * @param {Object} event The event to wrap.
 * @returns {Event} The wrapper instance.
 * @private
 */
function wrapEvent(eventTarget, event) {
    const Wrapper = getWrapper(Object.getPrototypeOf(event));
    return new Wrapper(eventTarget, event)
}

/**
 * Get the immediateStopped flag of a given event.
 * @param {Event} event The event to get.
 * @returns {boolean} The flag to stop propagation immediately.
 * @private
 */
function isStopped(event) {
    return pd(event).immediateStopped
}

/**
 * Set the current event phase of a given event.
 * @param {Event} event The event to set current target.
 * @param {number} eventPhase New event phase.
 * @returns {void}
 * @private
 */
function setEventPhase(event, eventPhase) {
    pd(event).eventPhase = eventPhase;
}

/**
 * Set the current target of a given event.
 * @param {Event} event The event to set current target.
 * @param {EventTarget|null} currentTarget New current target.
 * @returns {void}
 * @private
 */
function setCurrentTarget(event, currentTarget) {
    pd(event).currentTarget = currentTarget;
}

/**
 * Set a passive listener of a given event.
 * @param {Event} event The event to set current target.
 * @param {Function|null} passiveListener New passive listener.
 * @returns {void}
 * @private
 */
function setPassiveListener(event, passiveListener) {
    pd(event).passiveListener = passiveListener;
}

/**
 * @typedef {object} ListenerNode
 * @property {Function} listener
 * @property {1|2|3} listenerType
 * @property {boolean} passive
 * @property {boolean} once
 * @property {ListenerNode|null} next
 * @private
 */

/**
 * @type {WeakMap<object, Map<string, ListenerNode>>}
 * @private
 */
const listenersMap = new WeakMap();

// Listener types
const CAPTURE = 1;
const BUBBLE = 2;
const ATTRIBUTE = 3;

/**
 * Check whether a given value is an object or not.
 * @param {any} x The value to check.
 * @returns {boolean} `true` if the value is an object.
 */
function isObject(x) {
    return x !== null && typeof x === "object" //eslint-disable-line no-restricted-syntax
}

/**
 * Get listeners.
 * @param {EventTarget} eventTarget The event target to get.
 * @returns {Map<string, ListenerNode>} The listeners.
 * @private
 */
function getListeners(eventTarget) {
    const listeners = listenersMap.get(eventTarget);
    if (listeners == null) {
        throw new TypeError(
            "'this' is expected an EventTarget object, but got another value."
        )
    }
    return listeners
}

/**
 * Get the property descriptor for the event attribute of a given event.
 * @param {string} eventName The event name to get property descriptor.
 * @returns {PropertyDescriptor} The property descriptor.
 * @private
 */
function defineEventAttributeDescriptor(eventName) {
    return {
        get() {
            const listeners = getListeners(this);
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    return node.listener
                }
                node = node.next;
            }
            return null
        },

        set(listener) {
            if (typeof listener !== "function" && !isObject(listener)) {
                listener = null; // eslint-disable-line no-param-reassign
            }
            const listeners = getListeners(this);

            // Traverse to the tail while removing old value.
            let prev = null;
            let node = listeners.get(eventName);
            while (node != null) {
                if (node.listenerType === ATTRIBUTE) {
                    // Remove old value.
                    if (prev !== null) {
                        prev.next = node.next;
                    } else if (node.next !== null) {
                        listeners.set(eventName, node.next);
                    } else {
                        listeners.delete(eventName);
                    }
                } else {
                    prev = node;
                }

                node = node.next;
            }

            // Add new value.
            if (listener !== null) {
                const newNode = {
                    listener,
                    listenerType: ATTRIBUTE,
                    passive: false,
                    once: false,
                    next: null,
                };
                if (prev === null) {
                    listeners.set(eventName, newNode);
                } else {
                    prev.next = newNode;
                }
            }
        },
        configurable: true,
        enumerable: true,
    }
}

/**
 * Define an event attribute (e.g. `eventTarget.onclick`).
 * @param {Object} eventTargetPrototype The event target prototype to define an event attrbite.
 * @param {string} eventName The event name to define.
 * @returns {void}
 */
function defineEventAttribute(eventTargetPrototype, eventName) {
    Object.defineProperty(
        eventTargetPrototype,
        `on${eventName}`,
        defineEventAttributeDescriptor(eventName)
    );
}

/**
 * Define a custom EventTarget with event attributes.
 * @param {string[]} eventNames Event names for event attributes.
 * @returns {EventTarget} The custom EventTarget.
 * @private
 */
function defineCustomEventTarget(eventNames) {
    /** CustomEventTarget */
    function CustomEventTarget() {
        EventTarget.call(this);
    }

    CustomEventTarget.prototype = Object.create(EventTarget.prototype, {
        constructor: {
            value: CustomEventTarget,
            configurable: true,
            writable: true,
        },
    });

    for (let i = 0; i < eventNames.length; ++i) {
        defineEventAttribute(CustomEventTarget.prototype, eventNames[i]);
    }

    return CustomEventTarget
}

/**
 * EventTarget.
 *
 * - This is constructor if no arguments.
 * - This is a function which returns a CustomEventTarget constructor if there are arguments.
 *
 * For example:
 *
 *     class A extends EventTarget {}
 *     class B extends EventTarget("message") {}
 *     class C extends EventTarget("message", "error") {}
 *     class D extends EventTarget(["message", "error"]) {}
 */
function EventTarget() {
    /*eslint-disable consistent-return */
    if (this instanceof EventTarget) {
        listenersMap.set(this, new Map());
        return
    }
    if (arguments.length === 1 && Array.isArray(arguments[0])) {
        return defineCustomEventTarget(arguments[0])
    }
    if (arguments.length > 0) {
        const types = new Array(arguments.length);
        for (let i = 0; i < arguments.length; ++i) {
            types[i] = arguments[i];
        }
        return defineCustomEventTarget(types)
    }
    throw new TypeError("Cannot call a class as a function")
    /*eslint-enable consistent-return */
}

// Should be enumerable, but class methods are not enumerable.
EventTarget.prototype = {
    /**
     * Add a given listener to this event target.
     * @param {string} eventName The event name to add.
     * @param {Function} listener The listener to add.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    addEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }
        if (typeof listener !== "function" && !isObject(listener)) {
            throw new TypeError("'listener' should be a function or an object.")
        }

        const listeners = getListeners(this);
        const optionsIsObj = isObject(options);
        const capture = optionsIsObj
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;
        const newNode = {
            listener,
            listenerType,
            passive: optionsIsObj && Boolean(options.passive),
            once: optionsIsObj && Boolean(options.once),
            next: null,
        };

        // Set it as the first node if the first node is null.
        let node = listeners.get(eventName);
        if (node === undefined) {
            listeners.set(eventName, newNode);
            return
        }

        // Traverse to the tail while checking duplication..
        let prev = null;
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                // Should ignore duplication.
                return
            }
            prev = node;
            node = node.next;
        }

        // Add it.
        prev.next = newNode;
    },

    /**
     * Remove a given listener from this event target.
     * @param {string} eventName The event name to remove.
     * @param {Function} listener The listener to remove.
     * @param {boolean|{capture?:boolean,passive?:boolean,once?:boolean}} [options] The options for this listener.
     * @returns {void}
     */
    removeEventListener(eventName, listener, options) {
        if (listener == null) {
            return
        }

        const listeners = getListeners(this);
        const capture = isObject(options)
            ? Boolean(options.capture)
            : Boolean(options);
        const listenerType = capture ? CAPTURE : BUBBLE;

        let prev = null;
        let node = listeners.get(eventName);
        while (node != null) {
            if (
                node.listener === listener &&
                node.listenerType === listenerType
            ) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
                return
            }

            prev = node;
            node = node.next;
        }
    },

    /**
     * Dispatch a given event.
     * @param {Event|{type:string}} event The event to dispatch.
     * @returns {boolean} `false` if canceled.
     */
    dispatchEvent(event) {
        if (event == null || typeof event.type !== "string") {
            throw new TypeError('"event.type" should be a string.')
        }

        // If listeners aren't registered, terminate.
        const listeners = getListeners(this);
        const eventName = event.type;
        let node = listeners.get(eventName);
        if (node == null) {
            return true
        }

        // Since we cannot rewrite several properties, so wrap object.
        const wrappedEvent = wrapEvent(this, event);

        // This doesn't process capturing phase and bubbling phase.
        // This isn't participating in a tree.
        let prev = null;
        while (node != null) {
            // Remove this listener if it's once
            if (node.once) {
                if (prev !== null) {
                    prev.next = node.next;
                } else if (node.next !== null) {
                    listeners.set(eventName, node.next);
                } else {
                    listeners.delete(eventName);
                }
            } else {
                prev = node;
            }

            // Call this listener
            setPassiveListener(
                wrappedEvent,
                node.passive ? node.listener : null
            );
            if (typeof node.listener === "function") {
                try {
                    node.listener.call(this, wrappedEvent);
                } catch (err) {
                    if (
                        typeof console !== "undefined" &&
                        typeof console.error === "function"
                    ) {
                        console.error(err);
                    }
                }
            } else if (
                node.listenerType !== ATTRIBUTE &&
                typeof node.listener.handleEvent === "function"
            ) {
                node.listener.handleEvent(wrappedEvent);
            }

            // Break if `event.stopImmediatePropagation` was called.
            if (isStopped(wrappedEvent)) {
                break
            }

            node = node.next;
        }
        setPassiveListener(wrappedEvent, null);
        setEventPhase(wrappedEvent, 0);
        setCurrentTarget(wrappedEvent, null);

        return !wrappedEvent.defaultPrevented
    },
};

// `constructor` is not enumerable.
Object.defineProperty(EventTarget.prototype, "constructor", {
    value: EventTarget,
    configurable: true,
    writable: true,
});

// Ensure `eventTarget instanceof window.EventTarget` is `true`.
if (
    typeof window !== "undefined" &&
    typeof window.EventTarget !== "undefined"
) {
    Object.setPrototypeOf(EventTarget.prototype, window.EventTarget.prototype);
}

/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */

/**
 * The signal class.
 * @see https://dom.spec.whatwg.org/#abortsignal
 */
class AbortSignal extends EventTarget {
    /**
     * AbortSignal cannot be constructed directly.
     */
    constructor() {
        super();
        throw new TypeError("AbortSignal cannot be constructed directly");
    }
    /**
     * Returns `true` if this `AbortSignal`'s `AbortController` has signaled to abort, and `false` otherwise.
     */
    get aborted() {
        const aborted = abortedFlags.get(this);
        if (typeof aborted !== "boolean") {
            throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this === null ? "null" : typeof this}`);
        }
        return aborted;
    }
}
defineEventAttribute(AbortSignal.prototype, "abort");
/**
 * Create an AbortSignal object.
 */
function createAbortSignal() {
    const signal = Object.create(AbortSignal.prototype);
    EventTarget.call(signal);
    abortedFlags.set(signal, false);
    return signal;
}
/**
 * Abort a given signal.
 */
function abortSignal(signal) {
    if (abortedFlags.get(signal) !== false) {
        return;
    }
    abortedFlags.set(signal, true);
    signal.dispatchEvent({ type: "abort" });
}
/**
 * Aborted flag for each instances.
 */
const abortedFlags = new WeakMap();
// Properties should be enumerable.
Object.defineProperties(AbortSignal.prototype, {
    aborted: { enumerable: true },
});
// `toString()` should return `"[object AbortSignal]"`
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortSignal.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortSignal",
    });
}

/**
 * The AbortController.
 * @see https://dom.spec.whatwg.org/#abortcontroller
 */
class AbortController {
    /**
     * Initialize this controller.
     */
    constructor() {
        signals.set(this, createAbortSignal());
    }
    /**
     * Returns the `AbortSignal` object associated with this object.
     */
    get signal() {
        return getSignal(this);
    }
    /**
     * Abort and signal to any observers that the associated activity is to be aborted.
     */
    abort() {
        abortSignal(getSignal(this));
    }
}
/**
 * Associated signals.
 */
const signals = new WeakMap();
/**
 * Get the associated signal of a given controller.
 */
function getSignal(controller) {
    const signal = signals.get(controller);
    if (signal == null) {
        throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${controller === null ? "null" : typeof controller}`);
    }
    return signal;
}
// Properties should be enumerable.
Object.defineProperties(AbortController.prototype, {
    signal: { enumerable: true },
    abort: { enumerable: true },
});
if (typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol") {
    Object.defineProperty(AbortController.prototype, Symbol.toStringTag, {
        configurable: true,
        value: "AbortController",
    });
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
// Falling back on a known string used in code transpiled by Babel
const asyncIteratorSymbol = Symbol.asyncIterator || "@@asyncIterator";
const READABLE_STREAM_HANDLER = {
    get(target, prop, receiver) {
        if (prop === asyncIteratorSymbol) {
            return () => {
                const reader = target.getReader();
                return {
                    next() {
                        return reader.read();
                    },
                    async return() {
                        await reader.cancel();
                        return { done: true, value: null };
                    },
                };
            };
        }
        return Reflect.get(target, prop, receiver);
    },
};
/**
 * This method ensures that a ReadableStream is iterable, wraps in a proxy with the {@link Symbol.asyncIterator} if missing.
 * @param response
 * @returns An async iterator.
 */
function makeStreamIterable(stream) {
    if (asyncIteratorSymbol in stream) {
        return stream;
    }
    else if ("getReader" in stream) {
        return new Proxy(stream, READABLE_STREAM_HANDLER);
    }
    else {
        throw new Error("Expected a `getReader` method on ReadableStream");
    }
}
const RESPONSE_HANDLER = {
    get(target, prop, receiver) {
        if (prop === "body") {
            const body = target.body;
            if (body) {
                return makeStreamIterable(body);
            }
            return body;
        }
        return Reflect.get(target, prop, receiver);
    },
};
/**
 * This method ensures that a ReadableStream is iterable, wraps in a proxy with the {@link Symbol.asyncIterator} if missing.
 * @param response
 * @returns An async iterator.
 */
function makeRequestBodyIterable(response) {
    return new Proxy(response, RESPONSE_HANDLER);
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
 */
const HTTP_STATUS_TEXTS = {
    100: "Continue",
    101: "Switching Protocols",
    102: "Processing",
    200: "OK",
    201: "Created",
    202: "Accepted",
    203: "Non-Authoritative Information",
    204: "No Content",
    205: "Reset Content",
    206: "Partial Content",
    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Found",
    303: "See Other",
    304: "Not Modified",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    412: "Precondition Failed",
    413: "Payload Too Large",
    414: "URI Too Long",
    415: "Unsupported Media Type",
    416: "Range Not Satisfiable",
    417: "Expectation Failed",
    418: "I'm a teapot",
    422: "Unprocessable Entity",
    425: "Too Early",
    426: "Upgrade Required",
    429: "Too Many Requests",
    431: "Request Header Fields Too Large",
    451: "Unavailable For Legal Reasons",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout",
    505: "HTTP Version Not Supported",
    506: "Variant Also Negotiates",
    507: "Insufficient Storage",
    508: "Loop Detected",
    510: "Not Extended",
    511: "Network Authentication Required",
};
function deriveStatusText(status) {
    return HTTP_STATUS_TEXTS[status];
}

////////////////////////////////////////////////////////////////////////////
class DefaultNetworkTransport {
    static createTimeoutSignal(timeoutMs) {
        if (typeof timeoutMs === "number") {
            const controller = new DefaultNetworkTransport.AbortController();
            // Call abort after a specific number of milliseconds
            const timeout = setTimeout(() => {
                controller.abort();
            }, timeoutMs);
            return {
                signal: controller.signal,
                cancelTimeout: () => {
                    clearTimeout(timeout);
                },
            };
        }
        else {
            return {
                signal: undefined,
                cancelTimeout: () => {
                    /* No-op */
                },
            };
        }
    }
    constructor() {
        if (!DefaultNetworkTransport.fetch) {
            throw new Error("DefaultNetworkTransport.fetch must be set before it's used");
        }
        if (!DefaultNetworkTransport.AbortController) {
            throw new Error("DefaultNetworkTransport.AbortController must be set before it's used");
        }
    }
    /** @deprecated Not used by the `bindgen` SDK and can be deleted */
    fetchWithCallbacks(request, handler) {
        // tslint:disable-next-line: no-console
        this.fetch(request)
            .then(async (response) => {
            const decodedBody = await response.text();
            // Pull out the headers of the response
            const responseHeaders = {};
            response.headers.forEach((value, key) => {
                responseHeaders[key] = value;
            });
            return {
                statusCode: response.status,
                headers: responseHeaders,
                body: decodedBody,
            };
        })
            .then((r) => handler.onSuccess(r))
            .catch((e) => handler.onError(e));
    }
    async fetch(request) {
        const { timeoutMs, url, ...rest } = request;
        const { signal, cancelTimeout } = DefaultNetworkTransport.createTimeoutSignal(timeoutMs);
        try {
            // Awaiting the response to cancel timeout on errors
            const response = await DefaultNetworkTransport.fetch(url, {
                ...DefaultNetworkTransport.extraFetchOptions,
                signal,
                ...rest,
            });
            // A bug in the React Native fetch polyfill leaves the statusText empty
            if (response.statusText === "") {
                const statusText = deriveStatusText(response.status);
                // @ts-expect-error Assigning to a read-only property
                response.statusText = statusText;
            }
            // Wraps the body of the request in an iterable interface
            return makeRequestBodyIterable(response);
        }
        finally {
            // Whatever happens, cancel any timeout
            cancelTimeout();
        }
    }
}
DefaultNetworkTransport.DEFAULT_HEADERS = {
    "Content-Type": "application/json",
};

////////////////////////////////////////////////////////////////////////////
DefaultNetworkTransport.fetch = fetch;
DefaultNetworkTransport.AbortController = AbortController;

////////////////////////////////////////////////////////////////////////////
const debug$1 = extendDebug("network");
const transport = new DefaultNetworkTransport();
const HTTP_METHOD = {
    [0 /* binding.HttpMethod.Get */]: "GET",
    [1 /* binding.HttpMethod.Post */]: "POST",
    [3 /* binding.HttpMethod.Put */]: "PUT",
    [2 /* binding.HttpMethod.Patch */]: "PATCH",
    [4 /* binding.HttpMethod.Del */]: "DELETE",
};
function toFetchRequest({ method, timeoutMs, body, headers, url }) {
    return {
        url,
        headers,
        method: HTTP_METHOD[method],
        timeoutMs: Number(timeoutMs),
        body: body !== "" ? body : undefined,
    };
}
const network = {
    async fetch(request) {
        debug$1("Requesting %O", request);
        const fetchRequest = typeof request.method === "string" ? request : toFetchRequest(request);
        const response = await transport.fetch(fetchRequest);
        debug$1("Responded %O", response);
        return response;
    },
};

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
const flags = {
    /**
     * When enabled, objects can be created by providing an array of values (in the order that they were declared in the object schema) in addition to of an object of property values.
     */
    ALLOW_VALUES_ARRAYS: false,
    /**
     * When enabled, accessing the `Realm` without first importing it from the Realm package, will throw.
     * Helps finding places where the app is depending on the now deprecated way of using the package.
     */
    THROW_ON_GLOBAL_REALM: false,
    /**
     * Enables calling internal, test-only functions like `Realm.clearTestState`.
     * This is disabled by default, mainly because the data-structures needed to support this, introduce minor memory leaks if clearTestState() is not called regularly and are not intended for production use.
     */
    ALLOW_CLEAR_TEST_STATE: false,
};

////////////////////////////////////////////////////////////////////////////
/**
 * Re-export a subset of the "bson" package, enabling access to the BSON types without requiring an explicit dependency on the "bson" package.
 * @see {@link https://www.npmjs.com/package/bson#documentation|the BSON documentation} for more information.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
exports.BSON = void 0;
(function (BSON) {
    BSON.ObjectId = bson__namespace.ObjectId;
    BSON.ObjectID = bson__namespace.ObjectID;
    BSON.Decimal128 = bson__namespace.Decimal128;
    BSON.UUID = bson__namespace.UUID;
    BSON.Binary = bson__namespace.Binary;
    BSON.EJSON = bson__namespace.EJSON;
})(exports.BSON || (exports.BSON = {}));

////////////////////////////////////////////////////////////////////////////
class AssertionError extends Error {
    /** @internal */
    constructor(message = "Assertion failed!") {
        super(message);
    }
}
class TypeAssertionError extends AssertionError {
    expected;
    value;
    /** @internal */
    static deriveType(value) {
        if (typeof value === "object") {
            if (value === null) {
                return "null";
            }
            else {
                const name = value.constructor.name;
                if (name === "Object") {
                    return "an object";
                }
                else if (name === "Array") {
                    return "an array";
                }
                else {
                    return "an instance of " + name;
                }
            }
        }
        else if (typeof value === "undefined") {
            return typeof value;
        }
        else if (typeof value === "function") {
            return `a function or class named ${value.name}`;
        }
        else {
            return "a " + typeof value;
        }
    }
    /**
     * Get an error message for when the target's value is of
     * the wrong type. Single quotes are added around the target
     * string if it does not already contain one.
     * @internal
     */
    static message(expected, value, target) {
        const actual = TypeAssertionError.deriveType(value);
        if (target) {
            target = target.includes("'") ? target : `'${target}'`;
        }
        else {
            target = "value";
        }
        return `Expected ${target} to be ${expected}, got ${actual}`;
    }
    /** @internal */
    constructor(/** @internal */ expected, /** @internal */ value, target) {
        super(TypeAssertionError.message(expected, value, target));
        this.expected = expected;
        this.value = value;
    }
    /** @internal */
    rename(name) {
        this.message = TypeAssertionError.message(this.expected, this.value, name);
    }
}
class IllegalConstructorError extends Error {
    constructor(type) {
        super(`Illegal constructor: ${type} objects are read from managed objects only.`);
    }
}
class TimeoutError extends Error {
    constructor(message) {
        super(`Timed out: ${message}`);
    }
}
class SchemaParseError extends Error {
    /** @internal */
    constructor(message) {
        super(message);
    }
}
class ObjectSchemaParseError extends SchemaParseError {
    objectName;
    /** @internal */
    constructor(message, info) {
        const displayName = info.objectName ? `object '${info.objectName}'` : "unnamed object";
        super(`Invalid schema for ${displayName}: ${message}`);
        this.objectName = info.objectName;
    }
}
class PropertySchemaParseError extends SchemaParseError {
    objectName;
    propertyName;
    /** @internal */
    constructor(message, info) {
        super(`Invalid type declaration for property '${info.propertyName}' on '${info.objectName}': ${message}`);
        this.objectName = info.objectName;
        this.propertyName = info.propertyName;
    }
}
/** @internal */
function fromBindingSyncError(error) {
    if (error.systemError.code === 231) {
        return new CompensatingWriteError(error);
    }
    else if (error.isClientResetRequested) {
        return new ClientResetError(error);
    }
    else {
        return new SyncError(error);
    }
}
/**
 * An class describing a sync error.
 */
class SyncError extends Error {
    name = "SyncError";
    /**
     * The error code that represents this error.
     */
    code;
    /**
     * The category of this error.
     */
    category;
    /**
     * The URL to the associated server log, if available. The string will be empty
     * if the sync error is not initiated by the server.
     */
    logUrl;
    /**
     * A record of extra user information associated with this error.
     */
    userInfo;
    /**
     * @deprecated Check the error message instead.
     */
    isFatal;
    /** @internal */
    constructor(error) {
        super(error.simpleMessage);
        const { systemError } = error;
        this.code = systemError.code;
        this.category = systemError.category;
        this.logUrl = error.logUrl;
        this.userInfo = error.userInfo;
        this.isFatal = error.isFatal;
    }
}
const RECOVERY_FILE_PATH_KEY = "RECOVERY_FILE_PATH";
/**
 * @deprecated Use the another {@link ClientResetMode} than {@link ClientResetMode.Manual}.
 * @see https://github.com/realm/realm-js/blob/main/CHANGELOG.md#1110-2022-11-01
 * @see https://github.com/realm/realm-js/issues/4135
 */
class ClientResetError extends SyncError {
    name = "ClientReset";
    config;
    /** @internal */
    constructor(error) {
        super(error);
        this.config = {
            path: error.userInfo[RECOVERY_FILE_PATH_KEY],
            readOnly: true,
        };
    }
}
/**
 * An error class that indicates that one or more object changes have been reverted by the server.
 * This can happen when the client creates/updates objects that do not match any subscription, or performs writes on
 * an object it didn't have permission to access.
 */
class CompensatingWriteError extends SyncError {
    /**
     * The array of information about each object that caused the compensating write.
     */
    writes = [];
    /** @internal */
    constructor(error) {
        super(error);
        for (const { objectName, primaryKey, reason } of error.compensatingWritesInfo) {
            assert.primaryKey(primaryKey);
            this.writes.push({ objectName, reason, primaryKey });
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Decorators are not intended to be used at runtime and are removed from the source
 * by @realm/babel-plugin. Therefore, if a decorator is called, this means it is being
 * used outside of @realm/babel-plugin (or the plugin is incorrectly configured), so
 * we should throw
 */
class DecoratorError extends Error {
    constructor(name) {
        super(`The @${name} decorator cannot be used without the \`@realm/babel-plugin\` Babel plugin. Please check that you have installed and configured the Babel plugin.`);
    }
}
/**
 * Specify that the decorated field should be indexed by Realm.
 * See: [documentation](https://www.mongodb.com/docs/realm/sdk/react-native/examples/define-a-realm-object-model/#index-a-property)
 */
const index = () => {
    throw new DecoratorError("index");
};
/**
 * Specify that the decorated field should be remapped to a different property name in the Realm database.
 * See: [documentation](https://www.mongodb.com/docs/realm/sdk/react-native/examples/define-a-realm-object-model/#remap-a-property)
 * @param propertyName The name of the property in the Realm database
 */
/* eslint-disable-next-line @typescript-eslint/no-unused-vars -- We don't read this at runtime */
const mapTo = (propertyName) => {
    throw new DecoratorError("mapTo");
};

////////////////////////////////////////////////////////////////////////////
/**
 * Expects the condition to be truthy
 * @throws an {@link Error} If the condition is not truthy. Throws either the {@link err} given as param if it's an {@link Error},
 * an {@link AssertionError} wrapping {@link err} if it's a string or undefined, or uses the result of invoking {@link err} if it's a function.
 * @param condition The condition that must be truthy to avoid throwing.
 * @param err Optional message or error to throw.
 * Or a function producing this, which is useful to avoid computing the error message in case it's not needed.
 */
function assert(condition, err) {
    if (!condition) {
        // Call any function to generate the error lazily
        err = typeof err === "function" ? err() : err;
        if (err instanceof Error) {
            throw err;
        }
        else if (typeof err === "string" || typeof err === "undefined") {
            throw new AssertionError(err);
        }
        else {
            throw new Error("Expected err to be an Err, string, undefined or a function returning either.");
        }
    }
}
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.instanceOf = (value, constructor, target) => {
    assert(value instanceof constructor, () => new TypeAssertionError(`an instance of ${constructor.name}`, value, target));
};
assert.string = (value, target) => {
    assert(typeof value === "string", () => new TypeAssertionError("a string", value, target));
};
assert.number = (value, target) => {
    assert(typeof value === "number", () => new TypeAssertionError("a number", value, target));
};
assert.numericString = (value, target) => {
    assert.string(value);
    assert(/^-?\d+$/.test(value), () => new TypeAssertionError("a numeric string", value, target));
};
assert.boolean = (value, target) => {
    assert(typeof value === "boolean", () => new TypeAssertionError("a boolean", value, target));
};
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.function = (value, target) => {
    assert(typeof value === "function", () => new TypeAssertionError("a function", value, target));
};
assert.symbol = (value, target) => {
    assert(typeof value === "symbol", () => new TypeAssertionError("a symbol", value, target));
};
assert.object = (value, target, { allowArrays } = { allowArrays: true }) => {
    assert(typeof value === "object" && value !== null && (allowArrays || !Array.isArray(value)), () => new TypeAssertionError("an object", value, target));
};
assert.undefined = (value, target) => {
    assert(typeof value === "undefined", () => new TypeAssertionError("undefined", value, target));
};
assert.null = (value, target) => {
    assert(value === null, () => new TypeAssertionError("null", value, target));
};
assert.array = (value, target) => {
    assert(Array.isArray(value), () => new TypeAssertionError("an array", value, target));
};
/* eslint-disable-next-line @typescript-eslint/ban-types */
assert.extends = (value, constructor, target) => {
    assert.function(value, target);
    assert(value.prototype instanceof constructor, () => new TypeAssertionError(`a class extending ${constructor.name}`, value, target));
};
assert.iterable = (value, target) => {
    assert.object(value, target);
    assert(Symbol.iterator in value, () => new TypeAssertionError("iterable", value, target));
};
// * Use arg type `value: never` rather than `value: unknown` to get a compile time
//   error when e.g. not including if-checks for all enum values.
// * Use return type `never` rather than `asserts value is never` to remove the
//   need for callers to explicitly throw (i.e. `throw assert.never()`) as a way
//   for TS to detect unreachable code.
assert.never = (value, target) => {
    throw new TypeAssertionError("never", value, target);
};
// SDK specific
assert.primaryKey = (value, target) => {
    assert(value === null ||
        typeof value === "number" ||
        typeof value === "string" ||
        value instanceof exports.BSON.UUID ||
        value instanceof exports.BSON.ObjectId, () => new TypeAssertionError("a primary key", value, target));
};
assert.open = (realm) => {
    assert(!realm.isClosed, "Cannot access realm that has been closed.");
};
assert.inTransaction = (realm, message = "Cannot modify managed objects outside of a write transaction.") => {
    assert.open(realm);
    assert(realm.isInTransaction, message);
};
assert.outTransaction = (realm, message = "Expected realm to be outside of a write transaction") => {
    assert.open(realm);
    assert(!realm.isInTransaction, message);
};
assert.isValid = (obj, message = "Accessing object which has been invalidated or deleted") => {
    assert(obj.isValid, message);
};
assert.isSameRealm = (realm1, realm2, message = "Expected the Realms to be the same") => {
    assert(realm1.$addr == realm2.$addr, message);
};

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function unwind(ranges) {
    if (Array.isArray(ranges)) {
        return ranges.flatMap(([start, end]) => new Array(end - start).fill(0).map((_, index) => start + index));
    }
    else {
        return unwind([...ranges]);
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/** @internal */
class Listeners {
    options;
    constructor(options) {
        this.options = options;
    }
    /**
     * Mapping of registered listener callbacks onto the their token in the bindings ObjectNotifier.
     */
    listeners = new Map();
    add(callback, ...args) {
        if (this.listeners.has(callback)) {
            // No need to add a listener twice
            if (this.options.throwOnReAdd) {
                throw new Error("Remove callback before adding it again");
            }
            return;
        }
        const token = this.options.add(callback, ...args);
        // Store the notification token by the callback to enable later removal.
        this.listeners.set(callback, token);
    }
    remove(callback) {
        const token = this.listeners.get(callback);
        if (typeof token !== "undefined") {
            this.options.remove(token);
            this.listeners.delete(callback);
        }
    }
    removeAll() {
        for (const [, token] of this.listeners) {
            this.options.remove(token);
        }
        this.listeners.clear();
    }
}

////////////////////////////////////////////////////////////////////////////
/** @internal */
class JSONCacheMap extends Map {
    add(object, value) {
        const tableKey = object[INTERNAL$1].table.key;
        let cachedMap = this.get(tableKey);
        if (!cachedMap) {
            cachedMap = new Map();
            this.set(tableKey, cachedMap);
        }
        cachedMap.set(object._objectKey(), value);
    }
    find(object) {
        return this.get(object[INTERNAL$1].table.key)?.get(object._objectKey());
    }
}

////////////////////////////////////////////////////////////////////////////
class PromiseHandle {
    resolve;
    reject;
    promise;
    constructor() {
        this.promise = new Promise((arg0, arg1) => {
            this.resolve = (arg) => {
                arg0(arg);
            };
            this.reject = arg1;
        });
        assert(this.resolve, "Expected promise executor to be called synchronously");
        assert(this.reject, "Expected promise executor to be called synchronously");
    }
}

////////////////////////////////////////////////////////////////////////////
class TimeoutPromise {
    timer;
    handle = new PromiseHandle();
    constructor(inner, { ms, message = `Waited ${ms}ms`, rejectOnTimeout = true } = {}) {
        if (typeof ms === "number") {
            this.timer = setTimeout(() => {
                if (rejectOnTimeout) {
                    this.handle.reject(new TimeoutError(message));
                }
                else {
                    this.handle.resolve();
                }
            }, ms);
        }
        inner.then(this.handle.resolve, this.handle.reject).finally(() => {
            this.cancel();
        });
    }
    cancel() {
        if (this.timer !== undefined) {
            clearTimeout(this.timer);
            delete this.timer;
        }
    }
    then = this.handle.promise.then.bind(this.handle.promise);
    catch = this.handle.promise.catch.bind(this.handle.promise);
    finally = this.handle.promise.finally.bind(this.handle.promise);
    get [Symbol.toStringTag]() {
        return TimeoutPromise.name;
    }
}

////////////////////////////////////////////////////////////////////////////
function getObj(results, index) {
    return results.getObj(index);
}
function getAny(results, index) {
    return results.getAny(index);
}
const defaultGet = ({ typeHelpers: { fromBinding }, columnKey }) => (obj) => {
    try {
        return fromBinding(obj.getAny(columnKey));
    }
    catch (err) {
        assert.isValid(obj);
        throw err;
    }
};
const defaultSet = ({ realm, typeHelpers: { toBinding }, columnKey }) => (obj, value) => {
    assert.inTransaction(realm);
    try {
        obj.setAny(columnKey, toBinding(value));
    }
    catch (err) {
        assert.isValid(obj);
        throw err;
    }
};
function embeddedSet({ typeHelpers: { toBinding }, columnKey }) {
    return (obj, value) => {
        // Asking for the toBinding will create the object and link it to the parent in one operation
        // no need to actually set the value on the `obj`
        toBinding(value, { createObj: () => [obj.createAndSetLinkedObject(columnKey), true] });
    };
}
const ACCESSOR_FACTORIES = {
    [7 /* binding.PropertyType.Object */](options) {
        const { columnKey, typeHelpers: { fromBinding }, embedded, } = options;
        assert(options.optional, "Objects are always nullable");
        return {
            get(obj) {
                return fromBinding(obj.getLinkedObject(columnKey));
            },
            set: embedded ? embeddedSet(options) : defaultSet(options),
        };
    },
    [8 /* binding.PropertyType.LinkingObjects */]() {
        return {
            get() {
                throw new Error("Getting linking objects happens through Array");
            },
            set() {
                throw new Error("Setting linking objects happens through Array");
            },
        };
    },
    [128 /* binding.PropertyType.Array */]({ realm, type, name, columnKey, objectType, embedded, linkOriginPropertyName, getClassHelpers, optional, typeHelpers: { fromBinding }, }) {
        const realmInternal = realm.internal;
        const itemType = type & ~960 /* binding.PropertyType.Flags */;
        const itemHelpers = getTypeHelpers(itemType, {
            realm,
            name: `element of ${name}`,
            optional,
            getClassHelpers,
            objectType,
            objectSchemaName: undefined,
        });
        // Properties of items are only available on lists of objects
        const isObjectItem = itemType === 7 /* binding.PropertyType.Object */ || itemType === 8 /* binding.PropertyType.LinkingObjects */;
        const collectionHelpers = {
            ...itemHelpers,
            get: isObjectItem ? getObj : getAny,
        };
        if (itemType === 8 /* binding.PropertyType.LinkingObjects */) {
            // Locate the table of the targeted object
            assert.string(objectType, "object type");
            assert(objectType !== "", "Expected a non-empty string");
            const targetClassHelpers = getClassHelpers(objectType);
            const { objectSchema: { tableKey, persistedProperties }, } = targetClassHelpers;
            // TODO: Check if we want to match with the `p.name` or `p.publicName` here
            const targetProperty = persistedProperties.find((p) => p.name === linkOriginPropertyName);
            assert(targetProperty, `Expected a '${linkOriginPropertyName}' property on ${objectType}`);
            const tableRef = Helpers.getTable(realmInternal, tableKey);
            return {
                get(obj) {
                    const tableView = obj.getBacklinkView(tableRef, targetProperty.columnKey);
                    const results = Results$1.fromTableView(realmInternal, tableView);
                    return new Results(realm, results, collectionHelpers);
                },
                set() {
                    throw new Error("Not supported");
                },
            };
        }
        else {
            const { toBinding: itemToBinding } = itemHelpers;
            return {
                collectionHelpers,
                get(obj) {
                    const internal = List$1.make(realm.internal, obj, columnKey);
                    assert.instanceOf(internal, List$1);
                    return fromBinding(internal);
                },
                set(obj, values) {
                    assert.inTransaction(realm);
                    // Implements https://github.com/realm/realm-core/blob/v12.0.0/src/realm/object-store/list.hpp#L258-L286
                    assert.iterable(values);
                    const bindingValues = [];
                    const internal = List$1.make(realm.internal, obj, columnKey);
                    // In case of embedded objects, they're added as they're transformed
                    // So we need to ensure an empty list before
                    if (embedded) {
                        internal.removeAll();
                    }
                    // Transform all values to mixed before inserting into the list
                    {
                        let index = 0;
                        for (const value of values) {
                            try {
                                if (embedded) {
                                    itemToBinding(value, { createObj: () => [internal.insertEmbedded(index), true] });
                                }
                                else {
                                    bindingValues.push(itemToBinding(value));
                                }
                            }
                            catch (err) {
                                if (err instanceof TypeAssertionError) {
                                    err.rename(`${name}[${index}]`);
                                }
                                throw err;
                            }
                            index++;
                        }
                    }
                    // Move values into the internal list - embedded objects are added as they're transformed
                    if (!embedded) {
                        internal.removeAll();
                        let index = 0;
                        for (const value of bindingValues) {
                            internal.insertAny(index++, value);
                        }
                    }
                },
            };
        }
    },
    [512 /* binding.PropertyType.Dictionary */]({ columnKey, realm, name, type, optional, objectType, getClassHelpers, embedded }) {
        const itemType = type & ~960 /* binding.PropertyType.Flags */;
        const itemHelpers = getTypeHelpers(itemType, {
            realm,
            name: `value in ${name}`,
            getClassHelpers,
            objectType,
            optional,
            objectSchemaName: undefined,
        });
        return {
            get(obj) {
                const internal = Dictionary$1.make(realm.internal, obj, columnKey);
                return new Dictionary(realm, internal, itemHelpers);
            },
            set(obj, value) {
                const internal = Dictionary$1.make(realm.internal, obj, columnKey);
                // Clear the dictionary before adding new values
                internal.removeAll();
                assert.object(value, `values of ${name}`);
                for (const [k, v] of Object.entries(value)) {
                    try {
                        if (embedded) {
                            itemHelpers.toBinding(v, { createObj: () => [internal.insertEmbedded(k), true] });
                        }
                        else {
                            internal.insertAny(k, itemHelpers.toBinding(v));
                        }
                    }
                    catch (err) {
                        if (err instanceof TypeAssertionError) {
                            err.rename(`${name}["${k}"]`);
                        }
                        throw err;
                    }
                }
            },
        };
    },
    [256 /* binding.PropertyType.Set */]({ columnKey, realm, name, type, optional, objectType, getClassHelpers }) {
        const itemType = type & ~960 /* binding.PropertyType.Flags */;
        const itemHelpers = getTypeHelpers(itemType, {
            realm,
            name: `value in ${name}`,
            getClassHelpers,
            objectType,
            optional,
            objectSchemaName: undefined,
        });
        assert.string(objectType);
        const collectionHelpers = {
            get: itemType === 7 /* binding.PropertyType.Object */ ? getObj : getAny,
            fromBinding: itemHelpers.fromBinding,
            toBinding: itemHelpers.toBinding,
        };
        return {
            get(obj) {
                const internal = Set$1.make(realm.internal, obj, columnKey);
                return new RealmSet(realm, internal, collectionHelpers);
            },
            set(obj, value) {
                const internal = Set$1.make(realm.internal, obj, columnKey);
                // Clear the set before adding new values
                internal.removeAll();
                assert.array(value, "values");
                for (const v of value) {
                    internal.insertAny(itemHelpers.toBinding(v));
                }
            },
        };
    },
};
function getPropertyHelpers(type, options) {
    const { typeHelpers, columnKey, embedded, objectType } = options;
    const accessorFactory = ACCESSOR_FACTORIES[type];
    if (accessorFactory) {
        const accessors = accessorFactory(options);
        return { ...accessors, ...typeHelpers, type: options.type, columnKey, embedded, objectType };
    }
    else {
        return {
            get: defaultGet(options),
            set: defaultSet(options),
            ...typeHelpers,
            type: options.type,
            columnKey,
            embedded,
            objectType,
        };
    }
}
function createPropertyHelpers(property, options) {
    const collectionType = property.type & 896 /* binding.PropertyType.Collection */;
    const typeOptions = {
        realm: options.realm,
        name: property.name,
        getClassHelpers: options.getClassHelpers,
        objectType: property.objectType,
        objectSchemaName: property.objectSchemaName,
        optional: !!(property.type & 64 /* binding.PropertyType.Nullable */),
    };
    if (collectionType) {
        return getPropertyHelpers(collectionType, {
            ...property,
            ...options,
            ...typeOptions,
            typeHelpers: getTypeHelpers(collectionType, typeOptions),
        });
    }
    else {
        const baseType = property.type & ~960 /* binding.PropertyType.Flags */;
        return getPropertyHelpers(baseType, {
            ...property,
            ...options,
            ...typeOptions,
            typeHelpers: getTypeHelpers(baseType, typeOptions),
        });
    }
}

////////////////////////////////////////////////////////////////////////////
class UninitializedPropertyMapError extends Error {
    constructor() {
        super("Property Map was accessed before it got initialized");
    }
}
/** @internal */
class PropertyMap {
    objectSchemaName = null;
    initialized = false;
    mapping = {};
    /**
     * Note: Cannot key by the binding.ColKey directly, as this is `Long` on JSC (which does not pass equality checks like `bigint` does)
     */
    nameByColumnKeyString = new Map();
    _names = [];
    initialize(objectSchema, defaults, options) {
        const { name: objectSchemaName, persistedProperties, computedProperties } = objectSchema;
        this.objectSchemaName = objectSchemaName;
        const properties = [...persistedProperties, ...computedProperties];
        this.mapping = Object.fromEntries(properties.map((property) => {
            const propertyName = property.publicName || property.name;
            const embedded = property.objectType
                ? options.getClassHelpers(property.objectType).objectSchema.tableType === 1 /* binding.TableType.Embedded */
                : false;
            const helpers = createPropertyHelpers({ ...property, embedded, objectSchemaName }, options);
            // Allow users to override the default value of properties
            const defaultValue = defaults[propertyName];
            helpers.default = typeof defaultValue !== "undefined" ? defaultValue : helpers.default;
            return [propertyName, helpers];
        }));
        this.nameByColumnKeyString = new Map(properties.map((p) => [p.columnKey.toString(), p.publicName || p.name]));
        this._names = properties.map((p) => p.publicName || p.name);
        this.initialized = true;
    }
    get = (property) => {
        if (this.initialized) {
            const helpers = this.mapping[property];
            if (!helpers) {
                throw new Error(`Property '${property}' does not exist on '${this.objectSchemaName}' objects`);
            }
            return helpers;
        }
        else {
            throw new UninitializedPropertyMapError();
        }
    };
    getName = (columnKey) => {
        if (this.initialized) {
            return this.nameByColumnKeyString.get(columnKey.toString());
        }
        else {
            throw new UninitializedPropertyMapError();
        }
    };
    get names() {
        if (this.initialized) {
            return this._names;
        }
        else {
            throw new UninitializedPropertyMapError();
        }
    }
}

////////////////////////////////////////////////////////////////////////////
function setClassHelpers(constructor, value) {
    // Store the properties map on the object class
    Object.defineProperty(constructor, INTERNAL_HELPERS, {
        enumerable: false,
        writable: false,
        configurable: false,
        value,
    });
}
/**
 * Get internal helpers.
 * NOTE: This is a free function instead of a member of RealmObject to limit conflicts with user defined properties.
 * @param arg The object or constructor to get a helpers for.
 * @returns Helpers injected onto the class by the `ClassMap`.
 */
function getClassHelpers(arg) {
    const helpers = arg[INTERNAL_HELPERS];
    if (helpers) {
        return helpers;
    }
    else {
        throw new Error(`Expected INTERNAL_HELPERS to be set on the '${arg.name}' class`);
    }
}

////////////////////////////////////////////////////////////////////////////
/** @internal */
class ClassMap {
    mapping;
    nameByTableKey;
    static createNamedConstructor(name) {
        const result = function () {
            /* no-op */
        };
        // Need to use `defineProperty` since it isn't writable
        Object.defineProperty(result, "name", { value: name });
        return result;
    }
    static createClass(schema, constructor) {
        const result = ClassMap.createNamedConstructor(schema.name);
        // Make the new constructor extend RealmObject
        // TODO: Use the end-users constructor, instead of `RealmObject` if provided
        if (constructor) {
            Object.setPrototypeOf(result, constructor);
            Object.setPrototypeOf(result.prototype, constructor.prototype);
        }
        else {
            Object.setPrototypeOf(result, RealmObject);
            Object.setPrototypeOf(result.prototype, RealmObject.prototype);
        }
        return result;
    }
    static defineProperties(constructor, schema, propertyMap, realm) {
        // Create bound functions for getting and setting properties
        const properties = [...schema.persistedProperties, ...schema.computedProperties];
        const propertyNames = properties.map((p) => p.publicName || p.name);
        // Set up accessors for the properties declared in the schema
        for (const property of properties) {
            const propertyName = property.publicName || property.name;
            const { get, set } = propertyMap.get(propertyName);
            Object.defineProperty(constructor.prototype, propertyName, {
                enumerable: true,
                get() {
                    return get(this[INTERNAL$1]);
                },
                set(value) {
                    set(this[INTERNAL$1], value);
                },
            });
        }
        Object.defineProperty(constructor.prototype, REALM$1, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: realm,
        });
        Object.defineProperty(constructor.prototype, KEY_ARRAY, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: propertyNames,
        });
        Object.defineProperty(constructor.prototype, KEY_SET, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: new Set(propertyNames),
        });
    }
    constructor(realm, realmSchema, canonicalRealmSchema) {
        this.mapping = Object.fromEntries(realmSchema.map((objectSchema, index) => {
            const canonicalObjectSchema = canonicalRealmSchema[index];
            assert.object(canonicalObjectSchema);
            // Create the wrapping class first
            const constructor = ClassMap.createClass(objectSchema, canonicalObjectSchema.ctor);
            // Create property getters and setters
            const properties = new PropertyMap();
            // Setting the helpers on the class
            setClassHelpers(constructor, {
                constructor,
                objectSchema,
                canonicalObjectSchema,
                properties,
                wrapObject(obj) {
                    if (obj.isValid) {
                        return RealmObject.createWrapper(obj, constructor);
                    }
                    else {
                        return null;
                    }
                },
            });
            return [objectSchema.name, constructor];
        }));
        this.nameByTableKey = Object.fromEntries(realmSchema.map(({ name, tableKey }) => [tableKey, name]));
        for (const [index, objectSchema] of realmSchema.entries()) {
            const canonicalObjectSchema = canonicalRealmSchema[index];
            const defaults = Object.fromEntries(Object.entries(canonicalObjectSchema.properties).map(([name, property]) => {
                return [name, property.default];
            }));
            const constructor = this.mapping[objectSchema.name];
            // Get the uninitialized property map
            const { properties } = getClassHelpers(constructor);
            // Initialize the property map, now that all classes have helpers set
            properties.initialize(objectSchema, defaults, {
                realm,
                getClassHelpers: (name) => this.getHelpers(name),
            });
            // Transfer property getters and setters onto the prototype of the class
            ClassMap.defineProperties(constructor, objectSchema, properties, realm);
        }
    }
    get(arg) {
        if (typeof arg === "string") {
            const constructor = this.mapping[arg];
            if (!constructor) {
                throw new Error(`Object type '${arg}' not found in schema.`);
            }
            return constructor;
        }
        else if (arg instanceof RealmObject) {
            return this.get(arg.constructor.name);
        }
        else if (typeof arg === "function") {
            assert.extends(arg, RealmObject);
            assert.object(arg.schema, "schema static");
            assert.string(arg.schema.name, "name");
            const result = this.get(arg.schema.name);
            assert(result === arg || Object.getPrototypeOf(result) === arg, "Constructor was not registered in the schema for this Realm");
            return result;
        }
        else if (arg in this.nameByTableKey) {
            const name = this.nameByTableKey[arg];
            return this.get(name);
        }
        else {
            throw new Error("Expected an object schema name, object instance or class");
        }
    }
    getHelpers(arg) {
        const constructor = this.get(arg);
        return getClassHelpers(constructor);
    }
}

////////////////////////////////////////////////////////////////////////////
const TYPED_ARRAY_CONSTRUCTORS = new Set([
    DataView,
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array,
    // These will not be present on old versions of JSC without BigInt support.
    safeGlobalThis.BigInt64Array,
    safeGlobalThis.BigUint64Array,
].filter((ctor) => ctor !== undefined));
function toArrayBuffer(value, stringToBase64 = true) {
    if (typeof value === "string" && stringToBase64) {
        return Helpers.base64Decode(value);
    }
    for (const TypedArray of TYPED_ARRAY_CONSTRUCTORS) {
        if (value instanceof TypedArray) {
            return value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength);
        }
    }
    assert.instanceOf(value, ArrayBuffer);
    return value;
}
// TODO: Consider testing for expected object instance types and throw something similar to the legacy SDK:
// "Only Realm instances are supported." (which should probably have been "RealmObject")
// instead of relying on the binding to throw.
function mixedToBinding(realm, value) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean" || value === null) {
        // Fast track pass through for the most commonly used types
        return value;
    }
    else if (value === undefined) {
        return null;
    }
    else if (value instanceof Date) {
        return Timestamp.fromDate(value);
    }
    else if (value instanceof RealmObject) {
        const otherRealm = value[REALM$1].internal;
        assert.isSameRealm(realm, otherRealm, "Realm object is from another Realm");
        return value[INTERNAL$1];
    }
    else if (value instanceof Collection) {
        throw new Error(`Using a ${value.constructor.name} as Mixed value, is not yet supported`);
    }
    else if (Array.isArray(value)) {
        throw new TypeError("A mixed property cannot contain an array of values.");
    }
    else {
        if (typeof value === "object" && value !== null) {
            if (isGeoCircle(value)) {
                return circleToBindingGeospatial(value);
            }
            else if (isGeoBox(value)) {
                return boxToBindingGeospatial(value);
            }
            else if (isGeoPolygon(value)) {
                return polygonToBindingGeospatial(value);
            }
        }
        // Convert typed arrays to an `ArrayBuffer`
        for (const TypedArray of TYPED_ARRAY_CONSTRUCTORS) {
            if (value instanceof TypedArray) {
                return value.buffer.slice(value.byteOffset, value.byteOffset + value.byteLength);
            }
        }
        // Rely on the binding for any other value
        return value;
    }
}
function isGeoCircle(value) {
    return "distance" in value && "center" in value && typeof value["distance"] === "number";
}
function isGeoBox(value) {
    return "bottomLeft" in value && "topRight" in value;
}
function isGeoPolygon(value) {
    return (("type" in value && value["type"] === "Polygon" && "coordinates" in value && Array.isArray(value["coordinates"])) ||
        ("outerRing" in value && Array.isArray(value["outerRing"])));
}
function defaultToBinding(value) {
    return value;
}
function defaultFromBinding(value) {
    return value;
}
/**
 * Adds a branch to a function, which checks for the argument to be null, in which case it returns early.
 */
/* eslint-disable-next-line @typescript-eslint/no-explicit-any -- Using `unknown` here breaks type inference in `binding.PropertyType.Object` `toBinding` from for some reason */
function nullPassthrough(fn, enabled) {
    if (enabled) {
        return ((value, ...rest) => typeof value === "undefined" || value === null ? null : fn.call(this, value, ...rest));
    }
    else {
        return fn;
    }
}
const TYPES_MAPPING = {
    [0 /* binding.PropertyType.Int */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                if (typeof value === "number") {
                    return Int64.numToInt(value);
                }
                else if (Int64.isInt(value)) {
                    return value;
                }
                else {
                    throw new TypeAssertionError("a number or bigint", value);
                }
            }, optional),
            // TODO: Support returning bigints to end-users
            fromBinding: nullPassthrough((value) => Number(value), optional),
        };
    },
    [1 /* binding.PropertyType.Bool */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.boolean(value);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [2 /* binding.PropertyType.String */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.string(value);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [3 /* binding.PropertyType.Data */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                return toArrayBuffer(value);
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [4 /* binding.PropertyType.Date */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                if (typeof value === "string") {
                    // TODO: Consider deprecating this undocumented type coercion
                    return Timestamp.fromDate(new Date(value));
                }
                else {
                    assert.instanceOf(value, Date);
                    return Timestamp.fromDate(value);
                }
            }, optional),
            fromBinding: nullPassthrough((value) => {
                assert.instanceOf(value, Timestamp);
                return value.toDate();
            }, optional),
        };
    },
    [5 /* binding.PropertyType.Float */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.number(value);
                return new Float(value);
            }, optional),
            fromBinding: nullPassthrough((value) => {
                assert.instanceOf(value, Float);
                return value.value;
            }, optional),
        };
    },
    [6 /* binding.PropertyType.Double */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.number(value);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [7 /* binding.PropertyType.Object */]({ realm, name, objectType, optional, getClassHelpers }) {
        assert(objectType);
        const helpers = getClassHelpers(objectType);
        const { wrapObject } = helpers;
        return {
            toBinding: nullPassthrough((value, options) => {
                if (value instanceof RealmObject &&
                    value.constructor.name === objectType &&
                    value[REALM$1].internal.$addr === realm.internal.$addr) {
                    return value[INTERNAL$1];
                }
                else {
                    // TODO: Consider exposing a way for calling code to disable object creation
                    assert.object(value, name);
                    // Use the update mode if set; otherwise, the object is assumed to be an
                    // unmanaged object that the user wants to create.
                    // TODO: Ideally use `options?.updateMode` instead of `realm.currentUpdateMode`.
                    const createdObject = RealmObject.create(realm, value, realm.currentUpdateMode ?? exports.UpdateMode.Never, {
                        helpers,
                        createObj: options?.createObj,
                    });
                    return createdObject[INTERNAL$1];
                }
            }, optional),
            fromBinding: nullPassthrough((value) => {
                if (value instanceof ObjLink) {
                    const table = Helpers.getTable(realm.internal, value.tableKey);
                    const linkedObj = table.getObject(value.objKey);
                    return wrapObject(linkedObj);
                }
                else {
                    assert.instanceOf(value, Obj);
                    return wrapObject(value);
                }
            }, optional),
        };
    },
    [8 /* binding.PropertyType.LinkingObjects */]({ objectType, getClassHelpers }) {
        assert(objectType);
        const { wrapObject } = getClassHelpers(objectType);
        return {
            toBinding: defaultToBinding,
            fromBinding(value) {
                assert.instanceOf(value, Obj);
                return wrapObject(value);
            },
        };
    },
    [9 /* binding.PropertyType.Mixed */]({ realm, getClassHelpers }) {
        return {
            toBinding: mixedToBinding.bind(null, realm.internal),
            fromBinding(value) {
                if (Int64.isInt(value)) {
                    return Int64.intToNum(value);
                }
                else if (value instanceof Timestamp) {
                    return value.toDate();
                }
                else if (value instanceof Float) {
                    return value.value;
                }
                else if (value instanceof ObjLink) {
                    const table = Helpers.getTable(realm.internal, value.tableKey);
                    const linkedObj = table.getObject(value.objKey);
                    const { wrapObject } = getClassHelpers(value.tableKey);
                    return wrapObject(linkedObj);
                }
                else {
                    return value;
                }
            },
        };
    },
    [10 /* binding.PropertyType.ObjectId */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.instanceOf(value, exports.BSON.ObjectId);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [11 /* binding.PropertyType.Decimal */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.instanceOf(value, exports.BSON.Decimal128);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [12 /* binding.PropertyType.Uuid */]({ optional }) {
        return {
            toBinding: nullPassthrough((value) => {
                assert.instanceOf(value, exports.BSON.UUID);
                return value;
            }, optional),
            fromBinding: defaultFromBinding,
        };
    },
    [128 /* binding.PropertyType.Array */]({ realm, getClassHelpers, name, objectSchemaName }) {
        assert.string(objectSchemaName, "objectSchemaName");
        const classHelpers = getClassHelpers(objectSchemaName);
        return {
            fromBinding(value) {
                assert.instanceOf(value, List$1);
                const propertyHelpers = classHelpers.properties.get(name);
                const collectionHelpers = propertyHelpers.collectionHelpers;
                assert.object(collectionHelpers);
                return new List(realm, value, collectionHelpers);
            },
            toBinding() {
                throw new Error("Not supported");
            },
        };
    },
    [256 /* binding.PropertyType.Set */]() {
        return {
            fromBinding() {
                throw new Error("Not yet supported");
            },
            toBinding() {
                throw new Error("Not yet supported");
            },
        };
    },
    [512 /* binding.PropertyType.Dictionary */]() {
        return {
            fromBinding() {
                throw new Error("Not supported");
            },
            toBinding() {
                throw new Error("Not supported");
            },
        };
    },
    [64 /* binding.PropertyType.Nullable */]() {
        throw new Error("Not directly mappable");
    },
    [896 /* binding.PropertyType.Collection */]() {
        throw new Error("Not directly mappable");
    },
    [960 /* binding.PropertyType.Flags */]() {
        throw new Error("Not directly mappable");
    },
};
function getTypeHelpers(type, options) {
    const helpers = TYPES_MAPPING[type];
    assert(helpers, `Unexpected type ${type}`);
    return helpers(options);
}

////////////////////////////////////////////////////////////////////////////
/**
 * The update mode to use when creating an object that already exists.
 */
exports.UpdateMode = void 0;
(function (UpdateMode) {
    /**
     * Objects are only created. If an existing object exists, an exception is thrown.
     */
    UpdateMode["Never"] = "never";
    /**
     * If an existing object exists, only properties where the value has actually
     * changed will be updated. This improves notifications and server side
     * performance but also have implications for how changes across devices are
     * merged. For most use cases, the behavior will match the intuitive behavior
     * of how changes should be merged, but if updating an entire object is
     * considered an atomic operation, this mode should not be used.
     */
    UpdateMode["Modified"] = "modified";
    /**
     * If an existing object is found, all properties provided will be updated,
     * any other properties will remain unchanged.
     */
    UpdateMode["All"] = "all";
})(exports.UpdateMode || (exports.UpdateMode = {}));
const KEY_ARRAY = Symbol("Object#keys");
const KEY_SET = Symbol("Object#keySet");
const REALM$1 = Symbol("Object#realm");
const INTERNAL$1 = Symbol("Object#internal");
const INTERNAL_LISTENERS = Symbol("Object#listeners");
const INTERNAL_HELPERS = Symbol("Object.helpers");
const DEFAULT_PROPERTY_DESCRIPTOR$3 = { configurable: true, enumerable: true, writable: true };
/* eslint-disable-next-line @typescript-eslint/no-explicit-any */
const PROXY_HANDLER$3 = {
    ownKeys(target) {
        return Reflect.ownKeys(target).concat(target[KEY_ARRAY]);
    },
    getOwnPropertyDescriptor(target, prop) {
        if (typeof prop === "string" && target[KEY_SET].has(prop)) {
            return DEFAULT_PROPERTY_DESCRIPTOR$3;
        }
        const result = Reflect.getOwnPropertyDescriptor(target, prop);
        if (result && typeof prop === "symbol") {
            if (prop === INTERNAL$1) {
                result.enumerable = false;
                result.writable = false;
            }
            else if (prop === INTERNAL_LISTENERS) {
                result.enumerable = false;
            }
        }
        return result;
    },
};
/**
 * Base class for a Realm Object.
 * @example
 * To define a class `Person` with required `name` and `age`
 * properties, define a `static schema`:
 * ```
 * class Person extends Realm.Object<Person> {
 *   _id!: Realm.BSON.ObjectId;
 *   name!: string;
 *   age!: number;
 *   static schema: Realm.ObjectSchema = {
 *     name: "Person",
 *     primaryKey: "_id",
 *     properties: {
 *       _id: "objectId",
 *       name: "string",
 *       age: "int",
 *     },
 *   };
 * }
 * ```
 * @example
 * If using the [@realm/babel-plugin](https://www.npmjs.com/package/@realm/babel-plugin):
 * To define a class `Person` with required `name` and `age` properties, they would
 * need to be specified in the type argument when it is being constructed to allow
 * Typescript-only model definitions:
 * ```
 * class Person extends Realm.Object<Person, "name" | "age"> {
 *   _id = new Realm.Types.ObjectId();
 *   name: Realm.Types.String;
 *   age: Realm.Types.Int;
 *   static primaryKey = "_id";
 * }
 * ```
 * @see {@link ObjectSchema}
 * @typeParam `T` - The type of this class (e.g. if your class is `Person`,
 * `T` should also be `Person` - this duplication is required due to how
 * TypeScript works)
 * @typeParam `RequiredProperties` - The names of any properties of this
 * class which are required when an instance is constructed with `new`. Any
 * properties not specified will be optional, and will default to a sensible
 * null value if no default is specified elsewhere.
 */
class RealmObject {
    /**
     * This property is stored on the per class prototype when transforming the schema.
     * @internal
     */
    static [INTERNAL_HELPERS];
    static allowValuesArrays = false;
    /**
     * Optionally specify the primary key of the schema when using [@realm/babel-plugin](https://www.npmjs.com/package/@realm/babel-plugin).
     */
    static primaryKey;
    /**
     * Optionally specify that the schema is an embedded schema when using [@realm/babel-plugin](https://www.npmjs.com/package/@realm/babel-plugin).
     */
    static embedded;
    /**
     * Optionally specify that the schema should sync unidirectionally if using flexible sync when using [@realm/babel-plugin](https://www.npmjs.com/package/@realm/babel-plugin).
     */
    static asymmetric;
    /**
     * Create an object in the database and set values on it
     * @internal
     */
    static create(realm, values, mode, context) {
        assert.inTransaction(realm);
        if (Array.isArray(values)) {
            if (flags.ALLOW_VALUES_ARRAYS) {
                const { persistedProperties } = context.helpers.objectSchema;
                return RealmObject.create(realm, Object.fromEntries(values.map((value, index) => {
                    const property = persistedProperties[index];
                    const propertyName = property.publicName || property.name;
                    return [propertyName, value];
                })), mode, context);
            }
            else {
                throw new Error("Array values on object creation is no longer supported");
            }
        }
        const { helpers: { properties, wrapObject, objectSchema: { persistedProperties }, }, createObj, } = context;
        // Create the underlying object
        const [obj, created] = createObj ? createObj() : this.createObj(realm, values, mode, context);
        const result = wrapObject(obj);
        assert(result);
        // Persist any values provided
        // TODO: Consider using the property helpers directly to improve performance
        for (const property of persistedProperties) {
            const propertyName = property.publicName || property.name;
            const { default: defaultValue } = properties.get(propertyName);
            if (property.isPrimary) {
                continue; // Skip setting this, as we already provided it on object creation
            }
            const propertyValue = values[propertyName];
            if (typeof propertyValue !== "undefined") {
                if (mode !== exports.UpdateMode.Modified || result[propertyName] !== propertyValue) {
                    // This will call into the property setter in PropertyHelpers.ts.
                    // (E.g. the setter for [binding.PropertyType.Array] in the case of lists.)
                    result[propertyName] = propertyValue;
                }
            }
            else {
                if (typeof defaultValue !== "undefined") {
                    result[propertyName] = typeof defaultValue === "function" ? defaultValue() : defaultValue;
                }
                else if (!(property.type & 896 /* binding.PropertyType.Collection */) &&
                    !(property.type & 64 /* binding.PropertyType.Nullable */) &&
                    created) {
                    throw new Error(`Missing value for property '${propertyName}'`);
                }
            }
        }
        return result;
    }
    /**
     * Create an object in the database and populate its primary key value, if required
     * @internal
     */
    static createObj(realm, values, mode, context) {
        const { helpers: { objectSchema: { name, tableKey, primaryKey }, properties, }, } = context;
        // Create the underlying object
        const table = Helpers.getTable(realm.internal, tableKey);
        if (primaryKey) {
            const primaryKeyHelpers = properties.get(primaryKey);
            let primaryKeyValue = values[primaryKey];
            // If the value for the primary key was not set, use the default value
            if (primaryKeyValue === undefined) {
                const defaultValue = primaryKeyHelpers.default;
                primaryKeyValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
            }
            const pk = primaryKeyHelpers.toBinding(
            // Fallback to default value if the provided value is undefined or null
            typeof primaryKeyValue !== "undefined" && primaryKeyValue !== null
                ? primaryKeyValue
                : primaryKeyHelpers.default);
            const result = Helpers.getOrCreateObjectWithPrimaryKey(table, pk);
            const [, created] = result;
            if (mode === exports.UpdateMode.Never && !created) {
                throw new Error(`Attempting to create an object of type '${name}' with an existing primary key value '${primaryKeyValue}'.`);
            }
            return result;
        }
        else {
            return [table.createObject(), true];
        }
    }
    /**
     * Create a wrapper for accessing an object from the database
     * @internal
     */
    static createWrapper(internal, constructor) {
        const result = Object.create(constructor.prototype);
        result[INTERNAL$1] = internal;
        // Initializing INTERNAL_LISTENERS here rather than letting it just be implicitly undefined since JS engines
        // prefer adding all fields to objects upfront. Adding optional fields later can sometimes trigger deoptimizations.
        result[INTERNAL_LISTENERS] = null;
        // Wrap in a proxy to trap keys, enabling the spread operator, and hiding our internal fields.
        return new Proxy(result, PROXY_HANDLER$3);
    }
    /**
     * Create a `RealmObject` wrapping an `Obj` from the binding.
     * @param realm - The Realm managing the object.
     * @param values - The values of the object's properties at creation.
     */
    constructor(realm, values) {
        return realm.create(this.constructor, values);
    }
    /**
     * @returns An array of the names of the object's properties.
     * @deprecated Please use {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys | Object.keys()}
     */
    keys() {
        // copying to prevent caller from modifying the static array.
        return [...this[KEY_ARRAY]];
    }
    /**
     * @returns An array of key/value pairs of the object's properties.
     * @deprecated Please use {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries | Object.entries()}
     */
    entries() {
        return Object.entries(this);
    }
    /** @internal */
    toJSON(_, cache = new JSONCacheMap()) {
        // Construct a reference-id of table-name & primaryKey if it exists, or fall back to objectId.
        // Check if current objectId has already processed, to keep object references the same.
        const existing = cache.find(this);
        if (existing) {
            return existing;
        }
        const result = {};
        cache.add(this, result);
        // Move all enumerable keys to result, triggering any specific toJSON implementation in the process.
        for (const key in this) {
            const value = this[key];
            if (typeof value == "function") {
                continue;
            }
            if (value instanceof RealmObject || value instanceof OrderedCollection || value instanceof Dictionary) {
                // recursively trigger `toJSON` for Realm instances with the same cache.
                result[key] = value.toJSON(key, cache);
            }
            else {
                // Other cases, including null and undefined.
                result[key] = value;
            }
        }
        return result;
    }
    /**
     * Checks if this object has not been deleted and is part of a valid Realm.
     * @returns `true` if the object can be safely accessed, `false` if not.
     */
    isValid() {
        return this[INTERNAL$1] && this[INTERNAL$1].isValid;
    }
    /**
     * The schema for the type this object belongs to.
     * @returns The {@link CanonicalObjectSchema} that describes this object.
     */
    objectSchema() {
        return this[REALM$1].getClassHelpers(this).canonicalObjectSchema;
    }
    linkingObjects(objectType, propertyName) {
        const targetClassHelpers = this[REALM$1].getClassHelpers(objectType);
        const { objectSchema: targetObjectSchema, properties, wrapObject } = targetClassHelpers;
        const targetProperty = properties.get(propertyName);
        const originObjectSchema = this.objectSchema();
        assert(originObjectSchema.name === targetProperty.objectType, () => `'${targetObjectSchema.name}#${propertyName}' is not a relationship to '${originObjectSchema.name}'`);
        const collectionHelpers = {
            // See `[binding.PropertyType.LinkingObjects]` in `TypeHelpers.ts`.
            toBinding(value) {
                return value;
            },
            fromBinding(value) {
                assert.instanceOf(value, Obj);
                return wrapObject(value);
            },
            // See `[binding.PropertyType.Array]` in `PropertyHelpers.ts`.
            get(results, index) {
                return results.getObj(index);
            },
        };
        // Create the Result for the backlink view.
        const tableRef = Helpers.getTable(this[REALM$1].internal, targetObjectSchema.tableKey);
        const tableView = this[INTERNAL$1].getBacklinkView(tableRef, targetProperty.columnKey);
        const results = Results$1.fromTableView(this[REALM$1].internal, tableView);
        return new Results(this[REALM$1], results, collectionHelpers);
    }
    /**
     * Returns the total count of incoming links to this object
     * @returns The number of links to this object.
     */
    linkingObjectsCount() {
        return this[INTERNAL$1].getBacklinkCount();
    }
    /**
     * @deprecated
     * TODO: Remove completely once the type tests are abandoned.
     */
    _objectId() {
        throw new Error("This is now removed!");
    }
    /**
     * A string uniquely identifying the object across all objects of the same type.
     */
    _objectKey() {
        return this[INTERNAL$1].key.toString();
    }
    /**
     * Add a listener `callback` which will be called when a **live** object instance changes.
     * @param callback - A function to be called when changes occur.
     * @param callback.obj - The object that changed.
     * @param callback.changes - A dictionary with information about the changes.
     * @param callback.changes.deleted - Is `true` if the object has been deleted.
     * @param callback.changes.changedProperties  - An array of properties that have changed their value.
     * @throws A {@link TypeAssertionError} if `callback` is not a function.
     * @example
     * wine.addListener((obj, changes) => {
     *  // obj === wine
     *  console.log(`object is deleted: ${changes.deleted}`);
     *  console.log(`${changes.changedProperties.length} properties have been changed:`);
     *  changes.changedProperties.forEach(prop => {
     *      console.log(` ${prop}`);
     *   });
     * })
     * @note Adding the listener is an asynchronous operation, so the callback is invoked the first time to notify the caller when the listener has been added.
     * Thus, when the callback is invoked the first time it will contain empty array for `changes.changedProperties`.
     */
    addListener(callback) {
        assert.function(callback);
        if (!this[INTERNAL_LISTENERS]) {
            this[INTERNAL_LISTENERS] = new ObjectListeners(this[REALM$1].internal, this);
        }
        this[INTERNAL_LISTENERS].addListener(callback);
    }
    /**
     * Remove the listener `callback` from this object.
     * @throws A {@link TypeAssertionError} if `callback` is not a function.
     * @param callback A function previously added as listener
     */
    removeListener(callback) {
        assert.function(callback);
        // Note: if the INTERNAL_LISTENERS field hasn't been initialized, then we have no listeners to remove.
        this[INTERNAL_LISTENERS]?.removeListener(callback);
    }
    /**
     * Remove all listeners from this object.
     */
    removeAllListeners() {
        // Note: if the INTERNAL_LISTENERS field hasn't been initialized, then we have no listeners to remove.
        this[INTERNAL_LISTENERS]?.removeAllListeners();
    }
    /**
     * Get underlying type of a property value.
     * @param propertyName - The name of the property to retrieve the type of.
     * @throws An {@link Error} if property does not exist.
     * @returns Underlying type of the property value.
     */
    getPropertyType(propertyName) {
        const { properties } = this[REALM$1].getClassHelpers(this);
        const { type, objectType, columnKey } = properties.get(propertyName);
        const typeName = getTypeName(type, objectType);
        if (typeName === "mixed") {
            // This requires actually getting the object and inferring its type
            const value = this[INTERNAL$1].getAny(columnKey);
            if (value === null) {
                return "null";
            }
            else if (Int64.isInt(value)) {
                return "int";
            }
            else if (value instanceof Float) {
                return "float";
            }
            else if (value instanceof Timestamp) {
                return "date";
            }
            else if (value instanceof Obj) {
                const { objectSchema } = this[REALM$1].getClassHelpers(value.table.key);
                return `<${objectSchema.name}>`;
            }
            else if (value instanceof ObjLink) {
                const { objectSchema } = this[REALM$1].getClassHelpers(value.tableKey);
                return `<${objectSchema.name}>`;
            }
            else if (value instanceof ArrayBuffer) {
                return "data";
            }
            else if (typeof value === "number") {
                return "double";
            }
            else if (typeof value === "string") {
                return "string";
            }
            else if (typeof value === "boolean") {
                return "bool";
            }
            else if (value instanceof exports.BSON.ObjectId) {
                return "objectId";
            }
            else if (value instanceof exports.BSON.Decimal128) {
                return "decimal128";
            }
            else if (value instanceof exports.BSON.UUID) {
                return "uuid";
            }
            else {
                assert.never(value, "value");
            }
        }
        else {
            return typeName;
        }
    }
}
// We like to refer to this as "Realm.Object"
// TODO: Determine if we want to revisit this if we're going away from a namespaced API
Object.defineProperty(RealmObject, "name", { value: "Realm.Object" });

////////////////////////////////////////////////////////////////////////////
/** @internal */
class ObjectListeners {
    realm;
    object;
    /**
     * Storage for the memoized, lazily created object notifier.
     */
    internal;
    constructor(realm, object) {
        this.realm = realm;
        this.object = object;
        this.properties = getClassHelpers(this.object.constructor).properties;
    }
    properties;
    listeners = new Listeners({
        add: (callback) => {
            const token = this.notifier.addCallback((changes) => {
                try {
                    callback(this.object, {
                        deleted: changes.isDeleted,
                        changedProperties: changes.changedColumns.map(this.properties.getName),
                    });
                }
                catch (err) {
                    // Scheduling a throw on the event loop,
                    // since throwing synchronously here would result in an abort in the calling C++
                    setImmediate(() => {
                        throw err;
                    });
                }
            }, undefined);
            // Get an actual NotificationToken for the bigint value
            return NotificationToken.forObject(this.notifier, token);
        },
        remove(token) {
            token.unregister();
        },
    });
    /**
     * A memoized, lazily created object notifier.
     */
    get notifier() {
        let notifier = this.internal;
        if (notifier) {
            return notifier;
        }
        else {
            notifier = Helpers.makeObjectNotifier(this.realm, this.object[INTERNAL$1]);
            this.internal = notifier;
            return notifier;
        }
    }
    addListener(callback) {
        this.listeners.add(callback);
    }
    removeListener(callback) {
        this.listeners.remove(callback);
    }
    removeAllListeners() {
        this.listeners.removeAll();
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Abstract base class containing methods shared by Realm {@link List}, {@link Dictionary} and {@link Results}.
 *
 * A {@link Collection} always reflect the current state of the Realm. The one exception to this is
 * when using `for...in` or `for...of` enumeration, which will always enumerate over the
 * objects which matched the query when the enumeration is begun, even if some of them are
 * deleted or modified to be excluded by the filter during the enumeration.
 * @since 0.11.0
 */
class Collection {
    /** @internal */
    listeners;
    /** @internal */
    constructor(addListener) {
        if (arguments.length === 0) {
            throw new IllegalConstructorError("Collection");
        }
        this.listeners = new Listeners({
            add: addListener,
            remove(token) {
                token.unregister();
            },
        });
        // Make the internal properties non-enumerable
        Object.defineProperty(this, "listeners", {
            enumerable: false,
            configurable: false,
            writable: false,
        });
    }
    /**
     * Add a listener `callback` which will be called when a **live** collection instance changes.
     * @param callback - A function to be called when changes occur.
     * @param callback.collection - The collection instance that changed,
     * @param callback.changes - An object with information about the changes.
     * @param callback.changes.insertions - The indices in the collection where objects were inserted.
     * @param callback.changes.newModifications - The indices in the collection where objects were modified.
     * @param callback.changes.oldModifications - The indices in the collection where objects were modified.
     * @param callback.changes.deletions - The indices in the collection where objects were deleted.
     * @note `deletions and `oldModifications` report the indices in the collection before the change happened,
     * while `insertions` and `newModifications` report the indices into the new version of the collection.
     * @throws A {@link TypeAssertionError} if `callback` is not a function.
     * @example
     * wines.addListener((collection, changes) => {
     *  // collection === wines
     *  console.log(`${changes.insertions.length} insertions`);
     *  console.log(`${changes.oldModifications.length} oldModifications`);
     *  console.log(`${changes.newModifications.length} newModifications`);
     *  console.log(`${changes.deletions.length} deletions`);
     *  console.log(`new size of collection: ${collection.length}`);
     * });
     * @note Adding the listener is an asynchronous operation, so the callback is invoked the first time to notify the caller when the listener has been added.
     * Thus, when the callback is invoked the first time it will contain empty arrays for each property in the `changes` object.
     */
    addListener(callback) {
        assert.function(callback, "callback");
        this.listeners.add(callback);
    }
    /**
     * Remove the listener `callback` from the collection instance.
     * @param callback - Callback function that was previously
     *   added as a listener through the {@link Collection.addListener} method.
     * @throws a {@link TypeAssertionError} If `callback` is not a function.
     */
    removeListener(callback) {
        assert.function(callback, "callback");
        this.listeners.remove(callback);
    }
    /**
     * Remove all `callback` listeners from the collection instance.
     */
    removeAllListeners() {
        this.listeners.removeAll();
    }
}

////////////////////////////////////////////////////////////////////////////
const DEFAULT_COLUMN_KEY = Int64.numToInt(0);
const DEFAULT_PROPERTY_DESCRIPTOR$2 = { configurable: true, enumerable: true, writable: true };
const PROXY_HANDLER$2 = {
    // TODO: Consider executing the `parseInt` first to optimize for index access over accessing a member on the list
    get(target, prop) {
        if (Reflect.has(target, prop)) {
            return Reflect.get(target, prop);
        }
        else if (typeof prop === "string") {
            const index = Number.parseInt(prop, 10);
            // TODO: Consider catching an error from access out of bounds, instead of checking the length, to optimize for the hot path
            if (!Number.isNaN(index) && index >= 0 && index < target.length) {
                return target.get(index);
            }
        }
    },
    set(target, prop, value, receiver) {
        if (typeof prop === "string") {
            const index = Number.parseInt(prop, 10);
            // TODO: Consider catching an error from access out of bounds, instead of checking the length, to optimize for the hot path
            // TODO: Do we expect an upper bound check on the index when setting?
            if (Number.isInteger(index)) {
                if (index < 0) {
                    throw new Error(`Index ${index} cannot be less than zero.`);
                }
                target.set(index, value);
                return true;
            }
        }
        return Reflect.set(target, prop, value, receiver);
    },
    ownKeys(target) {
        return Reflect.ownKeys(target).concat([...target.keys()].map(String));
    },
    getOwnPropertyDescriptor(target, prop) {
        if (Reflect.has(target, prop)) {
            return Reflect.getOwnPropertyDescriptor(target, prop);
        }
        else if (typeof prop === "string") {
            const index = Number.parseInt(prop, 10);
            if (index < target.length) {
                return DEFAULT_PROPERTY_DESCRIPTOR$2;
            }
        }
    },
};
/**
 * An {@link OrderedCollection} is a homogenous sequence of values of any of the types
 * that can be stored as properties of Realm objects. It can be
 * accessed in any of the ways that a normal JavaScript Array can, including
 * subscripting, enumerating with `for-of` and so on.
 * @see {@link https://mdn.io/Array | Array}
 */
class OrderedCollection extends Collection {
    /** @internal */
    constructor(realm, results, helpers) {
        if (arguments.length === 0) {
            throw new IllegalConstructorError("OrderedCollection");
        }
        super((callback) => {
            return results.addNotificationCallback((changes) => {
                try {
                    callback(proxied, {
                        deletions: unwind(changes.deletions),
                        insertions: unwind(changes.insertions),
                        oldModifications: unwind(changes.modifications),
                        newModifications: unwind(changes.modificationsNew),
                    });
                }
                catch (err) {
                    // Scheduling a throw on the event loop,
                    // since throwing synchronously here would result in an abort in the calling C++
                    setImmediate(() => {
                        throw err;
                    });
                }
            }, undefined);
        });
        // Wrap in a proxy to trap ownKeys and get, enabling the spread operator
        const proxied = new Proxy(this, PROXY_HANDLER$2);
        // Get the class helpers for later use, if available
        const { objectType } = results;
        const classHelpers = typeof objectType === "string" && objectType !== "" ? realm.getClassHelpers(objectType) : null;
        // Make the internal properties non-enumerable
        Object.defineProperty(this, "realm", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: realm,
        });
        Object.defineProperty(this, "results", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: results,
        });
        Object.defineProperty(this, "helpers", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: helpers,
        });
        Object.defineProperty(this, "classHelpers", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: classHelpers,
        });
        Object.defineProperty(this, "mixedToBinding", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: mixedToBinding.bind(undefined, realm.internal),
        });
        return proxied;
    }
    /**
     * Get an element of the ordered collection by index.
     * @param index - The index.
     * @returns The element.
     * @internal
     */
    get(index) {
        return this.helpers.fromBinding(this.helpers.get(this.results, index));
    }
    set() {
        throw new Error(`Assigning into a ${this.constructor.name} is not supported`);
    }
    /** @internal */
    toJSON(_, cache = new JSONCacheMap()) {
        return this.map((item, index) => {
            if (item instanceof RealmObject) {
                return item.toJSON(index.toString(), cache);
            }
            else {
                return item;
            }
        });
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys | Array.prototype.keys()}
     * @returns An iterator with all keys in the collection.
     */
    *keys() {
        const size = this.results.size();
        for (let i = 0; i < size; i++) {
            yield i;
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values} | Array.prototype.values()}
     * @returns An iterator with all values in the collection.
     */
    *values() {
        const snapshot = this.results.snapshot();
        const { get, fromBinding } = this.helpers;
        for (const i of this.keys()) {
            yield fromBinding(get(snapshot, i));
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries | Array.prototype.entries()}
     * @returns An iterator with all key/value pairs in the collection.
     */
    *entries() {
        const { get, fromBinding } = this.helpers;
        const snapshot = this.results.snapshot();
        const size = snapshot.size();
        for (let i = 0; i < size; i++) {
            yield [i, fromBinding(get(snapshot, i))];
        }
    }
    /**
     * @returns The number of values.
     */
    get length() {
        return this.results.size();
    }
    /**
     * @throws An {@link Error} as the length property cannot be assigned.
     */
    set length(value) {
        throw new Error("Cannot assign to read only property 'length'");
    }
    /**
     * Name of the type of items.
     * @returns The name of the type of values.
     */
    get type() {
        return getTypeName(this.results.type & ~960 /* binding.PropertyType.Flags */, undefined);
    }
    /**
     * Whether `null` is a valid value for the collection.
     * @returns Whether `null` is a valid value for the collection.
     * @readonly
     */
    get optional() {
        return !!(this.results.type & 64 /* binding.PropertyType.Nullable */);
    }
    /* eslint-disable @typescript-eslint/no-explicit-any -- We've copied these from the lib types */
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString | Array.prototype.toString()}
     * @returns A string representation of the collection.
     */
    toString() {
        return [...this].toString();
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString | Array.prototype.toLocaleString()}
     * @returns A localized string representation of the collection.
     */
    toLocaleString() {
        return [...this].toLocaleString();
    }
    concat(...items) {
        return [...this].concat(...items);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join | Array.prototype.join()}
     * @params separator - A string used to separate one element of the collection from the next in the resulting String.
     * @returns A string representing the elements of the collection.
     */
    join(separator) {
        return [...this].join(separator);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice | Array.prototype.slice()}
     * @params start - Zero-based index at which to begin extraction.
     * @params end - Zero-based index at which to end extraction. It extracts up to but not including `end`.
     * @returns A new array containing the elements between the start and end indices.
     */
    slice(start, end) {
        return [...this].slice(start, end);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf | Array.prototype.indexOf()}
     * @params searchElement - Element to locate in the collection.
     * @params fromIndex - The collection index at which to begin the search. If omitted, the search starts at index 0.
     * @note `fromIndex` is currently not supported. So all searches start at index 0.
     * @returns The first index at which a given element can be found in the collection, or -1 if it is not present.
     */
    indexOf(searchElement, fromIndex) {
        assert(typeof fromIndex === "undefined", "The second fromIndex argument is not yet supported");
        if (this.type === "object") {
            assert.instanceOf(searchElement, RealmObject);
            return this.results.indexOfObj(searchElement[INTERNAL$1]);
        }
        else {
            return this.results.indexOf(this.helpers.toBinding(searchElement));
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf | Array.prototype.lastIndexOf()}
     * @params searchElement - Element to locate in the collection.
     * @params fromIndex - The collection index at which to begin the search. If omitted, the search starts at the last index.
     * @returns The last index at which a given element can be found in the collection, or -1 if it is not present. The collection is searched backwards, starting at `fromIndex`.
     */
    lastIndexOf(searchElement, fromIndex) {
        return [...this].lastIndexOf(searchElement, fromIndex);
    }
    every(predicate, thisArg) {
        return [...this].every(predicate, thisArg);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some | Array.prototype.some()}
     * @params predicate - A function to test for each element.
     * @params predicate.value - The current element being processed in the collection.
     * @params predicate.index - The index of the current element being processed in the collection.
     * @params predicate.array - The collection `every` was called upon.
     * @params thisArg - An object to which the `this` keyword can refer in the predicate function. If `thisArg` is omitted, `undefined` is used as the `this` value.
     * @returns `true` if the callback function returns a truthy value for any collection element; otherwise, `false`.
     */
    some(predicate, thisArg) {
        return [...this].some(predicate, thisArg);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach | Array.prototype.forEach()}
     * @params callbackfn - A function that accepts up to three arguments. `forEach` calls the callbackfn function one time for each element in the collection.
     * @params callbackfn.value - The current element being processed in the collection.
     * @params callbackfn.index - The index of the current element being processed in the collection.
     * @params callbackfn.array - The collection `forEach` was called upon.
     * @params thisArg - An object to which the `this` keyword can refer in the `callbackfn` function. If `thisArg` is omitted, `undefined` is used as the `this` value.
     */
    forEach(callbackfn, thisArg) {
        return [...this].forEach(callbackfn, thisArg);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map | Array.prototype.map()}
     * @params callbackfn - A function that accepts up to three arguments. The `map` method calls the `callbackfn` function one time for each element in the collection.
     * @params callbackfn.value - The current element being processed in the collection.
     * @params callbackfn.index - The index of the current element being processed in the collection.
     * @params callbackfn.array - The collection `map` was called upon.
     * @params thisArg - An object to which the `this` keyword can refer in the `callbackfn` function. If `thisArg` is omitted, `undefined` is used as the `this` value.
     * @returns A new array containing the results of calling the `callbackfn` function on each element in the collection.
     */
    map(callbackfn, thisArg) {
        return [...this].map(callbackfn, thisArg);
    }
    filter(predicate, thisArg) {
        return [...this].filter(predicate, thisArg);
    }
    reduce(callbackfn, initialValue) {
        return [...this].reduce(callbackfn, initialValue);
    }
    reduceRight(callbackfn, initialValue) {
        return [...this].reduceRight(callbackfn, initialValue);
    }
    find(predicate, thisArg) {
        return [...this].find(predicate, thisArg);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex | Array.prototype.findIndex()}
     * @params predicate - A function that accepts up to three arguments. The `findIndex` method calls the `predicate` function one time for each element in the collection.
     * @params predicate.value - The value of the element.
     * @params predicate.index - The index of the element.
     * @params predicate.obj - The object being traversed.
     * @params thisArg - An object to which the `this` keyword can refer in the `predicate` function. If `thisArg` is omitted, `undefined` is used as the `this` value.
     * @returns The index of the first element in the array that satisfies the provided testing function. Otherwise, -1 is returned.
     */
    findIndex(predicate, thisArg) {
        return [...this].findIndex(predicate, thisArg);
    }
    // TODO: Implement support for RealmObjects, by comparing their #objectKey values
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes | Array.prototype.includes()}
     * @params searchElement - The element to search for.
     * @params fromIndex - The position in this array at which to begin searching for `searchElement`. A negative value searches from the index of array.length + fromIndex by asc.
     * @note `fromIndex` is currently not supported. So all searches start at index 0.
     * @returns `true` if the `searchElement` is found in the array; otherwise, `false`.
     */
    includes(searchElement, fromIndex) {
        return this.indexOf(searchElement, fromIndex) !== -1;
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap | Array.prototype.flatMap()}
     * @params callback - Function that produces an element of the new Array, taking three arguments:
     * @params callback.currentValue - The current element being processed in the array.
     * @params callback.index - The index of the current element being processed in the array.
     * @params callback.array - The array `flatMap` was called upon.
     * @params thisArg - Value to use as this when executing callback.
     * @returns A new array with each element being the result of the callback function and flattened to a depth of 1.
     */
    flatMap(callback, thisArg) {
        return [...this].flatMap(callback, thisArg);
    }
    flat() {
        throw new Error("Method not implemented.");
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/at | Array.prototype.at()}
     * @params index - The index of the element to return from the array. If the index is a negative number, the element at `array.length + index` is returned.
     * @returns The element at the given index in the array; `undefined` if there is no element at the given index.
     */
    at(index) {
        return [...this].at(index);
    }
    /* eslint-enable @typescript-eslint/no-explicit-any */
    /**
     * @returns An iterator that iterates over all the values in the collection.
     */
    [Symbol.iterator]() {
        return this.values();
    }
    // Other methods
    // TODO: Implement this method
    /**
     * @returns A string describing the filters applied to this collection.
     */
    description() {
        throw new Error("Method not implemented.");
    }
    /**
     * Checks if this collection is empty.
     * @returns `true` if the collection is empty, `false` if not.
     */
    isEmpty() {
        return this.results.size() === 0;
    }
    /**
     * Returns the minimum value of the values in the collection or of the
     * given property among all the objects in the collection, or `undefined`
     * if the collection is empty.
     *
     * Only supported for int, float, double and date properties. `null` values
     * are ignored entirely by this method and will not be returned.
     * @param property - For a collection of objects, the property to take the minimum of.
     * @throws A {@link TypeAssertionError} if no property with the name exists or if property is not numeric/date.
     * @returns The minimum value.
     */
    min(property) {
        const columnKey = this.getPropertyColumnKey(property);
        const result = this.results.min(columnKey);
        if (result instanceof Date || typeof result === "number" || typeof result === "undefined") {
            return result;
        }
        else if (Int64.isInt(result)) {
            return Int64.intToNum(result);
        }
        else if (result instanceof Float) {
            return result.value;
        }
        else if (result instanceof Timestamp) {
            return result.toDate();
        }
        else {
            throw new TypeAssertionError("Timestamp, number, bigint, Float or null", result, "result");
        }
    }
    /**
     * Returns the maximum value of the values in the collection or of the
     * given property among all the objects in the collection, or `undefined`
     * if the collection is empty.
     *
     * Only supported for int, float, double and date properties. `null` values
     * are ignored entirely by this method and will not be returned.
     * @param property - For a collection of objects, the property to take the maximum of.
     * @throws An {@link Error} if no property with the name exists or if property is not numeric/date.
     * @returns The maximum value.
     */
    max(property) {
        const columnKey = this.getPropertyColumnKey(property);
        const result = this.results.max(columnKey);
        if (result instanceof Date || typeof result === "number" || typeof result === "undefined") {
            return result;
        }
        else if (Int64.isInt(result)) {
            return Int64.intToNum(result);
        }
        else if (result instanceof Float) {
            return result.value;
        }
        else if (result instanceof Timestamp) {
            return result.toDate();
        }
        else {
            throw new TypeAssertionError("Timestamp, number, bigint, Float or undefined", result, "result");
        }
    }
    /**
     * Computes the sum of the values in the collection or of the given
     * property among all the objects in the collection, or 0 if the collection
     * is empty.
     *
     * Only supported for int, float and double properties. `null` values are
     * ignored entirely by this method.
     * @param property - For a collection of objects, the property to take the sum of.
     * @throws An {@link Error} if no property with the name exists or if property is not numeric.
     * @returns The sum.
     */
    sum(property) {
        const columnKey = this.getPropertyColumnKey(property);
        const result = this.results.sum(columnKey);
        if (typeof result === "number") {
            return result;
        }
        else if (Int64.isInt(result)) {
            return Int64.intToNum(result);
        }
        else if (result instanceof Float) {
            return result.value;
        }
        else {
            throw new TypeAssertionError("number, bigint or Float", result, "result");
        }
    }
    /**
     * Computes the average of the values in the collection or of the given
     * property among all the objects in the collection, or `undefined` if the collection
     * is empty.
     *
     * Only supported for int, float and double properties. `null` values are
     * ignored entirely by this method and will not be factored into the average.
     * @param property - For a collection of objects, the property to take the average of.
     * @throws An {@link Error} if no property with the name exists or if property is not numeric.
     * @returns The sum.
     */
    avg(property) {
        const columnKey = this.getPropertyColumnKey(property);
        const result = this.results.average(columnKey);
        if (typeof result === "number" || typeof result === "undefined") {
            return result;
        }
        else if (Int64.isInt(result)) {
            return Int64.intToNum(result);
        }
        else if (result instanceof Float) {
            return result.value;
        }
        else {
            throw new TypeAssertionError("number, Float, bigint or undefined", result, "result");
        }
    }
    /**
     * Returns new {@link Results} that represent this collection being filtered by the provided query.
     * @param queryString - Query used to filter objects from the collection.
     * @param args - Each subsequent argument is used by the placeholders
     * (e.g. `$0`, `$1`, `$2`, ) in the query.
     * @throws An {@link Error} if the query or any other argument passed into this method is invalid.
     * @returns Results filtered according to the provided query.
     * @note This is currently only supported for collections of Realm Objects.
     * @example
     * let merlots = wines.filtered('variety == "Merlot" && vintage <= $0', maxYear);
     */
    filtered(queryString, ...args) {
        const { results: parent, realm, helpers } = this;
        const kpMapping = Helpers.getKeypathMapping(realm.internal);
        const bindingArgs = args.map((arg) => Array.isArray(arg) ? arg.map((sub) => this.mixedToBinding(sub)) : this.mixedToBinding(arg));
        const newQuery = parent.query.table.query(queryString, bindingArgs, kpMapping);
        const results = Helpers.resultsAppendQuery(parent, newQuery);
        return new Results(realm, results, helpers);
    }
    sorted(arg0 = "self", arg1) {
        if (Array.isArray(arg0)) {
            assert.undefined(arg1, "second 'argument'");
            const { results: parent, realm, helpers } = this;
            // Map optional "reversed" to "ascending" (expected by the binding)
            const descriptors = arg0.map((arg, i) => {
                if (typeof arg === "string") {
                    return [arg, true];
                }
                else if (Array.isArray(arg)) {
                    const [property, direction] = arg;
                    assert.string(property, "property");
                    assert.boolean(direction, "direction");
                    return [property, !direction];
                }
                else {
                    throw new TypeAssertionError("string or array with two elements [string, boolean]", arg, `descriptor[${i}]`);
                }
            });
            // TODO: Call `parent.sort`, avoiding property name to column key conversion to speed up performance here.
            const results = parent.sortByNames(descriptors);
            return new Results(realm, results, helpers);
        }
        else if (typeof arg0 === "string") {
            return this.sorted([[arg0, arg1 === true]]);
        }
        else if (typeof arg0 === "boolean") {
            return this.sorted([["self", arg0]]);
        }
        else {
            throw new TypeAssertionError("property name and optional bool or an array of descriptors", arg0, "argument");
        }
    }
    /**
     * Create a frozen snapshot of the collection.
     *
     * Values added to and removed from the original collection will not be
     * reflected in the _Results_ returned by this method, including if the
     * values of properties are changed to make them match or not match any
     * filters applied.
     *
     * This is **not** a _deep_ snapshot. Realm objects contained in this
     * snapshot will continue to update as changes are made to them, and if
     * they are deleted from the Realm they will be replaced by `null` at the
     * respective indices.
     * @returns Results which will **not** live update.
     */
    snapshot() {
        return new Results(this.realm, this.results.snapshot(), this.helpers);
    }
    getPropertyColumnKey(name) {
        if (this.classHelpers) {
            assert.string(name, "name");
            return this.classHelpers.properties.get(name).columnKey;
        }
        else if (name) {
            throw new Error(`Cannot get property named '${name}' on a list of primitives`);
        }
        else {
            return DEFAULT_COLUMN_KEY;
        }
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Instances of this class are typically **live** collections returned by
 * objects() that will update as new objects are either
 * added to or deleted from the Realm that match the underlying query. Results returned by
 * snapshot()}, however, will **not** live update
 * (and listener callbacks added through addListener()
 * will thus never be called).
 * @see https://www.mongodb.com/docs/realm/sdk/react-native/model-data/data-types/collections/
 */
class Results extends OrderedCollection {
    /** @internal */
    subscriptionName;
    /**
     * Create a `Results` wrapping a set of query `Results` from the binding.
     * @internal
     */
    constructor(realm, internal, helpers) {
        if (arguments.length === 0 || !(internal instanceof Results$1)) {
            throw new IllegalConstructorError("Results");
        }
        super(realm, internal, helpers);
        Object.defineProperty(this, "internal", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: internal,
        });
        Object.defineProperty(this, "realm", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: realm,
        });
        Object.defineProperty(this, "subscriptionName", {
            enumerable: false,
            configurable: false,
            writable: true,
        });
    }
    get length() {
        return this.internal.size();
    }
    set length(value) {
        throw new Error("Cannot assign to read only property 'length'");
    }
    /*
     * @returns A string representation of the query and sorting bound to the results.
     */
    description() {
        return Helpers.getResultsDescription(this.internal);
    }
    /**
     * Bulk update objects in the collection.
     * @param propertyName - The name of the property.
     * @param value - The updated property value.
     * @throws An {@link Error} if no property with the name exists.
     * @since 2.0.0
     */
    update(propertyName, value) {
        const { classHelpers, helpers: { get }, } = this;
        assert.string(propertyName);
        assert(this.type === "object" && classHelpers, "Expected a result of Objects");
        const { set } = classHelpers.properties.get(propertyName);
        const snapshot = this.results.snapshot();
        const size = snapshot.size();
        for (let i = 0; i < size; i++) {
            const obj = get(snapshot, i);
            assert.instanceOf(obj, Obj);
            set(obj, value);
        }
    }
    /**
     * Add this query result to the set of active subscriptions. The query will be joined
     * via an `OR` operator with any existing queries for the same type.
     * @param options - Options to use when adding this subscription (e.g. a name or wait behavior).
     * @returns A promise that resolves to this {@link Results} instance.
     * @experimental This API is experimental and may change or be removed.
     */
    async subscribe(options = { behavior: exports.WaitForSync.FirstTime }) {
        const subs = this.realm.subscriptions;
        const shouldWait = options.behavior === exports.WaitForSync.Always || (options.behavior === exports.WaitForSync.FirstTime && !subs.exists(this));
        if (shouldWait) {
            if (typeof options.timeout === "number") {
                await new TimeoutPromise(subs.update((mutableSubs) => mutableSubs.add(this, options)), { ms: options.timeout, rejectOnTimeout: false });
            }
            else {
                await subs.update((mutableSubs) => mutableSubs.add(this, options));
            }
        }
        else {
            subs.updateNoWait((mutableSubs) => mutableSubs.add(this, options));
        }
        return this;
    }
    /**
     * Unsubscribe from this query result. It returns immediately without waiting
     * for synchronization.
     *
     * If the subscription is unnamed, the subscription matching the query will
     * be removed.
     * @experimental This API is experimental and may change or be removed.
     */
    unsubscribe() {
        this.realm.subscriptions.updateNoWait((mutableSubs) => {
            if (this.subscriptionName) {
                mutableSubs.removeByName(this.subscriptionName);
            }
            else {
                mutableSubs.remove(this);
            }
        });
    }
    /**
     * Checks if this results collection has not been deleted and is part of a valid Realm.
     * @returns `true` if the collection can be safely accessed.
     */
    isValid() {
        return this.internal.isValid;
    }
    /**
     * Checks if this collection result is empty.
     * @returns `true` if the collection result is empty, `false` if not.
     */
    isEmpty() {
        return this.internal.size() === 0;
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Instances of this class will be returned when accessing object properties whose type is `"list"`.
 *
 * Lists mostly behave like normal Javascript Arrays, except for that they can
 * only store values of a single type (indicated by the `type` and `optional`
 * properties of the List), and can only be modified inside a {@link Realm.write | write} transaction.
 */
class List extends OrderedCollection {
    /** @internal */
    constructor(realm, internal, helpers) {
        if (arguments.length === 0 || !(internal instanceof List$1)) {
            throw new IllegalConstructorError("List");
        }
        super(realm, internal.asResults(), helpers);
        // Getting the `objectSchema` off the internal will throw if base type isn't object
        const baseType = this.results.type & ~960 /* binding.PropertyType.Flags */;
        const isEmbedded = baseType === 7 /* binding.PropertyType.Object */ && internal.objectSchema.tableType === 1 /* binding.TableType.Embedded */;
        Object.defineProperty(this, "internal", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: internal,
        });
        Object.defineProperty(this, "isEmbedded", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: isEmbedded,
        });
    }
    /**
     * Checks if this collection has not been deleted and is part of a valid Realm.
     * @returns `true` if the collection can be safely accessed.
     */
    isValid() {
        return this.internal.isValid;
    }
    /**
     * Set an element of the ordered collection by index
     * @param index The index
     * @param value The value
     * @internal
     */
    set(index, value) {
        const { realm, internal, isEmbedded, helpers: { toBinding }, } = this;
        assert.inTransaction(realm);
        // TODO: Consider a more performant way to determine if the list is embedded
        internal.setAny(index, toBinding(value, isEmbedded ? { createObj: () => [internal.insertEmbedded(index), true] } : undefined));
    }
    /**
     * @returns The number of values in the list.
     */
    get length() {
        return this.internal.size;
    }
    /**
     * @throws An {@link Error} as the length property cannot be assigned.
     */
    set length(value) {
        throw new Error("Cannot assign to read only property 'length'");
    }
    /**
     * Remove the **last** value from the list and return it.
     * @throws an {@link AssertionError} If not inside a write transaction.
     * @returns The last value or undefined if the list is empty.
     */
    pop() {
        assert.inTransaction(this.realm);
        const { internal, helpers: { fromBinding }, } = this;
        const lastIndex = internal.size - 1;
        if (lastIndex >= 0) {
            const result = fromBinding(internal.getAny(lastIndex));
            internal.remove(lastIndex);
            return result;
        }
    }
    /**
     * Add one or more values to the _end_ of the list.
     * @param items - Values to add to the list.
     * @throws A {TypeError} if a value is not of a type which can be stored in
     * the list, or if an object being added to the list does not match the {@link ObjectSchema} for the list.
     * @throws An {@link AssertionError} if not inside a write transaction.
     * @returns The new length of the list after adding the values.
     */
    push(...items) {
        assert.inTransaction(this.realm);
        const { isEmbedded, internal, helpers: { toBinding }, } = this;
        const start = internal.size;
        for (const [offset, item] of items.entries()) {
            const index = start + offset;
            if (isEmbedded) {
                // Simply transforming to binding will insert the embedded object
                toBinding(item, { createObj: () => [internal.insertEmbedded(index), true] });
            }
            else {
                internal.insertAny(index, toBinding(item));
            }
        }
        return internal.size;
    }
    /**
     * Remove the **first** value from the list and return it.
     * @throws An {@link AssertionError} if not inside a write transaction.
     * @returns The first value or `undefined` if the list is empty.
     */
    shift() {
        assert.inTransaction(this.realm);
        const { internal, helpers: { fromBinding }, } = this;
        if (internal.size > 0) {
            const result = fromBinding(internal.getAny(0));
            internal.remove(0);
            return result;
        }
    }
    /**
     * Add one or more values to the _beginning_ of the list.
     * @param items - Values to add to the list.
     * @throws A {TypeError} if a value is not of a type which can be stored in
     * the list, or if an object being added to the list does not match the {@link ObjectSchema} for the list.
     * @throws An {@link AssertionError} if not inside a write transaction.
     * @returns The new length of the list after adding the values.
     */
    unshift(...items) {
        assert.inTransaction(this.realm);
        const { isEmbedded, internal, helpers: { toBinding }, } = this;
        for (const [index, item] of items.entries()) {
            if (isEmbedded) {
                // Simply transforming to binding will insert the embedded object
                toBinding(item, { createObj: () => [internal.insertEmbedded(index), true] });
            }
            else {
                internal.insertAny(index, toBinding(item));
            }
        }
        return internal.size;
    }
    /**
     * Changes the contents of the list by removing value and/or inserting new value.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice Array.prototype.splice}
     * @param start - The start index. If greater than the length of the list,
     * the start index will be set to the length instead. If negative, then the start index
     * will be counted from the end of the list (e.g. `list.length - index`).
     * @param deleteCount - The number of values to remove from the list.
     * If not provided, then all values from the start index through the end of
     * the list will be removed.
     * @param items - Values to insert into the list starting at `index`.
     * @returns An array containing the value that were removed from the list. The
     * array is empty if no value were removed.
     */
    splice(start, deleteCount, ...items) {
        // Comments in the code below is copied from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
        assert.inTransaction(this.realm);
        assert.number(start, "start");
        const { isEmbedded, internal, helpers: { fromBinding, toBinding }, } = this;
        // If negative, it will begin that many elements from the end of the array.
        if (start < 0) {
            start = internal.size + start;
        }
        // If greater than the length of the array, start will be set to the length of the array.
        if (start > internal.size) {
            start = internal.size;
        }
        // If deleteCount is omitted, or if its value is equal to or larger than array.length - start
        // (that is, if it is equal to or greater than the number of elements left in the array, starting at start),
        // then all the elements from start to the end of the array will be deleted.
        const end = typeof deleteCount === "number" ? Math.min(start + deleteCount, internal.size) : internal.size;
        // Get the elements that are about to be deleted
        const result = [];
        for (let i = start; i < end; i++) {
            result.push(fromBinding(internal.getAny(i)));
        }
        // Remove the elements from the list (backwards to avoid skipping elements as they're being deleted)
        for (let i = end - 1; i >= start; i--) {
            internal.remove(i);
        }
        // Insert any new elements
        for (const [offset, item] of items.entries()) {
            const index = start + offset;
            if (isEmbedded) {
                // Simply transforming to binding will insert the embedded object
                toBinding(item, { createObj: () => [internal.insertEmbedded(index), true] });
            }
            else {
                internal.insertAny(index, toBinding(item));
            }
        }
        return result;
    }
    /**
     * Removes the element of the list at the specified index.
     * @param index - The index of the element to remove.
     * @throws An {@link AssertionError} if not inside a write transaction or the input index is less than 0
     * or greater than or equal to the size of the list.
     */
    remove(index) {
        assert.inTransaction(this.realm);
        assert.number(index, "index");
        assert(index >= 0, "Index cannot be smaller than 0");
        assert(index < this.internal.size, "Index cannot be greater than the size of the list");
        this.internal.remove(index);
    }
    /**
     * Moves one element of the list from one index to another.
     * @param from - The index of the element to move.
     * @param to - The destination index of the element.
     * @throws An {@link AssertionError} if not inside a write transaction or if any of the input indexes
     * is less than 0 or greater than or equal to the size of the list.
     */
    move(from, to) {
        assert.inTransaction(this.realm);
        assert.number(from, "from");
        assert.number(to, "to");
        const size = this.internal.size;
        assert(from >= 0 && to >= 0, "Indexes cannot be smaller than 0");
        assert(from < size && to < size, "Indexes cannot be greater than the size of the list");
        this.internal.move(from, to);
    }
    /**
     * Swaps the positions of the elements of the list at two indexes.
     * @param index1 - The index of the first element.
     * @param index2 - The index of the second element.
     * @throws An {@link AssertionError} if not inside a write transaction or if any of the input indexes
     * is less than 0 or greater than or equal to the size of the list.
     */
    swap(index1, index2) {
        assert.inTransaction(this.realm);
        assert.number(index1, "index1");
        assert.number(index2, "index2");
        const size = this.internal.size;
        assert(index1 >= 0 && index2 >= 0, "Indexes cannot be smaller than 0");
        assert(index1 < size && index2 < size, "Indexes cannot be greater than the size of the list");
        this.internal.swap(index1, index2);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Instances of this class will be returned when accessing object properties whose type is `"Set"`
 *
 * Sets mostly behave like normal JavaScript Sets, with a few exceptions:
 * They can only store values of a single type (indicated by the `type`
 * and `optional` properties of the Set).
 * They can only be modified inside a **write** transaction.
 * Unlike JavaScript's Set, Realm~Set does NOT make any guarantees about the
 * traversal order of `values()`, `entries()`, `keys()`, or `forEach` iterations.
 * If values in a Set are required to have some order, it must be implemented
 * by the developer by, for example, wrapping values in an object that holds
 * a user-supplied insertion order.
 * @see https://www.mongodb.com/docs/realm/sdk/react-native/model-data/data-types/sets/
 */
class RealmSet extends OrderedCollection {
    /** @internal */
    constructor(realm, internal, helpers) {
        if (arguments.length === 0 || !(internal instanceof Set$1)) {
            throw new IllegalConstructorError("Set");
        }
        super(realm, internal.asResults(), helpers);
        Object.defineProperty(this, "internal", {
            enumerable: false,
            configurable: false,
            writable: false,
            value: internal,
        });
    }
    /**
     * @returns The number of values in the Set.
     */
    get size() {
        return this.length;
    }
    /**
     * Checks if this Set has not been deleted and is part of a valid Realm.
     * @returns `true` if the set can be safely accessed, `false` if not.
     */
    isValid() {
        return this.internal.isValid;
    }
    /**
     * Delete a value from the Set.
     * @param value - Value to delete from the Set.
     * @throws An {@link Error} if not inside a write transaction.
     * @returns `true` if the value existed in the Set prior to deletion, `false` if not.
     */
    delete(value) {
        assert.inTransaction(this.realm);
        const [, success] = this.internal.removeAny(this.helpers.toBinding(value));
        return success;
    }
    /**
     * Add a new value to the Set.
     * @param value - Value to add to the Set.
     * @throws A {@link TypeError} if a `value` is not of a type which can be stored in
     * the Set, or if an object being added to the Set does not match the for the Set.
     * @throws An {@link Error} if not inside a write transaction.
     * @returns The Set itself, after adding the new value.
     */
    add(value) {
        assert.inTransaction(this.realm);
        this.internal.insertAny(this.helpers.toBinding(value));
        return this;
    }
    /**
     * Remove all values from the Set.
     * @throws An {@link Error} if not inside a write transaction.
     */
    clear() {
        assert.inTransaction(this.realm);
        this.internal.deleteAll();
    }
    /**
     * Check for existence of a value in the Set.
     * @param value - Value to search for in the Set
     * @throws A {@link TypeError} if a `value` is not of a type which can be stored in
     * the Set, or if an object being added to the Set does not match the
     * **object schema** for the Set.
     * @returns `true` if the value exists in the Set, `false` if not.
     */
    has(value) {
        return this.includes(value);
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/entries | Set.prototype.entries()}
     * @returns An iterator over the entries of the Set. Each entry is a two-element array
     * containing the value from the Set, followed by a copy of the same value (`[value, value]`).
     */
    *entries() {
        for (const value of this.values()) {
            yield [value, value];
        }
    }
}

////////////////////////////////////////////////////////////////////////////
/* eslint-disable jsdoc/multiline-blocks -- We need this to have @ts-expect-error located correctly in the .d.ts bundle */
const REALM = Symbol("Dictionary#realm");
const INTERNAL = Symbol("Dictionary#internal");
const HELPERS = Symbol("Dictionary#helpers");
const DEFAULT_PROPERTY_DESCRIPTOR$1 = { configurable: true, enumerable: true };
const PROXY_HANDLER$1 = {
    get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === "undefined" && typeof prop === "string") {
            const internal = target[INTERNAL];
            const fromBinding = target[HELPERS].fromBinding;
            return fromBinding(internal.tryGetAny(prop));
        }
        else {
            return value;
        }
    },
    set(target, prop, value) {
        if (typeof prop === "string") {
            const internal = target[INTERNAL];
            const toBinding = target[HELPERS].toBinding;
            internal.insertAny(prop, toBinding(value));
            return true;
        }
        else {
            assert(typeof prop !== "symbol", "Symbols cannot be used as keys of a dictionary");
            return false;
        }
    },
    deleteProperty(target, prop) {
        // We're intentionally not checking !Reflect.has(target, prop) below to allow deletes to propagate for any key
        if (typeof prop === "string") {
            const internal = target[INTERNAL];
            internal.tryErase(prop);
            // We consider any key without a value as "deletable", the same way `const foo = {}; delete foo.bar;` returns true
            return true;
        }
        else {
            return false;
        }
    },
    ownKeys(target) {
        const internal = target[INTERNAL];
        const result = Reflect.ownKeys(target);
        const keys = internal.keys.snapshot();
        for (let i = 0; i < keys.size(); i++) {
            const key = keys.getAny(i);
            assert.string(key, "dictionary key");
            result.push(key);
        }
        return result;
    },
    getOwnPropertyDescriptor(target, prop) {
        const internal = target[INTERNAL];
        if (typeof prop === "string" && internal.contains(prop)) {
            return {
                ...DEFAULT_PROPERTY_DESCRIPTOR$1,
                get: PROXY_HANDLER$1.get?.bind(null, target, prop, null),
                set: PROXY_HANDLER$1.set?.bind(null, target, prop, null),
            };
        }
        else {
            return Reflect.getOwnPropertyDescriptor(target, prop);
        }
    },
};
/**
 * Instances of this class are returned when accessing object properties whose type is `"Dictionary"`
 *
 * Dictionaries behave mostly like a JavaScript object i.e., as a key/value pair
 * where the key is a string.
 */
class Dictionary extends Collection {
    /**
     * Create a `Results` wrapping a set of query `Results` from the binding.
     * @internal
     */
    constructor(realm, internal, helpers) {
        if (arguments.length === 0 || !(internal instanceof Dictionary$1)) {
            throw new IllegalConstructorError("Dictionary");
        }
        super((callback) => {
            return this[INTERNAL].addKeyBasedNotificationCallback(({ deletions, insertions, modifications }) => {
                try {
                    callback(proxied, {
                        deletions: deletions.map((value) => {
                            assert.string(value);
                            return value;
                        }),
                        insertions: insertions.map((value) => {
                            assert.string(value);
                            return value;
                        }),
                        modifications: modifications.map((value) => {
                            assert.string(value);
                            return value;
                        }),
                    });
                }
                catch (err) {
                    // Scheduling a throw on the event loop,
                    // since throwing synchronously here would result in an abort in the calling C++
                    setImmediate(() => {
                        throw err;
                    });
                }
            }, []);
        });
        const proxied = new Proxy(this, PROXY_HANDLER$1);
        Object.defineProperty(this, REALM, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: realm,
        });
        Object.defineProperty(this, INTERNAL, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: internal,
        });
        Object.defineProperty(this, HELPERS, {
            enumerable: false,
            configurable: false,
            writable: false,
            value: helpers,
        });
        return proxied;
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries Array.prototype.entries}
     * @returns An iterator with all entries in the dictionary.
     */
    *[Symbol.iterator]() {
        yield* this.entries();
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys Array.prototype.keys}
     * @returns An iterator with all values in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    *keys() {
        const snapshot = this[INTERNAL].keys.snapshot();
        const size = snapshot.size();
        for (let i = 0; i < size; i++) {
            const key = snapshot.getAny(i);
            assert.string(key);
            yield key;
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values Array.prototype.values}
     * @returns An iterator with all values in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of values */
    *values() {
        const { fromBinding } = this[HELPERS];
        const snapshot = this[INTERNAL].values.snapshot();
        const size = snapshot.size();
        for (let i = 0; i < size; i++) {
            const value = snapshot.getAny(i);
            yield fromBinding(value);
        }
    }
    /**
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries Array.prototype.entries}
     * @returns An iterator with all key/value pairs in the dictionary.
     * @since 10.5.0
     * @ts-expect-error We're exposing methods in the end-users namespace of entries */
    *entries() {
        const { fromBinding } = this[HELPERS];
        const keys = this[INTERNAL].keys.snapshot();
        const values = this[INTERNAL].values.snapshot();
        const size = keys.size();
        assert(size === values.size(), "Expected keys and values to equal in size");
        for (let i = 0; i < size; i++) {
            const key = keys.getAny(i);
            const value = values.getAny(i);
            yield [key, fromBinding(value)];
        }
    }
    /**
     * Checks if this dictionary has not been deleted and is part of a valid Realm.
     * @returns `true` if the dictionary can be safely accessed.
     * @since 0.14.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    isValid() {
        return this[INTERNAL].isValid;
    }
    /**
     * Adds one or more elements with the specified key and value to the dictionary or updates value if key exists.
     * @param elementsOrKey - The element to add or the key of the element to add.
     * @param value - The value of the element to add.
     * @throws An {@link AssertionError} if not inside a write transaction, if using symbol as keys, or if any value violates type constraints.
     * @returns The dictionary.
     * @since 10.6.0
     */
    set(elementsOrKey, value) {
        const elements = typeof elementsOrKey === "object" ? elementsOrKey : { [elementsOrKey]: value };
        assert(Object.getOwnPropertySymbols(elements).length === 0, "Symbols cannot be used as keys of a dictionary");
        assert.inTransaction(this[REALM]);
        const internal = this[INTERNAL];
        const toBinding = this[HELPERS].toBinding;
        for (const [key, val] of Object.entries(elements)) {
            internal.insertAny(key, toBinding(val));
        }
        return this;
    }
    /**
     * Removes elements from the dictionary, with the keys provided.
     * This does not throw if the keys are already missing from the dictionary.
     * @param key - The key to be removed.
     * @throws An {@link AssertionError} if not inside a write transaction.
     * @returns The dictionary
     * @since 10.6.0
     * @ts-expect-error We're exposing methods in the end-users namespace of keys */
    remove(key) {
        assert.inTransaction(this[REALM]);
        const internal = this[INTERNAL];
        const keys = typeof key === "string" ? [key] : key;
        for (const k of keys) {
            internal.tryErase(k);
        }
        return this;
    }
    /** @internal */
    toJSON(_, cache = new JSONCacheMap()) {
        return Object.fromEntries(Object.entries(this).map(([k, v]) => [k, v instanceof RealmObject ? v.toJSON(k, cache) : v]));
    }
}

////////////////////////////////////////////////////////////////////////////
const RealmDictionary = Dictionary;
const RealmList = List;
const RealmResults = Results;
const GlobalDate = Date;
// eslint-disable-next-line @typescript-eslint/no-namespace
exports.Types = void 0;
(function (Types) {
    Types.Decimal128 = exports.BSON.Decimal128;
    Types.ObjectId = exports.BSON.ObjectId;
    Types.UUID = exports.BSON.UUID;
    Types.Date = GlobalDate;
    Types.Data = ArrayBuffer;
    Types.List = RealmList;
    Types.Set = RealmSet;
    Types.Dictionary = RealmDictionary;
    Types.LinkingObjects = RealmResults;
})(exports.Types || (exports.Types = {}));

////////////////////////////////////////////////////////////////////////////
/** @internal */
function circleToBindingGeospatial(circle) {
    return Geospatial.makeFromCircle({
        center: toBindingGeoPoint(circle.center),
        radiusRadians: circle.distance,
    });
}
/** @internal */
function boxToBindingGeospatial(box) {
    return Geospatial.makeFromBox({
        lo: toBindingGeoPoint(box.bottomLeft),
        hi: toBindingGeoPoint(box.topRight),
    });
}
/** @internal */
function polygonToBindingGeospatial(polygon) {
    let points;
    if ("type" in polygon) {
        points = toBindingGeoPointArray(polygon.coordinates);
    }
    else {
        points = toBindingGeoPointArray([polygon.outerRing].concat(polygon.holes ?? []));
    }
    return Geospatial.makeFromPolygon({
        points,
    });
}
function toBindingGeoPoint(p) {
    if (Array.isArray(p)) {
        return { longitude: p[0], latitude: p[1], altitude: p[2] };
    }
    else if ("type" in p) {
        return { longitude: p.coordinates[0], latitude: p.coordinates[1], altitude: p.coordinates[2] };
    }
    else {
        return p;
    }
}
function toBindingGeoPointArray(arr) {
    return arr.map((ring) => ring.map((p) => toBindingGeoPoint(p)));
}
const earthRadiusKm = 6378.1;
const earthRadiusMi = 3963.16760121; //earthRadiusKm / 1.609344 (km/mi)
/**
 * Converts the input kilometer value in radians.
 * @param km - The kilometers to convert.
 * @returns The corresponding number of radians.
 */
function kmToRadians(km) {
    return km / earthRadiusKm;
}
/**
 * Converts the input miles value in radians.
 * @param mi - The miles to convert.
 * @returns The corresponding number of radians.
 */
function miToRadians(mi) {
    return mi / earthRadiusMi;
}

////////////////////////////////////////////////////////////////////////////
exports.NumericLogLevel = void 0;
(function (NumericLogLevel) {
    NumericLogLevel[NumericLogLevel["All"] = 0] = "All";
    NumericLogLevel[NumericLogLevel["Trace"] = 1] = "Trace";
    NumericLogLevel[NumericLogLevel["Debug"] = 2] = "Debug";
    NumericLogLevel[NumericLogLevel["Detail"] = 3] = "Detail";
    NumericLogLevel[NumericLogLevel["Info"] = 4] = "Info";
    NumericLogLevel[NumericLogLevel["Warn"] = 5] = "Warn";
    NumericLogLevel[NumericLogLevel["Error"] = 6] = "Error";
    NumericLogLevel[NumericLogLevel["Fatal"] = 7] = "Fatal";
    NumericLogLevel[NumericLogLevel["Off"] = 8] = "Off";
})(exports.NumericLogLevel || (exports.NumericLogLevel = {}));
/** @internal */
function toBindingLoggerLevel(arg) {
    const bindingLogLevel = inverseTranslationTable[arg];
    assert(bindingLogLevel !== undefined, `Unexpected log level: ${arg}`);
    return bindingLogLevel;
}
/** @internal */
function fromBindingLoggerLevelToNumericLogLevel(arg) {
    // For now, these map 1-to-1
    return arg;
}
const translationTable = {
    [0 /* binding.LoggerLevel.All */]: "all",
    [1 /* binding.LoggerLevel.Trace */]: "trace",
    [2 /* binding.LoggerLevel.Debug */]: "debug",
    [3 /* binding.LoggerLevel.Detail */]: "detail",
    [4 /* binding.LoggerLevel.Info */]: "info",
    [5 /* binding.LoggerLevel.Warn */]: "warn",
    [6 /* binding.LoggerLevel.Error */]: "error",
    [7 /* binding.LoggerLevel.Fatal */]: "fatal",
    [8 /* binding.LoggerLevel.Off */]: "off",
};
const inverseTranslationTable = Object.fromEntries(Object.entries(translationTable).map(([key, val]) => [val, Number(key)]));
/** @internal */
function fromBindingLoggerLevelToLogLevel(arg) {
    return translationTable[arg];
}
/** @internal */
const defaultLogger = function (logLevel, message) {
    const formattedLogMessage = `[${logLevel}] ${message}`;
    /* eslint-disable no-console */
    if (logLevel === "error" || logLevel === "fatal") {
        console.error(formattedLogMessage);
    }
    else if (logLevel === "warn") {
        console.warn(formattedLogMessage);
    }
    else {
        console.log(formattedLogMessage);
    }
    /* eslint-enable no-console */
};
/** @internal */
const defaultLoggerLevel = "warn";

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Remove entries for undefined property values.
 * @internal
 */
function cleanArguments(args) {
    if (Array.isArray(args)) {
        // Note: `undefined` elements in the array is not removed.
        return args.map(cleanArguments);
    }
    // Checking for constructor to allow for `new Date()` and `new ObjectId()` and similar.
    if (args === null || typeof args !== "object" || args?.constructor !== Object) {
        return args;
    }
    const result = {};
    for (const [key, value] of Object.entries(args)) {
        if (value !== undefined) {
            result[key] = cleanArguments(value);
        }
    }
    return result;
}

////////////////////////////////////////////////////////////////////////////
exports.OpenRealmBehaviorType = void 0;
(function (OpenRealmBehaviorType) {
    OpenRealmBehaviorType["DownloadBeforeOpen"] = "downloadBeforeOpen";
    OpenRealmBehaviorType["OpenImmediately"] = "openImmediately";
})(exports.OpenRealmBehaviorType || (exports.OpenRealmBehaviorType = {}));
exports.OpenRealmTimeOutBehavior = void 0;
(function (OpenRealmTimeOutBehavior) {
    OpenRealmTimeOutBehavior["OpenLocalRealm"] = "openLocalRealm";
    OpenRealmTimeOutBehavior["ThrowException"] = "throwException";
})(exports.OpenRealmTimeOutBehavior || (exports.OpenRealmTimeOutBehavior = {}));
exports.SessionStopPolicy = void 0;
(function (SessionStopPolicy) {
    SessionStopPolicy["AfterUpload"] = "after-upload";
    SessionStopPolicy["Immediately"] = "immediately";
    SessionStopPolicy["Never"] = "never";
})(exports.SessionStopPolicy || (exports.SessionStopPolicy = {}));
/**
 */
exports.ClientResetMode = void 0;
(function (ClientResetMode) {
    /** @deprecated See {@link Realm.App.Sync.initiateClientReset} */
    ClientResetMode["Manual"] = "manual";
    /**
     * Download a fresh copy from the server.
     */
    ClientResetMode["DiscardUnsyncedChanges"] = "discardUnsyncedChanges";
    /**
     * Merged remote and local, unsynced changes.
     */
    ClientResetMode["RecoverUnsyncedChanges"] = "recoverUnsyncedChanges";
    /**
     * Download a fresh copy from the server if recovery of unsynced changes is not possible.
     */
    ClientResetMode["RecoverOrDiscardUnsyncedChanges"] = "recoverOrDiscardUnsyncedChanges";
})(exports.ClientResetMode || (exports.ClientResetMode = {}));
exports.ProxyType = void 0;
(function (ProxyType) {
    ProxyType["HTTP"] = "http";
    ProxyType["HTTPS"] = "https";
})(exports.ProxyType || (exports.ProxyType = {}));
/** @internal */
function toBindingSyncConfig(config) {
    const { user, flexible, partitionValue, onError, _sessionStopPolicy, customHttpHeaders, ssl, clientReset, cancelWaitsOnNonFatalError, proxyConfig, } = config;
    return {
        user: user.internal,
        partitionValue: flexible ? undefined : bson.EJSON.stringify(partitionValue),
        flxSyncRequested: !!flexible,
        stopPolicy: _sessionStopPolicy
            ? toBindingStopPolicy(_sessionStopPolicy)
            : 2 /* binding.SyncSessionStopPolicy.AfterChangesUploaded */,
        customHttpHeaders,
        clientValidateSsl: ssl?.validate,
        sslTrustCertificatePath: ssl?.certificatePath,
        sslVerifyCallback: ssl?.validateCertificates
            ? Helpers.makeSslVerifyCallback(toSSLVerifyCallbackWithListArguments(ssl.validateCertificates))
            : undefined,
        ...parseClientResetConfig(clientReset, onError),
        cancelWaitsOnNonfatalError: cancelWaitsOnNonFatalError,
        proxyConfig: proxyConfig ? parseSyncProxyConfig(proxyConfig) : syncProxyConfig.create(),
    };
}
/** @internal */
function toSSLVerifyCallbackWithListArguments(verifyCallback) {
    return (serverAddress, serverPort, pemCertificate, preverifyOk, depth) => verifyCallback({ serverAddress, serverPort, pemCertificate, acceptedByOpenSSL: !!preverifyOk, depth });
}
/** @internal */
function parseClientResetConfig(clientReset, onError) {
    if (!clientReset) {
        return {
            clientResyncMode: undefined,
            notifyBeforeClientReset: undefined,
            notifyAfterClientReset: undefined,
            errorHandler: onError ? toBindingErrorHandler(onError) : undefined,
        };
    }
    switch (clientReset.mode) {
        case exports.ClientResetMode.Manual: {
            return parseManual(clientReset, onError);
        }
        case exports.ClientResetMode.DiscardUnsyncedChanges: {
            return {
                ...parseDiscardUnsyncedChanges(clientReset),
                errorHandler: onError ? toBindingErrorHandler(onError) : undefined,
            };
        }
        case exports.ClientResetMode.RecoverUnsyncedChanges: {
            return {
                ...parseRecoverUnsyncedChanges(clientReset),
                errorHandler: onError ? toBindingErrorHandler(onError) : undefined,
            };
        }
        case exports.ClientResetMode.RecoverOrDiscardUnsyncedChanges: {
            return {
                ...parseRecoverOrDiscardUnsyncedChanges(clientReset),
                errorHandler: onError ? toBindingErrorHandler(onError) : undefined,
            };
        }
    }
}
/** @internal */
function parseManual(clientReset, onError) {
    return {
        clientResyncMode: toBindingClientResetMode(clientReset.mode),
        errorHandler: toBindingErrorHandlerWithOnManual(onError, clientReset.onManual),
    };
}
/** @internal */
function parseDiscardUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: toBindingClientResetMode(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? toBindingNotifyBeforeClientReset(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter ? toBindingNotifyAfterClientReset(clientReset.onAfter) : undefined,
    };
}
/** @internal */
function parseRecoverUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: toBindingClientResetMode(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? toBindingNotifyBeforeClientReset(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter
            ? toBindingNotifyAfterClientResetWithFallback(clientReset.onAfter, clientReset.onFallback)
            : undefined,
    };
}
/** @internal */
function parseRecoverOrDiscardUnsyncedChanges(clientReset) {
    return {
        clientResyncMode: toBindingClientResetMode(clientReset.mode),
        notifyBeforeClientReset: clientReset.onBefore ? toBindingNotifyBeforeClientReset(clientReset.onBefore) : undefined,
        notifyAfterClientReset: clientReset.onAfter
            ? toBindingNotifyAfterClientResetWithFallback(clientReset.onAfter, clientReset.onFallback)
            : undefined,
    };
}
/** @internal */
function parseProxyType(proxyType) {
    switch (proxyType) {
        case exports.ProxyType.HTTP:
            return 0 /* binding.ProxyType.Http */;
        case exports.ProxyType.HTTPS:
            return 1 /* binding.ProxyType.Https */;
    }
}
/** @internal */
function parseSyncProxyConfig(syncProxyConfig) {
    return {
        ...syncProxyConfig,
        type: parseProxyType(syncProxyConfig.type),
    };
}
/**
 * Validate the fields of a user-provided realm sync configuration.
 * @internal
 */
function validateSyncConfiguration(config) {
    assert.object(config, "'sync' on realm configuration", { allowArrays: false });
    const { user, newRealmFileBehavior, existingRealmFileBehavior, onError, customHttpHeaders, ssl, clientReset, flexible, cancelWaitOnNonFatalError: cancelWaitsOnNonFatalError, } = config;
    assert.instanceOf(user, User, "'user' on realm sync configuration");
    if (cancelWaitsOnNonFatalError !== undefined) {
        assert.boolean(cancelWaitsOnNonFatalError, "'cancelWaitOnNonFatalError' on sync configuration");
    }
    if (newRealmFileBehavior !== undefined) {
        validateOpenRealmBehaviorConfiguration(newRealmFileBehavior, "newRealmFileBehavior");
    }
    if (existingRealmFileBehavior !== undefined) {
        validateOpenRealmBehaviorConfiguration(existingRealmFileBehavior, "existingRealmFileBehavior");
    }
    if (onError !== undefined) {
        assert.function(onError, "'onError' on realm sync configuration");
    }
    if (customHttpHeaders !== undefined) {
        assert.object(customHttpHeaders, "'customHttpHeaders' on realm sync configuration", { allowArrays: false });
        for (const key in customHttpHeaders) {
            assert.string(customHttpHeaders[key], "all property values of 'customHttpHeaders' on realm sync configuration");
        }
    }
    if (ssl !== undefined) {
        validateSSLConfiguration(ssl);
    }
    if (clientReset !== undefined) {
        validateClientResetConfiguration(clientReset);
    }
    // Assume the user intends to use Flexible Sync for all truthy values provided.
    if (flexible) {
        validateFlexibleSyncConfiguration(config);
    }
    else {
        validatePartitionSyncConfiguration(config);
    }
}
/**
 * Validate the fields of a user-provided open realm behavior configuration.
 */
function validateOpenRealmBehaviorConfiguration(config, target) {
    assert.object(config, `'${target}' on realm sync configuration`, { allowArrays: false });
    assert(config.type === exports.OpenRealmBehaviorType.DownloadBeforeOpen || config.type === exports.OpenRealmBehaviorType.OpenImmediately, `'${target}.type' on realm sync configuration must be either '${exports.OpenRealmBehaviorType.DownloadBeforeOpen}' or '${exports.OpenRealmBehaviorType.OpenImmediately}'.`);
    if (config.timeOut !== undefined) {
        assert.number(config.timeOut, `'${target}.timeOut' on realm sync configuration`);
    }
    if (config.timeOutBehavior !== undefined) {
        assert(config.timeOutBehavior === exports.OpenRealmTimeOutBehavior.OpenLocalRealm ||
            config.timeOutBehavior === exports.OpenRealmTimeOutBehavior.ThrowException, `'${target}.timeOutBehavior' on realm sync configuration must be either '${exports.OpenRealmTimeOutBehavior.OpenLocalRealm}' or '${exports.OpenRealmTimeOutBehavior.ThrowException}'.`);
    }
}
/**
 * Validate the fields of a user-provided SSL configuration.
 */
function validateSSLConfiguration(config) {
    assert.object(config, "'ssl' on realm sync configuration");
    if (config.validate !== undefined) {
        assert.boolean(config.validate, "'ssl.validate' on realm sync configuration");
    }
    if (config.certificatePath !== undefined) {
        assert.string(config.certificatePath, "'ssl.certificatePath' on realm sync configuration");
    }
    if (config.validateCertificates !== undefined) {
        assert.function(config.validateCertificates, "'ssl.validateCertificates' on realm sync configuration");
    }
}
/**
 * Validate the fields of a user-provided client reset configuration.
 */
function validateClientResetConfiguration(config) {
    assert.object(config, "'clientReset' on realm sync configuration", { allowArrays: false });
    const modes = Object.values(exports.ClientResetMode);
    assert(modes.includes(config.mode), `'clientReset' on realm sync configuration must be one of the following: '${modes.join("', '")}'`);
    if (config.onManual !== undefined) {
        assert.function(config.onManual, "'clientReset.onManual' on realm sync configuration");
    }
    if (config.onAfter !== undefined) {
        assert.function(config.onAfter, "'clientReset.onAfter' on realm sync configuration");
    }
    if (config.onBefore !== undefined) {
        assert.function(config.onBefore, "'clientReset.onBefore' on realm sync configuration");
    }
    if (config.onFallback !== undefined) {
        assert.function(config.onFallback, "'clientReset.onFallback' on realm sync configuration");
    }
}
/**
 * Validate the fields of a user-provided realm flexible sync configuration.
 */
function validateFlexibleSyncConfiguration(config) {
    const { flexible, partitionValue, initialSubscriptions } = config;
    assert(flexible === true, "'flexible' must always be true for realms using flexible sync. To enable partition-based sync, remove 'flexible' and specify 'partitionValue'.");
    if (initialSubscriptions !== undefined) {
        assert.object(initialSubscriptions, "'initialSubscriptions' on realm sync configuration", { allowArrays: false });
        assert.function(initialSubscriptions.update, "'initialSubscriptions.update' on realm sync configuration");
        if (initialSubscriptions.rerunOnOpen !== undefined) {
            assert.boolean(initialSubscriptions.rerunOnOpen, "'initialSubscriptions.rerunOnOpen' on realm sync configuration");
        }
    }
    assert(partitionValue === undefined, "'partitionValue' cannot be specified when flexible sync is enabled. To enable partition-based sync, remove 'flexible' and specify 'partitionValue'.");
}
/**
 * Validate the fields of a user-provided realm partition sync configuration.
 */
function validatePartitionSyncConfiguration(config) {
    const { flexible, partitionValue, initialSubscriptions } = config;
    validatePartitionValue(partitionValue);
    // We only allow `flexible` to be `true` (for Flexible Sync) or `undefined` (for Partition Sync).
    // `{ flexible: false }` is not allowed because TypeScript cannot discriminate that type correctly
    // with `strictNullChecks` disabled, and there is no real use case for `{ flexible: false }`.
    assert(flexible === undefined, "'flexible' can only be specified to enable flexible sync. To enable flexible sync, remove 'partitionValue' and set 'flexible' to true.");
    assert(initialSubscriptions === undefined, "'initialSubscriptions' can only be specified when flexible sync is enabled. To enable flexible sync, remove 'partitionValue' and set 'flexible' to true.");
}
/**
 * Validate the user-provided partition value of a realm sync configuration.
 */
function validatePartitionValue(value) {
    if (typeof value === "number") {
        assert(Number.isSafeInteger(value), `Expected 'partitionValue' on realm sync configuration to be an integer, got ${value}.`);
    }
    else {
        assert(typeof value === "string" || value instanceof bson.ObjectId || value instanceof bson.UUID || value === null, `Expected 'partitionValue' on realm sync configuration to be an integer, string, ObjectId, UUID, or null, got ${TypeAssertionError.deriveType(value)}.`);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Types of an authentication provider.
 */
exports.ProviderType = void 0;
(function (ProviderType) {
    ProviderType["AnonUser"] = "anon-user";
    ProviderType["ApiKey"] = "api-key";
    ProviderType["LocalUserPass"] = "local-userpass";
    ProviderType["CustomFunction"] = "custom-function";
    ProviderType["CustomToken"] = "custom-token";
    ProviderType["OAuth2Google"] = "oauth2-google";
    ProviderType["OAuth2Facebook"] = "oauth2-facebook";
    ProviderType["OAuth2Apple"] = "oauth2-apple";
})(exports.ProviderType || (exports.ProviderType = {}));
function isProviderType(arg) {
    return Object.values(exports.ProviderType).includes(arg);
}
class Credentials {
    /** @internal */
    internal;
    /** @internal */
    constructor(internal) {
        this.internal = internal;
    }
    /**
     * Creates credentials for an anonymous user. These can only be used once - using them a second
     * time will result in a different user being logged in. If you need to get a user that has already logged
     * in with the Anonymous credentials, use {@link App.currentUser} or {@link App.allUsers}.
     * @param reuse - Reuse any existing anonymous user already logged in.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://docs.mongodb.com/realm/authentication/anonymous/
     */
    static anonymous(reuse = true) {
        return new Credentials(AppCredentials.anonymous(reuse));
    }
    static emailPassword(arg1, password) {
        if (typeof arg1 === "string") {
            assert.string(password, "password");
            return new Credentials(AppCredentials.usernamePassword(arg1, password));
        }
        else {
            assert.string(arg1.email, "email");
            assert.string(arg1.password, "password");
            return new Credentials(AppCredentials.usernamePassword(arg1.email, arg1.password));
        }
    }
    /**
     * Creates credentials from an API key.
     * @param key - A string identifying the API key.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/api-key/
     */
    static apiKey(key) {
        return new Credentials(AppCredentials.apiKey(key));
    }
    /**
     * Creates credentials based on an Apple login.
     * @param token - An Apple authentication token, obtained by logging into Apple.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/apple/
     */
    static apple(token) {
        return new Credentials(AppCredentials.apple(token));
    }
    /**
     * Creates credentials based on a Facebook login.
     * @param token - A Facebook authentication token, obtained by logging into Facebook.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/facebook/
     */
    static facebook(token) {
        return new Credentials(AppCredentials.facebook(token));
    }
    static google({ authCode, idToken }) {
        let internal;
        if (authCode !== undefined) {
            assert(idToken === undefined, "Must not supply both an authCode or idToken field");
            internal = AppCredentials.googleAuth(GoogleAuthCode.make(authCode));
        }
        else {
            assert(idToken !== undefined, "Must supply either an authCode or idToken field");
            internal = AppCredentials.googleId(GoogleIdToken.make(idToken));
        }
        return new Credentials(internal);
    }
    /**
     * Creates credentials with a JSON Web Token (JWT) provider and user identifier.
     * @param token - A string identifying the user. Usually an identity token or a username.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/custom-jwt/
     */
    static jwt(token) {
        return new Credentials(AppCredentials.custom(token));
    }
    /**
     * Creates credentials with an Atlas App Services function and user identifier.
     * @param payload - An object identifying the user. Usually an identity token or a username.
     * @returns An instance of `Credentials` that can be used in {@link App.logIn}.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/custom-function/
     */
    static function(payload) {
        return new Credentials(AppCredentials.function(payload));
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * The state of a user.
 */
exports.UserState = void 0;
(function (UserState) {
    /**
     * Authenticated and available to communicate with services.
     * @deprecated Will be removed in v13. Please use {@link UserState.LoggedIn}
     */
    UserState["Active"] = "active";
    /** Authenticated and available to communicate with services. */
    UserState["LoggedIn"] = "LoggedIn";
    /** Logged out, but ready to be logged in. */
    UserState["LoggedOut"] = "LoggedOut";
    /** Removed from the app entirely. */
    UserState["Removed"] = "Removed";
})(exports.UserState || (exports.UserState = {}));
/**
 * Representation of an authenticated user of an {@link App}.
 */
class User {
    /** @internal */
    app;
    /** @internal */
    internal;
    // cached version of profile
    cachedProfile;
    listeners = new Listeners({
        add: (callback) => {
            return this.internal.subscribe(callback);
        },
        remove: (token) => {
            this.internal.unsubscribe(token);
        },
    });
    /** @internal */
    static get(internal, app) {
        // Update the static user reference to the current app
        if (app) {
            App.setAppByUser(internal, app);
        }
        // TODO: Use a WeakRef to memoize the SDK object
        return new User(internal, App.getAppByUser(internal));
    }
    /** @internal */
    constructor(internal, app) {
        this.internal = internal;
        this.app = app;
        this.cachedProfile = undefined;
    }
    /**
     * The automatically-generated internal ID of the user.
     * @returns The user ID as a string.
     */
    get id() {
        return this.internal.identity;
    }
    /**
     * The provider type used when authenticating the user.
     * @returns The provider type as an enumerated string.
     */
    get providerType() {
        const type = this.internal.providerType;
        if (isProviderType(type)) {
            return type;
        }
        else {
            throw new Error(`Unexpected provider type: ${type}`);
        }
    }
    /**
     * The ID of the device.
     * @returns The device ID as a string or `null`.
     */
    get deviceId() {
        return this.internal.deviceId;
    }
    /**
     * The state of the user.
     * @returns The state as an enumerated string.
     */
    get state() {
        const state = this.internal.state;
        switch (state) {
            case 1 /* binding.SyncUserState.LoggedIn */:
                return exports.UserState.LoggedIn;
            case 0 /* binding.SyncUserState.LoggedOut */:
                return exports.UserState.LoggedOut;
            case 2 /* binding.SyncUserState.Removed */:
                return exports.UserState.Removed;
            default:
                throw new Error(`Unsupported SyncUserState value: ${state}`);
        }
    }
    /**
     * The logged in state of the user.
     * @returns `true` if the user is logged in, `false` otherwise.
     */
    get isLoggedIn() {
        return this.internal.isLoggedIn;
    }
    /**
     * The identities of the user at any of the app's authentication providers.
     * @returns An array of {@link UserIdentity} objects.
     */
    get identities() {
        return this.internal.identities.map((identity) => {
            const { id, provider_type: providerType } = identity;
            return { id, providerType };
        });
    }
    /**
     * The access token used when requesting a new access token.
     * @returns The access token as a string or `null`.
     */
    get accessToken() {
        return this.internal.accessToken;
    }
    /**
     * The refresh token used when requesting a new access token.
     * @returns The refresh token as a string or `null`.
     */
    get refreshToken() {
        return this.internal.refreshToken;
    }
    /**
     * You can store arbitrary data about your application users in a MongoDB collection and configure
     * Atlas App Services to automatically expose each users data in a field of their user object.
     * For example, you might store a users preferred language, date of birth, or their local timezone.
     *
     * If this value has not been configured, it will be empty.
     * @returns The custom data as an object.
     */
    get customData() {
        const result = this.internal.customData;
        if (result === undefined) {
            return {};
        }
        return result;
    }
    /**
     * A profile containing additional information about the user.
     * @returns The user profile data as an object.
     */
    get profile() {
        if (!this.cachedProfile) {
            this.cachedProfile = this.internal.userProfile.data();
        }
        return this.cachedProfile;
    }
    /**
     * Use this to call functions defined by the Atlas App Services application, as this user.
     * @returns A {@link FunctionsFactory} that can be used to call the app's functions.
     */
    get functions() {
        return createFactory(this, undefined);
    }
    /**
     * Perform operations related to the API-key auth provider.
     * @returns An {@link ApiKeyAuth} object that can be used to manage API keys.
     */
    get apiKeys() {
        // TODO: Add memoization
        const internal = this.app.internal.userApiKeyProviderClient();
        return new ApiKeyAuth(this.internal, internal);
    }
    /**
     * Log out the user.
     * @returns A promise that resolves once the user has been logged out of the app.
     */
    async logOut() {
        await this.app.internal.logOutUser(this.internal);
    }
    /**
     * Link the user with an identity represented by another set of credentials.
     * @param credentials - The credentials to use when linking.
     * @returns A promise that resolves once the user has been linked with the credentials.
     */
    async linkCredentials(credentials) {
        await this.app.internal.linkUser(this.internal, credentials.internal);
    }
    /**
     * Call a remote Atlas App Services Function by its name.
     * @note Consider using `functions[name]()` instead of calling this method.
     * @param name - Name of the App Services Function.
     * @param args - Arguments passed to the Function.
     * @returns A promise that resolves to the value returned by the Function.
     * @example
     * // These are all equivalent:
     * await user.callFunction("doThing", a1, a2, a3);
     * await user.functions.doThing(a1, a2, a3);
     * await user.functions["doThing"](a1, a2, a3);
     * @example
     * // The methods returned from the functions object are bound, which is why it's okay to store the function in a variable before calling it:
     * const doThing = user.functions.doThing;
     * await doThing(a1);
     * await doThing(a2);
     */
    callFunction(name, ...args) {
        return this.callFunctionOnService(name, undefined, args);
    }
    /** @internal */
    callFunctionOnService(name, serviceName, ...args) {
        const cleanedArgs = cleanArguments(args);
        return this.app.internal.callFunction(this.internal, name, cleanedArgs, serviceName);
    }
    /** @internal */
    async callFunctionStreaming(functionName, serviceName, ...functionArgs) {
        const request = this.app.internal.makeStreamingRequest(this.internal, functionName, cleanArguments(functionArgs), serviceName);
        const response = await network.fetch(request);
        assert(response.ok, () => `Request failed: ${response.statusText} (${response.status})`);
        assert(response.body, "Expected a body in the response");
        return response.body;
    }
    /**
     * Refresh the access token and derive custom data from it.
     * @returns A promise that resolves to the refreshed custom data.
     */
    async refreshCustomData() {
        await this.app.internal.refreshCustomData(this.internal);
        return this.customData;
    }
    /**
     * Use the Push service to enable sending push messages to this user via Firebase Cloud Messaging (FCM).
     * @deprecated https://www.mongodb.com/docs/atlas/app-services/reference/push-notifications/
     * @returns A {@link PushClient} with methods to register and deregister the device on the user.
     */
    push(serviceName) {
        const internal = this.app.internal.pushNotificationClient(serviceName);
        return new PushClient(this.internal, internal);
    }
    /**
     * @param serviceName - The name of the MongoDB service to connect to.
     * @returns A client enabling access to a {@link MongoDB} service.
     * @example
     * let blueWidgets = user.mongoClient("myService")
     *                       .db("myDb")
     *                       .collection<Widget>("widgets")
     *                       .find({ color: "blue" });
     */
    mongoClient(serviceName) {
        assert.string(serviceName, "serviceName");
        assert(serviceName.length, "Please provide the name of the MongoDB service to connect to.");
        return {
            get serviceName() {
                return serviceName;
            },
            db: (databaseName) => {
                return {
                    get name() {
                        return databaseName;
                    },
                    collection: (collectionName) => {
                        return new MongoDBCollection(this, serviceName, databaseName, collectionName);
                    },
                };
            },
        };
    }
    /**
     * Adds a listener that will be fired on various user related events.
     * This includes auth token refresh, refresh token refresh, refresh custom user data, and logout.
     * @param callback - The callback to be fired when the event occurs.
     */
    addListener(callback) {
        this.listeners.add(callback);
    }
    /**
     * Removes an event listener previously added via {@link User.addListener}.
     * @param callback - The callback to be removed.
     */
    removeListener(callback) {
        this.listeners.remove(callback);
    }
    /**
     * Removes all event listeners previously added via {@link User.addListener}.
     */
    removeAllListeners() {
        this.listeners.removeAll();
    }
}

////////////////////////////////////////////////////////////////////////////
function flattenHeaders(headers) {
    const result = {};
    headers.forEach((value, key) => {
        result[key] = value;
    });
    return result;
}
/** @internal */
function createNetworkTransport() {
    return Helpers.makeNetworkTransport((request, callback) => {
        network.fetch(request).then(async (response) => {
            const headers = flattenHeaders(response.headers);
            const contentType = headers["content-type"];
            const body = contentType ? await response.text() : "";
            callback({
                customStatusCode: 0,
                httpStatusCode: response.status,
                headers,
                body,
            });
        }, (err) => {
            // Core will propagate any non-zero "custom status code" through to the caller
            // The error message is passed through the body
            const reason = err.message || "Unknown";
            const body = `request to ${request.url} failed, reason: ${reason}`;
            callback({ httpStatusCode: 0, headers: {}, customStatusCode: -1, body });
        });
    });
}

////////////////////////////////////////////////////////////////////////////
exports.ProgressDirection = void 0;
(function (ProgressDirection) {
    /**
     * Data going from the server to the client.
     */
    ProgressDirection["Download"] = "download";
    /**
     * Data going from the client to the server.
     */
    ProgressDirection["Upload"] = "upload";
})(exports.ProgressDirection || (exports.ProgressDirection = {}));
exports.ProgressMode = void 0;
(function (ProgressMode) {
    ProgressMode["ReportIndefinitely"] = "reportIndefinitely";
    ProgressMode["ForCurrentlyOutstandingWork"] = "forCurrentlyOutstandingWork";
})(exports.ProgressMode || (exports.ProgressMode = {}));
exports.ConnectionState = void 0;
(function (ConnectionState) {
    ConnectionState["Disconnected"] = "disconnected";
    ConnectionState["Connecting"] = "connecting";
    ConnectionState["Connected"] = "connected";
})(exports.ConnectionState || (exports.ConnectionState = {}));
exports.SessionState = void 0;
(function (SessionState) {
    /**
     * The sync session encountered a non-recoverable error and is permanently invalid. Create a new Session to continue syncing.
     */
    SessionState["Invalid"] = "invalid";
    /**
     * The sync session is actively communicating or attempting to communicate with Atlas App Services. A session may be considered active even if it is not currently connected. To find out if a session is online, check its connection state.
     */
    SessionState["Active"] = "active";
    /**
     * The sync session is not attempting to communicate with Atlas App Services due to the user logging out or synchronization being paused.
     */
    SessionState["Inactive"] = "inactive";
})(exports.SessionState || (exports.SessionState = {}));
function toBindingDirection(direction) {
    if (direction === exports.ProgressDirection.Download) {
        return 1 /* binding.ProgressDirection.Download */;
    }
    else if (direction === exports.ProgressDirection.Upload) {
        return 0 /* binding.ProgressDirection.Upload */;
    }
    else {
        throw new Error(`Unexpected direction: ${direction}`);
    }
}
function fromBindingConnectionState(state) {
    if (state === 2 /* binding.SyncSessionConnectionState.Connected */) {
        return exports.ConnectionState.Connected;
    }
    else if (state === 1 /* binding.SyncSessionConnectionState.Connecting */) {
        return exports.ConnectionState.Connecting;
    }
    else if (state === 0 /* binding.SyncSessionConnectionState.Disconnected */) {
        return exports.ConnectionState.Disconnected;
    }
    else {
        throw new Error(`Unexpected state: ${state}`);
    }
}
// TODO: This mapping is an interpretation of the behavior of the legacy SDK we might want to revisit
function fromBindingSessionState(state) {
    if (state === 2 /* binding.SyncSessionState.Inactive */) {
        return exports.SessionState.Inactive;
    }
    else {
        return exports.SessionState.Active;
    }
}
/** @internal */
function toBindingErrorHandler(onError) {
    return (sessionInternal, bindingError) => {
        // TODO: Return some cached sync session, instead of creating a new wrapper on every error
        // const session = App.Sync.getSyncSession(user, partitionValue);
        const session = new SyncSession(sessionInternal);
        const error = fromBindingSyncError(bindingError);
        onError(session, error);
    };
}
/** @internal */
function toBindingErrorHandlerWithOnManual(onError, onManual) {
    if (!onError && !onManual) {
        throw new Error("need to set either onError or onManual or both");
    }
    if (onError && onManual) {
        return toBindingErrorHandler((session, error) => {
            if (error instanceof ClientResetError) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                onManual(session, error.config.path);
            }
            else {
                onError(session, error);
            }
        });
    }
    if (onError) {
        // onError gets all errors
        return toBindingErrorHandler(onError);
    }
    if (onManual) {
        // onManual only gets ClientResetErrors
        return toBindingErrorHandler((session, error) => {
            if (error instanceof ClientResetError) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                onManual(session, error.config.path);
            }
        });
    }
}
/** @internal */
function toBindingNotifyBeforeClientReset(onBefore) {
    return (internal) => {
        onBefore(new Realm(null, { internal }));
    };
}
/** @internal */
function toBindingNotifyAfterClientReset(onAfter) {
    return (internal, tsr) => {
        onAfter(new Realm(null, { internal }), new Realm(null, { internal: Helpers.consumeThreadSafeReferenceToSharedRealm(tsr) }));
    };
}
/** @internal */
function toBindingNotifyAfterClientResetWithFallback(onAfter, onFallback) {
    return (internal, tsr, didRecover) => {
        if (didRecover) {
            onAfter(new Realm(null, { internal }), new Realm(null, { internal: Helpers.consumeThreadSafeReferenceToSharedRealm(tsr) }));
        }
        else {
            const realm = new Realm(null, { internal: Helpers.consumeThreadSafeReferenceToSharedRealm(tsr) });
            if (onFallback) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                onFallback(realm.syncSession, realm.path);
            }
            else {
                throw new Error("onFallback is undefined");
            }
        }
    };
}
/** @internal */
function toBindingStopPolicy(policy) {
    if (policy === exports.SessionStopPolicy.AfterUpload) {
        return 2 /* binding.SyncSessionStopPolicy.AfterChangesUploaded */;
    }
    else if (policy === exports.SessionStopPolicy.Immediately) {
        return 0 /* binding.SyncSessionStopPolicy.Immediately */;
    }
    else if (policy === exports.SessionStopPolicy.Never) {
        return 1 /* binding.SyncSessionStopPolicy.LiveIndefinitely */;
    }
    else {
        throw new Error(`Unexpected policy (get ${policy})`);
    }
}
/** @internal */
function toBindingClientResetMode(resetMode) {
    switch (resetMode) {
        case exports.ClientResetMode.Manual:
            return 0 /* binding.ClientResetMode.Manual */;
        case exports.ClientResetMode.DiscardUnsyncedChanges:
            return 1 /* binding.ClientResetMode.DiscardLocal */;
        case exports.ClientResetMode.RecoverUnsyncedChanges:
            return 2 /* binding.ClientResetMode.Recover */;
        case exports.ClientResetMode.RecoverOrDiscardUnsyncedChanges:
            return 3 /* binding.ClientResetMode.RecoverOrDiscard */;
    }
}
/**
 * With the current properties available through Core, it it's possible to construct an app from a user nor sync session internal.
 * TODO: Refactor to pass an app instance through to all places that constructs a SyncSession.
 */
const mockApp = new Proxy({}, {
    get() {
        throw new Error("Using user.app of a user returned through syncSession.config is not supported");
    },
});
/**
 * Progress listeners are shared across instances of the SyncSession, making it possible to deregister a listener on another session
 * TODO: Consider adding a check to verify that the callback is removed from the correct SyncSession (although that would break the API)
 */
const PROGRESS_LISTENERS = new Listeners({
    throwOnReAdd: true,
    add(callback, weakInternal, internal, direction, mode) {
        const token = internal.registerProgressNotifier((transferred, transferable) => callback(Number(transferred), Number(transferable)), toBindingDirection(direction), mode === exports.ProgressMode.ReportIndefinitely);
        return { weakInternal, token };
    },
    remove({ weakInternal, token }) {
        weakInternal.withDeref((internal) => internal?.unregisterProgressNotifier(token));
    },
});
/**
 * Connection listeners are shared across instances of the SyncSession, making it possible to deregister a listener on another session
 * TODO: Consider adding a check to verify that the callback is removed from the correct SyncSession (although that would break the API)
 */
const CONNECTION_LISTENERS = new Listeners({
    throwOnReAdd: true,
    add(callback, weakInternal, internal) {
        const token = internal.registerConnectionChangeCallback((oldState, newState) => callback(fromBindingConnectionState(newState), fromBindingConnectionState(oldState)));
        return { weakInternal, token };
    },
    remove({ weakInternal, token }) {
        weakInternal.withDeref((internal) => internal?.unregisterConnectionChangeCallback(token));
    },
});
class SyncSession {
    /** @internal */
    weakInternal;
    /** @internal */
    withInternal(cb) {
        return this.weakInternal.withDeref((syncSession) => {
            assert(syncSession, "This SyncSession is no longer valid");
            return cb(syncSession);
        });
    }
    /** @internal */
    constructor(internal) {
        this.weakInternal = internal.weaken();
    }
    // TODO: Return the `error_handler`
    // TODO: Figure out a way to avoid passing a mocked app instance when constructing the User.
    /**
     * Gets the Sync-part of the configuration that the corresponding Realm was constructed with.
     */
    get config() {
        return this.withInternal((internal) => {
            const user = new User(internal.user, mockApp);
            const { partitionValue, flxSyncRequested, customHttpHeaders, clientValidateSsl, sslTrustCertificatePath } = internal.config;
            if (flxSyncRequested) {
                return {
                    user,
                    flexible: true,
                    customHttpHeaders,
                    ssl: { validate: clientValidateSsl, certificatePath: sslTrustCertificatePath },
                };
            }
            else {
                return {
                    user,
                    partitionValue: bson.EJSON.parse(partitionValue),
                    customHttpHeaders,
                    ssl: { validate: clientValidateSsl, certificatePath: sslTrustCertificatePath },
                };
            }
        });
    }
    /**
     * Gets the current state of the session.
     */
    get state() {
        return fromBindingSessionState(this.withInternal((internal) => internal.state));
    }
    /**
     * Gets the URL of the Realm Object Server that this session is connected to.
     */
    get url() {
        const url = this.withInternal((internal) => internal.fullRealmUrl);
        if (url) {
            return url;
        }
        else {
            throw new Error("Unable to determine URL");
        }
    }
    /**
     * Gets the User that this session was created with.
     */
    get user() {
        return User.get(this.withInternal((internal) => internal.user));
    }
    /**
     * Gets the current state of the connection to the server. Multiple sessions might share the same underlying
     * connection. In that case, any connection change is sent to all sessions.
     *
     * Data will only be synchronized with the server if this method returns `Connected` and `state()` returns `Active` or `Dying`.
     */
    get connectionState() {
        return fromBindingConnectionState(this.withInternal((internal) => internal.connectionState));
    }
    // TODO: Make this a getter instead of a method
    /**
     * Returns `true` if the session is currently active and connected to the server, `false` if not.
     */
    isConnected() {
        return this.withInternal((internal) => {
            const { connectionState, state } = internal;
            return (connectionState === 2 /* binding.SyncSessionConnectionState.Connected */ &&
                (state === 0 /* binding.SyncSessionState.Active */ || state === 1 /* binding.SyncSessionState.Dying */));
        });
    }
    /**
     * Pause a sync session.
     *
     * This method is asynchronous so in order to know when the session has started you will need
     * to add a connection notification with {@link addConnectionNotification}.
     *
     * This method is idempotent so it will be a no-op if the session is already paused.
     */
    pause() {
        this.withInternal((internal) => internal.forceClose());
    }
    /**
     * Resumes a sync session that has been paused.
     *
     * This method is asynchronous so in order to know when the session has started you will need
     * to add a connection notification with {@link addConnectionNotification}.
     *
     * This method is idempotent so it will be a no-op if the session is already started.
     */
    resume() {
        this.withInternal((internal) => internal.reviveIfNeeded());
    }
    /**
     * Register a progress notification callback on a session object
     * @param direction - The progress direction to register for.
     * @param mode - The progress notification mode to use for the registration.
     * Can be either:
     *  - `reportIndefinitely` - the registration will stay active until the callback is unregistered
     *  - `forCurrentlyOutstandingWork` - the registration will be active until only the currently transferable bytes are synced
     * @param callback - Called with the following arguments:
     * 1. `transferred`: The current number of bytes already transferred
     * 2. `transferable`: The total number of transferable bytes (the number of bytes already transferred plus the number of bytes pending transfer)
     */
    addProgressNotification(direction, mode, callback) {
        this.withInternal((internal) => PROGRESS_LISTENERS.add(callback, this.weakInternal, internal, direction, mode));
    }
    /**
     * Unregister a progress notification callback that was previously registered with {@link addProgressNotification}.
     * Calling the function multiple times with the same callback is ignored.
     * @param callback - A previously registered progress callback.
     */
    removeProgressNotification(callback) {
        PROGRESS_LISTENERS.remove(callback);
    }
    /**
     * Registers a connection notification on the session object. This will be notified about changes to the
     * underlying connection to the Realm Object Server.
     * @param callback - Called with the following arguments:
     * 1. `newState`: The new state of the connection
     * 2. `oldState`: The state the connection transitioned from.
     */
    addConnectionNotification(callback) {
        this.withInternal((internal) => CONNECTION_LISTENERS.add(callback, this.weakInternal, internal));
    }
    /**
     * Unregister a state notification callback that was previously registered with addStateNotification.
     * Calling the function multiple times with the same callback is ignored.
     * @param callback - A previously registered state callback.
     */
    removeConnectionNotification(callback) {
        CONNECTION_LISTENERS.remove(callback);
    }
    /**
     * This method returns a promise that does not resolve successfully until all known remote changes have been
     * downloaded and applied to the Realm or the specified timeout is hit in which case it will be rejected. If the method
     * times out, the download will still continue in the background.
     *
     * This method cannot be called before the Realm has been opened.
     * @param timeoutMs - maximum amount of time to wait in milliseconds before the promise will be rejected. If no timeout
     * is specified the method will wait forever.
     */
    downloadAllServerChanges(timeoutMs) {
        return this.withInternal((internal) => new TimeoutPromise(internal.waitForDownloadCompletion(), {
            ms: timeoutMs,
            message: `Downloading changes did not complete in ${timeoutMs} ms.`,
        }));
    }
    /**
     * This method returns a promise that does not resolve successfully until all known local changes have been uploaded
     * to the server or the specified timeout is hit in which case it will be rejected. If the method times out, the upload
     * will still continue in the background.
     *
     * This method cannot be called before the Realm has been opened.
     * @param timeoutMs - Maximum amount of time to wait in milliseconds before the promise is rejected. If no timeout is specified the method will wait forever.
     */
    uploadAllLocalChanges(timeoutMs) {
        return this.withInternal((internal) => new TimeoutPromise(internal.waitForUploadCompletion(), {
            ms: timeoutMs,
            message: `Uploading changes did not complete in ${timeoutMs} ms.`,
        }));
    }
    /** @internal */
    _simulateError(code, message, type, isFatal) {
        this.withInternal((internal) => Helpers.simulateSyncError(internal, code, message, type, isFatal));
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Authentication provider where users identify using an API-key.
 */
class ApiKeyAuth {
    /** @internal */
    user;
    /** @internal */
    internal;
    /** @internal */
    constructor(user, internal) {
        this.user = user;
        this.internal = internal;
    }
    /**
     * Creates an API key that can be used to authenticate as the current user.
     * @param keyName the name of the API key to be created.
     */
    async create(keyName) {
        const { id, key, name, disabled } = await this.internal.createApiKey(keyName, this.user);
        assert.string(key);
        return { _id: id.toHexString(), key, name, disabled };
    }
    /**
     * Fetches an API key associated with the current user.
     * @param keyId the id of the API key to fetch.
     */
    async fetch(keyId) {
        const { id, name, disabled } = await this.internal.fetchApiKey(new exports.BSON.ObjectId(keyId), this.user);
        return { _id: id.toHexString(), name, disabled };
    }
    /**
     * Fetches the API keys associated with the current user.
     */
    async fetchAll() {
        const keys = await this.internal.fetchApiKeys(this.user);
        return keys.map(({ id, name, disabled }) => ({ _id: id.toHexString(), name, disabled }));
    }
    /**
     * Deletes an API key associated with the current user.
     * @param keyId the ID of the API key to delete
     */
    async delete(keyId) {
        await this.internal.deleteApiKey(new exports.BSON.ObjectId(keyId), this.user);
    }
    /**
     * Enables an API key associated with the current user.
     * @param keyId the ID of the API key to enable
     */
    async enable(keyId) {
        await this.internal.enableApiKey(new exports.BSON.ObjectId(keyId), this.user);
    }
    /**
     * Disable an API key associated with the current user.
     * @param keyId the ID of the API key to disable
     */
    async disable(keyId) {
        await this.internal.disableApiKey(new exports.BSON.ObjectId(keyId), this.user);
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Authentication provider where users identify using email and password.
 * @see https://www.mongodb.com/docs/atlas/app-services/authentication/email-password/
 */
class EmailPasswordAuth {
    /** @internal */
    internal;
    /** @internal */
    constructor(internal) {
        this.internal = internal;
    }
    /**
     * Registers a new email identity with the email/password provider,
     * and sends a confirmation email to the provided address.
     * @param details - The new user's email and password details.
     * @param details.email - The email address of the user to register.
     * @param details.password - The password that the user created for the new username/password identity.
     * @since v10.10.0
     */
    async registerUser(details) {
        await this.internal.registerEmail(details.email, details.password);
    }
    /**
     * Confirms an email identity with the email/password provider.
     * @param details - The received token and ID details
     * @param details.token - The confirmation token that was emailed to the user.
     * @param details.tokenId - The confirmation token id that was emailed to the user.
     * @since v10.10.0
     */
    async confirmUser(details) {
        await this.internal.confirmUser(details.token, details.tokenId);
    }
    /**
     * Re-sends a confirmation email to a user that has registered but
     * not yet confirmed their email address.
     * @param details - The associated email details.
     * @param details.email - The email address of the user to re-send a confirmation for.
     * @since v10.10.0
     */
    async resendConfirmationEmail(details) {
        await this.internal.resendConfirmationEmail(details.email);
    }
    /**
     * Re-run the custom confirmation function for user that has registered but
     * not yet confirmed their email address.
     * @param details - The associated email details.
     * @param details.email - The email address of the user to re-run the confirmation for.
     * @since v10.10.0
     */
    async retryCustomConfirmation(details) {
        await this.internal.retryCustomConfirmation(details.email);
    }
    /**
     * Resets the password of an email identity using the password reset token emailed to a user.
     * @param details - The token and password details for the reset.
     * @param details.password - The desired new password.
     * @param details.token - The password reset token that was emailed to the user.
     * @param details.tokenId - The password reset token id that was emailed to the user.
     * @since v10.10.0
     */
    async resetPassword(details) {
        await this.internal.resetPassword(details.password, details.token, details.tokenId);
    }
    /**
     * Sends an email to the user for resetting the password.
     * @param details - The email details to send the reset to.
     * @param details.email - The email address of the user to re-send a confirmation for.
     * @since v10.10.0
     */
    async sendResetPasswordEmail(details) {
        await this.internal.sendResetPasswordEmail(details.email);
    }
    /**
     * Call the custom function to reset the password.
     * @param details - The new user's email and password details.
     * @param details.email - The email address of the user to register.
     * @param details.password - The password that the user created for the new username/password identity.
     * @param args One or more arguments to pass to the function.
     * @since v10.10.0
     */
    async callResetPasswordFunction(details, ...args) {
        await this.internal.callResetPasswordFunction(details.email, details.password, args);
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Authentication provider where users identify using an API-key.
 */
class PushClient {
    /** @internal */
    user;
    /** @internal */
    internal;
    /** @internal */
    constructor(user, internal) {
        this.user = user;
        this.internal = internal;
    }
    /**
     * Register this device with the user.
     * @param token - A Firebase Cloud Messaging (FCM) token, retrieved via the firebase SDK.
     * @returns A promise that resolves once the device has been registered.
     */
    async register(token) {
        await this.internal.registerDevice(token, this.user);
    }
    /**
     * Deregister this device with the user, to disable sending messages to this device.
     * @returns A promise that resolves once the device has been deregistered.
     */
    async deregister() {
        await this.internal.deregisterDevice(this.user);
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * A remote collection of documents in a MongoDB database.
 */
class MongoDBCollection {
    user;
    serviceName;
    databaseName;
    collectionName;
    functions;
    /** @internal */
    constructor(
    /** @internal */ user, serviceName, databaseName, collectionName) {
        this.user = user;
        this.serviceName = serviceName;
        this.databaseName = databaseName;
        this.collectionName = collectionName;
        this.functions = createFactory(user, serviceName);
    }
    /**
     * The name of the collection.
     */
    get name() {
        return this.collectionName;
    }
    /**
     * Finds the documents which match the provided query.
     * @param filter - An optional filter applied to narrow down the results.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found documents.
     */
    find(filter = {}, options = {}) {
        return this.functions.find({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            project: options.projection,
            sort: options.sort,
            limit: options.limit,
        });
    }
    /**
     * Finds a document which matches the provided filter.
     * @param filter - A filter applied to narrow down the result.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document.
     */
    findOne(filter = {}, options = {}) {
        return this.functions.findOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            project: options.projection,
            sort: options.sort,
        });
    }
    /**
     * Finds a document which matches the provided query and performs the desired update to individual fields.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document before applying the update.
     */
    findOneAndUpdate(filter, update, options = {}) {
        return this.functions.findOneAndUpdate({
            database: this.databaseName,
            collection: this.name,
            filter,
            update,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /**
     * Finds a document which matches the provided filter and replaces it with a new document.
     * @param filter - A filter applied to narrow down the result.
     * @param replacement - The new replacing document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document found before replacement.
     */
    findOneAndReplace(filter, replacement, options = {}) {
        return this.functions.findOneAndReplace({
            database: this.databaseName,
            collection: this.name,
            filter: filter,
            update: replacement,
            sort: options.sort,
            projection: options.projection,
            upsert: options.upsert,
            returnNewDocument: options.returnNewDocument,
        });
    }
    /**
     * Finds a document which matches the provided filter and deletes it
     * @param filter - A filter applied to narrow down the result.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the found document before deletion.
     */
    findOneAndDelete(filter = {}, options = {}) {
        return this.functions.findOneAndDelete({
            database: this.databaseName,
            collection: this.name,
            filter,
            sort: options.sort,
            projection: options.projection,
        });
    }
    /**
     * Runs an aggregation framework pipeline against this collection.
     * @param pipeline - An array of aggregation pipeline stages.
     * @returns A promise that resolves to the aggregation result.
     */
    aggregate(pipeline) {
        return this.functions.aggregate({
            database: this.databaseName,
            collection: this.name,
            pipeline,
        });
    }
    /**
     * Counts the number of documents in this collection matching the provided filter.
     *
     * Note: When calling this without a filter, you may receive inaccurate document counts
     * as it returns results based on the collection's metadata, which may result in an
     * approximate count. In particular:
     *  - On a sharded cluster, the resulting count will not correctly filter out
     *    {@link https://www.mongodb.com/docs/manual/reference/glossary/#std-term-orphaned-document orphaned documents}.
     *  - After an unclean shutdown or file copy based initial sync, the count may be incorrect.
     * @param filter - An optional filter applied to narrow down the results.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to the number of documents matching the filter.
     */
    count(filter = {}, options = {}) {
        return this.functions.count({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            limit: options.limit,
        });
    }
    /**
     * Inserts a single document into the collection.
     * Note: If the document is missing an _id, one will be generated for it by the server.
     * @param document - The document to insert.
     * @returns A promise that resolves an object containing the inserted object ID (`insertedId`).
     */
    insertOne(document) {
        return this.functions.insertOne({
            database: this.databaseName,
            collection: this.name,
            document,
        });
    }
    /**
     * Inserts an array of documents into the collection.
     * If any values are missing identifiers, they will be generated by the server.
     * @param documents - The array of documents to insert.
     * @returns A promise that resolves to an object containing an array of IDs inserted (`insertedIds`).
     */
    insertMany(documents) {
        return this.functions.insertMany({
            database: this.databaseName,
            collection: this.name,
            documents,
        });
    }
    /**
     * Deletes a single matching document from the collection.
     * @param filter - A filter applied to narrow down the result.
     * @returns A promise that resolves to an object containing the number of deleted documents (`deletedCount`).
     */
    deleteOne(filter = {}) {
        return this.functions.deleteOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
        });
    }
    /**
     * Deletes multiple documents.
     * @param filter - A filter applied to narrow down the result. If omitted, it defaults
     *  to `{}` which deletes all documents in the collection.
     * @returns A promise that resolves to an object containing the number of deleted documents (`deletedCount`).
     */
    deleteMany(filter = {}) {
        return this.functions.deleteMany({
            database: this.databaseName,
            collection: this.name,
            query: filter,
        });
    }
    /**
     * Updates a single document matching the provided filter in this collection.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the document.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to an object containing:
     * ```
     * {
     *  matchedCount: number;
     *  modifiedCount: number;
     *  upsertedId: IdType | undefined;
     * }
     * ```
     */
    updateOne(filter, update, options = {}) {
        return this.functions.updateOne({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            update,
            upsert: options.upsert,
            arrayFilters: options.arrayFilters,
        });
    }
    /**
     * Updates multiple documents matching the provided filter in this collection.
     * @param filter - A filter applied to narrow down the result.
     * @param update - The new values for the documents.
     * @param options - Additional options to apply.
     * @returns A promise that resolves to an object containing:
     * ```
     * {
     *  matchedCount: number;
     *  modifiedCount: number;
     *  upsertedId: IdType | undefined;
     * }
     * ```
     */
    updateMany(filter, update, options = {}) {
        return this.functions.updateMany({
            database: this.databaseName,
            collection: this.name,
            query: filter,
            update,
            upsert: options.upsert,
            arrayFilters: options.arrayFilters,
        });
    }
    async *watch({ ids, filter, } = {}) {
        const iterator = await this.user.callFunctionStreaming("watch", this.serviceName, {
            database: this.databaseName,
            collection: this.collectionName,
            ids,
            filter,
        });
        const watchStream = WatchStream.make();
        for await (const chunk of iterator) {
            if (!chunk)
                continue;
            // TODO: Remove `toArrayBuffer()` once https://jira.mongodb.org/browse/RJS-2124 gets solved
            const buffer = toArrayBuffer(chunk);
            Helpers.feedBuffer(watchStream, buffer);
            while (watchStream.state === 1 /* binding.WatchStreamState.HaveEvent */) {
                yield watchStream.nextEvent();
            }
            if (watchStream.state === 2 /* binding.WatchStreamState.HaveError */) {
                throw watchStream.error;
            }
        }
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
function createFactory(user, serviceName) {
    return new Proxy({}, {
        get(target, name, receiver) {
            if (typeof name === "string" && name != "inspect") {
                return user.callFunctionOnService.bind(user, name, serviceName);
            }
            else {
                return Reflect.get(target, name, receiver);
            }
        },
    });
}

////////////////////////////////////////////////////////////////////////////
/**
 * Enum representing the state of a {@link SubscriptionSet}.
 */
exports.SubscriptionSetState = void 0;
(function (SubscriptionSetState) {
    /**
     * The subscription update has been persisted locally, but the server hasn't
     * yet returned all the data that matched the updated subscription queries.
     */
    SubscriptionSetState["Pending"] = "pending";
    /**
     * The server has acknowledged the subscription and sent all the data that
     * matched the subscription queries at the time the SubscriptionSet was
     * updated. The server is now in steady-state synchronization mode where it
     * will stream updates as they come.
     */
    SubscriptionSetState["Complete"] = "complete";
    /**
     * The server has returned an error and synchronization is paused for this
     * Realm. To view the actual error, use `Subscriptions.error`.
     *
     * You can still use {@link SubscriptionSet.update} to update the subscriptions,
     * and if the new update doesn't trigger an error, synchronization will be restarted.
     */
    SubscriptionSetState["Error"] = "error";
    /**
     * The SubscriptionSet has been superseded by an updated one. This typically means
     * that someone has called {@link SubscriptionSet.update} on a different instance
     * of the {@link SubscriptionSet}. You should not use a superseded SubscriptionSet,
     * and instead obtain a new instance from {@link Realm.subscriptions}.
     */
    SubscriptionSetState["Superseded"] = "superseded";
})(exports.SubscriptionSetState || (exports.SubscriptionSetState = {}));
/**
 * @deprecated Will be removed in v13.0.0. Please use {@link SubscriptionSetState}.
 */
exports.SubscriptionsState = void 0;
(function (SubscriptionsState) {
    /**
     * The subscription update has been persisted locally, but the server hasn't
     * yet returned all the data that matched the updated subscription queries.
     */
    SubscriptionsState["Pending"] = "pending";
    /**
     * The server has acknowledged the subscription and sent all the data that
     * matched the subscription queries at the time the SubscriptionSet was
     * updated. The server is now in steady-state synchronization mode where it
     * will stream updates as they come.
     */
    SubscriptionsState["Complete"] = "complete";
    /**
     * The server has returned an error and synchronization is paused for this
     * Realm. To view the actual error, use `Subscriptions.error`.
     *
     * You can still use {@link SubscriptionSet.update} to update the subscriptions,
     * and if the new update doesn't trigger an error, synchronization will be restarted.
     */
    SubscriptionsState["Error"] = "error";
    /**
     * The SubscriptionSet has been superseded by an updated one. This typically means
     * that someone has called {@link SubscriptionSet.update} on a different instance
     * of the {@link SubscriptionSet}. You should not use a superseded SubscriptionSet,
     * and instead obtain a new instance from {@link Realm.subscriptions}.
     */
    SubscriptionsState["Superseded"] = "superseded";
})(exports.SubscriptionsState || (exports.SubscriptionsState = {}));
const DEFAULT_PROPERTY_DESCRIPTOR = { configurable: true, enumerable: true, writable: false };
const PROXY_HANDLER = {
    ownKeys(target) {
        return Reflect.ownKeys(target).concat([...target.keys()].map(String));
    },
    getOwnPropertyDescriptor(target, prop) {
        if (Reflect.has(target, prop)) {
            return Reflect.getOwnPropertyDescriptor(target, prop);
        }
        if (typeof prop === "string") {
            const BASE = 10;
            const index = Number.parseInt(prop, BASE);
            if (index >= 0 && index < target.length) {
                return DEFAULT_PROPERTY_DESCRIPTOR;
            }
        }
    },
    // Not defining `set()` here will make e.g. `mySubscriptions[0] = someValue` a no-op
    // if strict mode (`"use strict"`) is used, or throw a TypeError if it is not used.
};
/**
 * Class representing the common functionality for the {@link SubscriptionSet} and
 * {@link MutableSubscriptionSet} classes.
 *
 * SubscriptionSets can only be modified inside a {@link SubscriptionSet.update} callback.
 *
 * The SubscriptionSet is an iterable; thus, the contained {@link Subscription}s can be
 * accessed in `for-of` loops or spread into an `Array` for access to the ECMAScript
 * Array API, e.g. `[...realm.subscriptions][0]`.
 */
class BaseSubscriptionSet {
    internal;
    /** @internal */
    constructor(/** @internal */ internal) {
        this.internal = internal;
        Object.defineProperty(this, "internal", {
            enumerable: false,
            configurable: false,
            // `internal` needs to be writable due to `SubscriptionSet.updateNoWait()`
            // overwriting `this.internal` with the new committed set.
            writable: true,
        });
        return new Proxy(this, PROXY_HANDLER);
    }
    /**
     * Whether there are no subscriptions in the set.
     * @returns `true` if there are no subscriptions in the set, `false` otherwise.
     */
    get isEmpty() {
        return this.internal.size === 0;
    }
    /**
     * The version of the SubscriptionSet. This is incremented every time a
     * {@link SubscriptionSet.update} is applied.
     * @returns The version of the {@link SubscriptionSet}.
     */
    get version() {
        return Number(this.internal.version);
    }
    /**
     * @returns The state of the SubscriptionSet.
     */
    get state() {
        const state = this.internal.state;
        switch (state) {
            case 0 /* binding.SyncSubscriptionSetState.Uncommitted */:
            case 1 /* binding.SyncSubscriptionSetState.Pending */:
            case 2 /* binding.SyncSubscriptionSetState.Bootstrapping */:
            case 6 /* binding.SyncSubscriptionSetState.AwaitingMark */:
                return exports.SubscriptionSetState.Pending;
            case 3 /* binding.SyncSubscriptionSetState.Complete */:
                return exports.SubscriptionSetState.Complete;
            case 4 /* binding.SyncSubscriptionSetState.Error */:
                return exports.SubscriptionSetState.Error;
            case 5 /* binding.SyncSubscriptionSetState.Superseded */:
                return exports.SubscriptionSetState.Superseded;
            default:
                throw new Error(`Unsupported SubscriptionSetState value: ${state}`);
        }
    }
    /**
     * If `state` is {@link SubscriptionSetState.Error}, this will be a string representing
     * why the {@link SubscriptionSet} is in an error state. It will be `null` if there is no error.
     * @returns A string representing the error, or `null` if there is no error.
     */
    get error() {
        return this.state === exports.SubscriptionSetState.Error ? this.internal.errorStr : null;
    }
    /**
     * @returns The number of subscriptions in the set.
     */
    get length() {
        return this.internal.size;
    }
    /**
     * Find a subscription by name.
     * @param name - The name to search for.
     * @returns The named subscription, or `null` if the subscription is not found.
     */
    findByName(name) {
        assert.string(name, "name");
        const subscription = this.internal.findByName(name);
        return subscription ? new Subscription(subscription) : null;
    }
    /**
     * Find a subscription by query. Will match both named and unnamed subscriptions.
     * @param query - The query to search for, represented as a {@link Results} instance,
     *  e.g. `Realm.objects("Cat").filtered("age > 10")`.
     * @returns The subscription with the specified query, or `null` if the subscription is not found.
     */
    findByQuery(query) {
        assert.instanceOf(query, Results, "query");
        const subscription = this.internal.findByQuery(query.internal.query);
        return subscription ? new Subscription(subscription) : null; // TODO: Remove the type assertion into Subscription
    }
    /** @internal */
    exists(query) {
        if (query.subscriptionName === undefined) {
            return !!this.internal.findByQuery(query.internal.query);
        }
        return !!this.internal.findByName(query.subscriptionName);
    }
    /**
     * Makes the subscription set iterable.
     * @returns Iterable of each value in the set.
     * @example
     * for (const subscription of subscriptions) {
     *   // ...
     * }
     */
    *[Symbol.iterator]() {
        for (const subscription of this.internal) {
            yield new Subscription(subscription);
        }
    }
    /**
     * Get an iterator that contains each index in the subscription set.
     * @internal
     */
    *keys() {
        const size = this.length;
        for (let i = 0; i < size; i++) {
            yield i;
        }
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Behavior when waiting for subscribed objects to be synchronized/downloaded.
 */
exports.WaitForSync = void 0;
(function (WaitForSync) {
    /**
     * Waits until the objects have been downloaded from the server
     * the first time the subscription is created. If the subscription
     * already exists, the `Results` is returned immediately.
     */
    WaitForSync["FirstTime"] = "first-time";
    /**
     * Always waits until the objects have been downloaded from the server.
     */
    WaitForSync["Always"] = "always";
    /**
     * Never waits for the download to complete, but keeps downloading the
     * objects in the background.
     */
    WaitForSync["Never"] = "never";
})(exports.WaitForSync || (exports.WaitForSync = {}));
/**
 * The mutable version of a given SubscriptionSet. The {@link MutableSubscriptionSet}
 * instance can only be used from inside the {@link SubscriptionSet.update} callback.
 */
class MutableSubscriptionSet extends BaseSubscriptionSet {
    /** @internal */
    constructor(/** @internal */ internal) {
        super(internal);
    }
    /**
     * Add a query to the set of active subscriptions. The query will be joined via
     * an `OR` operator with any existing queries for the same type.
     *
     * A query is represented by a {@link Results} instance returned from {@link Realm.objects},
     * for example: `mutableSubs.add(realm.objects("Cat").filtered("age > 10"));`.
     * @param query - A {@link Results} instance representing the query to subscribe to.
     * @param options - An optional {@link SubscriptionOptions} object containing options to
     * use when adding this subscription (e.g. to give the subscription a name).
     * @returns A `Subscription` instance for the new subscription.
     */
    add(query, options) {
        assert.instanceOf(query, Results, "query");
        if (options) {
            validateSubscriptionOptions(options);
        }
        const subscriptions = this.internal;
        const results = query.internal;
        const queryInternal = results.query;
        if (options?.throwOnUpdate && options.name !== undefined) {
            const existingSubscription = subscriptions.findByName(options.name);
            if (existingSubscription) {
                const isSameQuery = existingSubscription.queryString === queryInternal.description &&
                    existingSubscription.objectClassName === results.objectType;
                assert(isSameQuery, `A subscription with the name '${options.name}' already exists but has a different query. If you meant to update it, remove 'throwOnUpdate: true' from the subscription options.`);
            }
        }
        const [subscription] = 
        // Check for `undefined` rather than falsy since we treat empty names as named.
        options?.name === undefined
            ? subscriptions.insertOrAssignByQuery(queryInternal)
            : subscriptions.insertOrAssignByName(options.name, queryInternal);
        query.subscriptionName = subscription.name;
        return new Subscription(subscription);
    }
    /**
     * Remove a subscription with the given query from the SubscriptionSet.
     * @param query - A {@link Results} instance representing the query to remove a subscription to.
     * @returns `true` if the subscription was removed, `false` if it was not found.
     */
    remove(query) {
        assert.instanceOf(query, Results, "query");
        return this.internal.eraseByQuery(query.internal.query);
    }
    /**
     * Remove a subscription with the given name from the SubscriptionSet.
     * @param name - The name of the subscription to remove.
     * @returns `true` if the subscription was removed, `false` if it was not found.
     */
    removeByName(name) {
        assert.string(name, "name");
        return this.internal.eraseByName(name);
    }
    /**
     * Remove the specified subscription from the SubscriptionSet.
     * @param subscription - The {@link Subscription} instance to remove.
     * @returns `true` if the subscription was removed, `false` if it was not found.
     */
    removeSubscription(subscription) {
        assert.instanceOf(subscription, Subscription, "subscription");
        return Helpers.eraseSubscription(this.internal, subscription.internal);
    }
    /**
     * Remove all subscriptions for the specified object type from the SubscriptionSet.
     * @param objectType - The string name of the object type to remove all subscriptions for.
     * @returns The number of subscriptions removed.
     */
    removeByObjectType(objectType) {
        assert.string(objectType, "objectType");
        return this.removeByPredicate((subscription) => subscription.objectClassName === objectType);
    }
    /**
     * Remove all subscriptions from the SubscriptionSet.
     * @returns The number of subscriptions removed.
     */
    removeAll() {
        const numRemoved = this.internal.size;
        this.internal.clear();
        return numRemoved;
    }
    /**
     * Remove all unnamed/anonymous subscriptions from the SubscriptionSet.
     * @returns The number of subscriptions removed.
     */
    removeUnnamed() {
        return this.removeByPredicate((subscription) => subscription.name === undefined);
    }
    /** @internal */
    removeByPredicate(predicate) {
        // TODO: This is currently O(n^2) because each erase call is O(n). Once Core has
        //       fixed https://github.com/realm/realm-core/issues/6241, we can update this.
        // Removing the subscription (calling `eraseSubscription()`) invalidates all current
        // iterators, so it would be illegal to continue iterating. Instead, we push it to an
        // array to remove later.
        const subscriptionsToRemove = [];
        for (const subscription of this.internal) {
            if (predicate(subscription)) {
                subscriptionsToRemove.push(subscription);
            }
        }
        let numRemoved = 0;
        for (const subscription of subscriptionsToRemove) {
            const isRemoved = Helpers.eraseSubscription(this.internal, subscription);
            if (isRemoved) {
                numRemoved++;
            }
        }
        return numRemoved;
    }
}
function validateSubscriptionOptions(input) {
    assert.object(input, "options", { allowArrays: false });
    if (input.name !== undefined) {
        assert.string(input.name, "'name' on 'SubscriptionOptions'");
    }
    if (input.throwOnUpdate !== undefined) {
        assert.boolean(input.throwOnUpdate, "'throwOnUpdate' on 'SubscriptionOptions'");
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Represents the set of all active flexible sync subscriptions for a Realm instance.
 *
 * The server will continuously evaluate the queries that the instance is subscribed to
 * and will send data that matches them, as well as remove data that no longer does.
 *
 * The set of subscriptions can only be modified inside a {@link SubscriptionSet.update} callback,
 * by calling methods on the corresponding {@link MutableSubscriptionSet} instance.
 */
class SubscriptionSet extends BaseSubscriptionSet {
    realm;
    /** @internal */
    constructor(/** @internal */ realm, internal) {
        super(internal);
        this.realm = realm;
        Object.defineProperty(this, "realm", {
            enumerable: false,
            configurable: false,
            writable: false,
        });
    }
    /**
     * Wait for the server to acknowledge this set of subscriptions and return the
     * matching objects.
     *
     * If `state` is {@link SubscriptionSetState.Complete}, the promise will be resolved immediately.
     *
     * If `state` is {@link SubscriptionSetState.Error}, the promise will be rejected immediately.
     * @returns A promise which is resolved when synchronization is complete, or is
     *  rejected if there is an error during synchronization.
     */
    async waitForSynchronization() {
        try {
            const state = await this.internal.getStateChangeNotification(3 /* binding.SyncSubscriptionSetState.Complete */);
            if (state === 4 /* binding.SyncSubscriptionSetState.Error */) {
                throw new Error(this.error || "Encountered an error when waiting for synchronization.");
            }
        }
        finally {
            if (!this.realm.isClosed) {
                this.internal.refresh();
            }
        }
    }
    /**
     * Call this to make changes to this SubscriptionSet from inside the callback,
     * such as adding or removing subscriptions from the set.
     *
     * The MutableSubscriptionSet argument can only be used from the callback and must
     * not be used after it returns.
     *
     * All changes done by the callback will be batched and sent to the server. You can either
     * `await` the call to `update`, or call {@link SubscriptionSet.waitForSynchronization}
     * to wait for the new data to be available.
     * @param callback A callback function which receives a {@link MutableSubscriptionSet}
     *  instance as the first argument, which can be used to add or remove subscriptions
     *  from the set, and the {@link Realm} associated with the SubscriptionSet as the
     *  second argument (mainly useful when working with `initialSubscriptions` in
     *  {@link FlexibleSyncConfiguration}).
     * @returns A promise which resolves when the SubscriptionSet is synchronized, or is rejected
     *  if there was an error during synchronization (see {@link SubscriptionSet.waitForSynchronization})
     * @example
     * await realm.subscriptions.update(mutableSubscriptions => {
     *   mutableSubscriptions.add(realm.objects("Cat").filtered("age > 10"));
     *   mutableSubscriptions.add(realm.objects("Dog").filtered("age > 20"), { name: "oldDogs" });
     *   mutableSubscriptions.removeByName("youngDogs");
     * });
     * // `realm` will now return the expected results based on the updated subscriptions
     */
    async update(callback) {
        this.updateNoWait(callback);
        await this.waitForSynchronization();
    }
    /** @internal */
    updateNoWait(callback) {
        assert.function(callback, "callback");
        // Create a mutable copy of this instance (which copies the original and upgrades
        // its internal transaction to a write transaction) so that we can make updates to it.
        const mutableSubscriptions = this.internal.makeMutableCopy();
        callback(new MutableSubscriptionSet(mutableSubscriptions), this.realm);
        // Commit the mutation, which downgrades its internal transaction to a read transaction
        // so no more changes can be made to it, and returns a new (immutable) SubscriptionSet
        // with the changes we made. Then update this SubscriptionSet instance to point to the
        // updated version.
        this.internal = mutableSubscriptions.commit();
    }
}

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2023 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
/**
 * Class representing a single query subscription in a set of flexible sync
 * {@link SubscriptionSet}. This class contains readonly information about the
 * subscription  any changes to the set of subscriptions must be carried out
 * in a {@link SubscriptionSet.update} callback.
 */
class Subscription {
    internal;
    /** @internal */
    constructor(/** @internal */ internal) {
        this.internal = internal;
        this.internal = internal;
    }
    /**
     * The ObjectId of the subscription.
     * @returns The ObjectId of the subscription.
     */
    get id() {
        return this.internal.id;
    }
    /**
     * The date when this subscription was created.
     * @returns The date when this subscription was created.
     */
    get createdAt() {
        return this.internal.createdAt.toDate();
    }
    /**
     * The date when this subscription was last updated.
     * @returns The date when this subscription was last updated.
     */
    get updatedAt() {
        return this.internal.updatedAt.toDate();
    }
    /**
     * The name given to this subscription when it was created.
     * If no name was set, this will be `null`.
     * @returns The name of the subscription or `null` if unnamed.
     */
    get name() {
        const result = this.internal.name;
        return result === undefined ? null : result;
    }
    /**
     * The type of objects the subscription refers to.
     * @returns The type of objects the subscription refers to.
     */
    get objectType() {
        return this.internal.objectClassName;
    }
    /**
     * The string representation of the query the subscription was created with.
     * If no filter or sort was specified, this will be `"TRUEPREDICATE"`.
     * @returns The string representation of the query the subscription was created with.
     */
    get queryString() {
        return this.internal.queryString;
    }
}

////////////////////////////////////////////////////////////////////////////
class Sync {
    static Session = SyncSession;
    static ConnectionState = exports.ConnectionState;
    static Subscription = Subscription;
    static SubscriptionSet = SubscriptionSet;
    static MutableSubscriptionSet = MutableSubscriptionSet;
    static SubscriptionSetState = exports.SubscriptionSetState;
    /** @deprecated Please use {@link SubscriptionSetState} as a named import */
    static SubscriptionsState = exports.SubscriptionSetState;
    static NumericLogLevel = exports.NumericLogLevel;
    /** @deprecated Will be removed in v13.0.0. Please use {@link Realm.setLogLevel}. */
    static setLogLevel(app, level) {
        const numericLevel = toBindingLoggerLevel(level);
        app.internal.syncManager.setLogLevel(numericLevel);
    }
    /** @deprecated Will be removed in v13.0.0. Please use {@link Realm.setLogger}. */
    static setLogger(app, logger) {
        const factory = Helpers.makeLoggerFactory((level, message) => {
            logger(fromBindingLoggerLevelToNumericLogLevel(level), message);
        });
        app.internal.syncManager.setLoggerFactory(factory);
    }
    /**
     * Get all sync sessions for a particular user.
     * @since 10.0.0
     */
    static getAllSyncSessions(user) {
        return user.internal.allSessions.map((session) => new SyncSession(session));
    }
    /**
     * Get the session associated with a particular user and partition value.
     * @since 10.0.0
     */
    static getSyncSession(user, partitionValue) {
        validateSyncConfiguration({ user, partitionValue });
        const config = toBindingSyncConfig({ user, partitionValue });
        const path = user.app.internal.syncManager.pathForRealm(config, undefined);
        const session = user.internal.sessionForOnDiskPath(path);
        if (session) {
            return new SyncSession(session);
        }
        else {
            return null;
        }
    }
    // TODO: Consider breaking the API, turning this into a property
    /**
     * Set the application part of the User-Agent string that will be sent to the Realm Object Server when a session
     * is created.
     *
     * This method can only be called up to the point where the first Realm is opened. After that, the User-Agent
     * can no longer be changed.
     */
    static setUserAgent(app, userAgent) {
        app.internal.syncManager.setUserAgent(userAgent);
    }
    // TODO: Consider breaking the API, turning this into an instance method
    /**
     * Enable multiplexing multiple sync sessions over a single connection for a Realm app.
     * When having a lot of synchronized realms open the system might run out of file
     * descriptors because of all the open sockets to the server. Session multiplexing
     * is designed to alleviate that, but it might not work with a server configured with
     * fail-over. Only use if you're seeing errors about reaching the file descriptor limit
     * and you know you are using many sync sessions.
     */
    static enableSessionMultiplexing(app) {
        app.internal.syncManager.setSessionMultiplexing(true);
    }
    // TODO: Consider breaking the API, turning this into an instance method
    /**
     * Initiate a client reset. The Realm must be closed prior to the reset.
     *
     * A synced Realm may need to be reset if the communications with the Atlas Device Sync Server
     * indicate an unrecoverable error that prevents continuing with normal synchronization. The
     * most common reason for this is if a client has been disconnected for too long.
     *
     * The local copy of the Realm is moved into a recovery directory
     * for safekeeping.
     *
     * Local writes that were not successfully synchronized to Atlas
     * will be present in the local recovery copy of the Realm file. The re-downloaded Realm will
     * initially contain only the data present at the time the Realm was synchronized up on the server.
     * @deprecated
     * @throws An {@link Error} if reset is not possible.
     * @example
     * {
     *   // Once you have opened your Realm, you will have to keep a reference to it.
     *   // In the error handler, this reference is called `realm`
     *   const config = {
     *     // schema, etc.
     *     sync: {
     *       user,
     *       partitionValue,
     *       error: (session, error) => {
     *         if (error.name === 'ClientReset') {
     *           let path = realm.path; // realm.path will no be accessible after realm.close()
     *           realm.close();
     *           Realm.App.Sync.initiateClientReset(app, path);
     *           // - open Realm at `error.config.path` (oldRealm)
     *           // - open Realm with `config` (newRealm)
     *           // - copy required objects from oldRealm to newRealm
     *           // - close both Realms
     *         }
     *       }
     *     }
     *   };
     * }
     */
    static initiateClientReset(app, path) {
        const success = app.internal.syncManager.immediatelyRunFileActions(path);
        // TODO: Consider a better error message
        assert(success, `Realm was not configured correctly. Client Reset could not be run for Realm at: ${path}`);
    }
    // TODO: Consider breaking the API, turning this into an instance method
    /**
     * Returns `true` if Realm still has a reference to any sync sessions regardless of their state.
     * If `false` is returned it means that no sessions currently exist.
     * @param [app] - The app where the Realm was opened.
     * @internal
     */
    static _hasExistingSessions(app) {
        return app.internal.syncManager.hasExistingSessions;
    }
    // TODO: Consider breaking the API, turning this into an instance method
    static reconnect(app) {
        app.internal.syncManager.reconnect();
    }
    /**
     * The default behavior settings if you want to open a synchronized Realm immediately and start working on it.
     * If this is the first time you open the Realm, it will be empty while the server data is being downloaded in the background.
     * @deprecated since v12
     */
    static openLocalRealmBehavior = {
        type: exports.OpenRealmBehaviorType.OpenImmediately,
    };
    /**
     * The default behavior settings if you want to wait for downloading a synchronized Realm to complete before opening it.
     * @deprecated since v12
     */
    static downloadBeforeOpenBehavior = {
        type: exports.OpenRealmBehaviorType.DownloadBeforeOpen,
        timeOut: 30 * 1000,
        timeOutBehavior: exports.OpenRealmTimeOutBehavior.ThrowException,
    };
}

////////////////////////////////////////////////////////////////////////////
/**
 * The class represents an Atlas App Services Application.
 *
 * ```js
 * const app = new App({ id: "my-app-qwert" });
 * ```
 */
class App {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static appById = new Map();
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    static appByUserId = new Map();
    /**
     * Get or create a singleton Realm App from an ID.
     * Calling this function multiple times with the same ID will return the same instance.
     * @deprecated Use {@link App.get}.
     * @param id - The Realm App ID visible from the Atlas App Services UI or a configuration.
     * @returns The Realm App instance.
     */
    static getApp(id) {
        return this.get(id);
    }
    /**
     * Get or create a singleton Realm App from an ID.
     * Calling this function multiple times with the same ID will return the same instance.
     * @param id - The Realm App ID visible from the Atlas App Services UI or a configuration.
     * @returns The Realm App instance.
     */
    static get(id) {
        const cachedApp = App.appById.get(id)?.deref();
        if (cachedApp) {
            return cachedApp;
        }
        const newApp = new App(id);
        App.appById.set(id, new WeakRef(newApp));
        return newApp;
    }
    static Sync = Sync;
    /**
     * All credentials available for authentication.
     * @see https://www.mongodb.com/docs/atlas/app-services/authentication/
     */
    static Credentials = Credentials;
    /** @internal */
    static deviceInfo = deviceInfo.create();
    /** @internal */
    static userAgent = `RealmJS/${App.deviceInfo.sdkVersion} (v${App.deviceInfo.platformVersion})`;
    /** @internal */
    static getAppByUser(userInternal) {
        const app = App.appByUserId.get(userInternal.identity)?.deref();
        if (!app) {
            throw new Error(`Cannot determine which app is associated with user (id = ${userInternal.identity})`);
        }
        return app;
    }
    /** @internal */
    static setAppByUser(userInternal, currentApp) {
        App.appByUserId.set(userInternal.identity, new WeakRef(currentApp));
    }
    /** @internal */
    internal;
    listeners = new Listeners({
        add: (callback) => {
            return this.internal.subscribe(callback);
        },
        remove: (token) => {
            this.internal.unsubscribe(token);
        },
    });
    constructor(configOrId) {
        const config = typeof configOrId === "string" ? { id: configOrId } : configOrId;
        assert.object(config, "config");
        const { id, baseUrl, app, timeout, multiplexSessions = true, baseFilePath } = config;
        assert.string(id, "id");
        if (timeout !== undefined) {
            assert.number(timeout, "timeout");
        }
        assert.boolean(multiplexSessions, "multiplexSessions");
        if (baseFilePath !== undefined) {
            assert.string(baseFilePath, "baseFilePath");
        }
        fs.ensureDirectoryForFile(fs.joinPaths(baseFilePath || fs.getDefaultDirectoryPath(), "mongodb-realm"));
        // TODO: This used getSharedApp in the legacy SDK, but it's failing AppTests
        this.internal = App$1.getUncachedApp({
            appId: id,
            deviceInfo: App.deviceInfo,
            transport: createNetworkTransport(),
            localAppName: app?.name,
            localAppVersion: app?.version,
            baseUrl,
            defaultRequestTimeoutMs: timeout ? Int64.numToInt(timeout) : undefined,
        }, {
            baseFilePath: baseFilePath ? baseFilePath : fs.getDefaultDirectoryPath(),
            metadataMode: 0 /* binding.MetadataMode.NoEncryption */,
            userAgentBindingInfo: App.userAgent,
            multiplexSessions,
        });
    }
    /**
     * @returns The app ID.
     */
    get id() {
        return this.internal.config.appId;
    }
    /**
     * Log in a user.
     * @param credentials - A credentials object describing the type of authentication provider and its parameters.
     * @returns A promise that resolves to the logged in {@link User}.
     * @throws An {@link Error} if the login failed.
     */
    async logIn(credentials) {
        const userInternal = await this.internal.logInWithCredentials(credentials.internal);
        return User.get(userInternal, this);
    }
    /**
     * Perform operations related to the email/password auth provider.
     * @returns An instance of the email password authentication provider.
     */
    get emailPasswordAuth() {
        // TODO: Add memoization
        const internal = this.internal.usernamePasswordProviderClient();
        return new EmailPasswordAuth(internal);
    }
    /**
     * The last user to log in or being switched to.
     * @returns A {@link User} object representing the currently logged in user. If no user is logged in, `null` is returned.
     */
    get currentUser() {
        const currentUser = this.internal.currentUser;
        return currentUser ? User.get(currentUser, this) : null;
    }
    /**
     * All users that have logged into the device and have not been removed.
     * @returns A mapping from user ID to user.
     */
    get allUsers() {
        return Object.fromEntries(this.internal.allUsers.map((user) => [user.identity, User.get(user, this)]));
    }
    /**
     * Switches the current user to the one specified in {@link user}.
     * @throws an {@link Error} if the new user is logged out or removed.
     * @param user - The user to switch to.
     */
    switchUser(user) {
        this.internal.switchUser(user.internal);
    }
    /**
     * Logs out and removes a user from the client.
     * @returns A promise that resolves once the user has been logged out and removed from the app.
     */
    async removeUser(user) {
        await this.internal.removeUser(user.internal);
    }
    /**
     * Delete the user.
     * NOTE: This irrecoverably deletes the user from the device as well as the server!
     * @returns A promise that resolves once the user has been deleted.
     */
    async deleteUser(user) {
        await this.internal.deleteUser(user.internal);
    }
    /**
     * Adds a listener that will be fired on various user events.
     * This includes login, logout, switching users, linking users and refreshing custom data.
     * @param callback - A callback function that will be called when the event occurs.
     */
    addListener(callback) {
        this.listeners.add(callback);
    }
    /**
     * Removes an event listener previously added via {@link App.addListener}.
     * @param callback - The callback to remove.
     */
    removeListener(callback) {
        this.listeners.remove(callback);
    }
    /**
     * Removes all event listeners previously added via {@link App.addListener}.
     */
    removeAllListeners() {
        this.listeners.removeAll();
    }
}

////////////////////////////////////////////////////////////////////////////
const debug = extendDebug("Realm");
/**
 * Asserts the event passed as string is a valid RealmEvent value.
 * @throws A {@link TypeAssertionError} if an unexpected name is passed via {@link name}.
 * @param name - The name of the event.
 * @internal
 */
function assertRealmEvent(name) {
    const values = Object.values(RealmEvent);
    if (!values.includes(name)) {
        throw new TypeAssertionError("One of " + values.join(", "), name);
    }
}
/**
 * The Realm database.
 */
class Realm {
    static App = App;
    static Auth = { EmailPasswordAuth, ApiKeyAuth };
    static BSON = exports.BSON;
    static ClientResetMode = exports.ClientResetMode;
    static Collection = Collection;
    static CompensatingWriteError = CompensatingWriteError;
    static ConnectionState = exports.ConnectionState;
    static Credentials = Credentials;
    static Dictionary = Dictionary;
    static flags = flags;
    static index = index;
    static List = List;
    static mapTo = mapTo;
    static NumericLogLevel = exports.NumericLogLevel;
    static Object = RealmObject;
    static OpenRealmBehaviorType = exports.OpenRealmBehaviorType;
    static OpenRealmTimeOutBehavior = exports.OpenRealmTimeOutBehavior;
    static OrderedCollection = OrderedCollection;
    static ProgressDirection = exports.ProgressDirection;
    static ProgressMode = exports.ProgressMode;
    static PropertySchemaParseError = PropertySchemaParseError;
    static ProviderType = exports.ProviderType;
    static ProxyType = exports.ProxyType;
    static Results = Results;
    static SchemaParseError = SchemaParseError;
    static SessionState = exports.SessionState;
    static SessionStopPolicy = exports.SessionStopPolicy;
    static Set = RealmSet;
    static SubscriptionSetState = exports.SubscriptionSetState;
    static SyncError = SyncError;
    static Types = exports.Types;
    static UpdateMode = exports.UpdateMode;
    static User = User;
    static UserState = exports.UserState;
    static WaitForSync = exports.WaitForSync;
    static kmToRadians = kmToRadians;
    static miToRadians = miToRadians;
    static defaultPath = Realm.normalizePath("default.realm");
    static internals = new Set();
    /**
     * Sets the log level.
     * @param level - The log level to be used by the logger. The default value is `info`.
     * @note The log level can be changed during the lifetime of the application.
     * @since 12.0.0
     */
    static setLogLevel(level) {
        const bindingLoggerLevel = toBindingLoggerLevel(level);
        Logger.setDefaultLevelThreshold(bindingLoggerLevel);
    }
    /**
     * Sets the logger callback.
     * @param loggerCallback - The callback invoked by the logger. The default callback uses `console.log`, `console.warn` and `console.error`, depending on the level of the message.
     * @note The logger callback needs to be setup before opening the first realm.
     * @since 12.0.0
     */
    static setLogger(loggerCallback) {
        const logger = Helpers.makeLogger((level, message) => {
            loggerCallback(fromBindingLoggerLevelToLogLevel(level), message);
        });
        Logger.setDefaultLogger(logger);
    }
    /**
     * Clears the state by closing and deleting any Realm in the default directory and logout all users.
     * NOTE: Not a part of the public API and it's primarily used from the library's tests.
     * @private
     */
    static clearTestState() {
        assert(flags.ALLOW_CLEAR_TEST_STATE, "Set the flags.ALLOW_CLEAR_TEST_STATE = true before calling this.");
        // Close any realms not already closed
        for (const realmRef of Realm.internals) {
            const realm = realmRef.deref();
            if (realm && !realm.isClosed) {
                realm.close();
            }
        }
        Realm.internals.clear();
        RealmCoordinator.clearAllCaches();
        App$1.clearCachedApps();
        ProgressRealmPromise.cancelAll();
        // Delete all Realm files in the default directory
        const defaultDirectoryPath = fs.getDefaultDirectoryPath();
        fs.removeRealmFilesFromDirectory(defaultDirectoryPath);
    }
    /**
     * Delete the Realm file for the given configuration.
     * @param config - The configuration for the Realm being deleted.
     * @throws An {@link Error} if anything in the provided {@link config} is invalid.
     */
    static deleteFile(config) {
        validateConfiguration(config);
        const path = Realm.determinePath(config);
        fs.removeFile(path);
        fs.removeFile(path + ".lock");
        fs.removeFile(path + ".fresh.lock");
        fs.removeFile(path + ".note");
        fs.removeDirectory(path + ".management");
    }
    /**
     * Checks if the Realm already exists on disk.
     * @param arg - The configuration for the Realm or the path to it.
     * @throws An {@link Error} if anything in the provided {@link config} is invalid.
     * @returns `true` if the Realm exists on the device, `false` if not.
     */
    static exists(arg = {}) {
        const config = typeof arg === "string" ? { path: arg } : arg;
        validateConfiguration(config);
        const path = Realm.determinePath(config);
        return fs.exists(path);
    }
    /**
     * Open a Realm asynchronously with a promise. If the Realm is synced, it will be fully
     * synchronized before it is available.
     * In the case of query-based sync, {@link Configuration.scheme | config.schema} is required. An exception will be
     * thrown if {@link Configuration.scheme | config.schema} is not defined.
     * @param arg - The configuration for the Realm or the path to it.
     * @returns A promise that will be resolved with the Realm instance when it's available.
     * @throws An {@link Error} if anything in the provided {@link arg} is invalid.
     */
    static open(arg = {}) {
        const config = typeof arg === "string" ? { path: arg } : arg;
        return new ProgressRealmPromise(config);
    }
    /**
     * Get the current schema version of the Realm at the given path.
     * @param path - The path to the file where the Realm database is stored.
     * @param encryptionKey - Required only when accessing encrypted Realms.
     * @throws An {@link Error} if passing an invalid or non-matching encryption key.
     * @returns Version of the schema as an integer, or `-1` if no Realm exists at {@link path}.
     */
    static schemaVersion(path, encryptionKey) {
        const config = { path };
        const absolutePath = Realm.determinePath(config);
        const schemaVersion = Realm$1.getSchemaVersion({
            path: absolutePath,
            encryptionKey: Realm.determineEncryptionKey(encryptionKey),
        });
        return Int64.intToNum(schemaVersion);
    }
    /**
     * Creates a template object for a Realm model class where all optional fields are undefined
     * and all required fields have the default value for the given data type, either the value
     * set by the default property in the schema or the default value for the datatype if the schema
     * doesn't specify one, i.e. 0, false and "".
     * @param objectSchema - Schema describing the object that should be created.
     */
    static createTemplateObject(objectSchema) {
        validateObjectSchema(objectSchema);
        const normalizedSchema = normalizeObjectSchema(objectSchema);
        const result = {};
        for (const [key, property] of Object.entries(normalizedSchema.properties)) {
            // If a default value is explicitly set, always set the property
            if (typeof property.default !== "undefined") {
                result[key] = property.default;
                continue;
            }
            // if optional is set, it wil take precedence over any `?` set on the type parameter
            if (property.optional) {
                continue;
            }
            // Set the default value for all required primitive types.
            // Lists are always treated as empty if not specified and references to objects are always optional
            switch (property.type) {
                case "bool":
                    result[key] = false;
                    break;
                case "int":
                    result[key] = 0;
                    break;
                case "float":
                    result[key] = 0.0;
                    break;
                case "double":
                    result[key] = 0.0;
                    break;
                case "string":
                    result[key] = "";
                    break;
                case "data":
                    result[key] = new ArrayBuffer(0);
                    break;
                case "date":
                    result[key] = new Date(0);
                    break;
            }
        }
        return result;
    }
    /**
     * Copy any Realm files  (i.e. `*.realm`) bundled with the application from the application
     * directory into the application's documents directory, so that they can be opened and used
     * by Realm. If the file already exists in the documents directory, it will not be
     * overwritten, so this can safely be called multiple times.
     *
     * This should be called before opening the Realm, in order to move the bundled Realm
     * files into a place where they can be written to.
     * @example
     * ```
     * // Given a bundled file, example.realm, this will copy example.realm (and any other .realm files)
     * // from the app bundle into the app's documents directory. If the file already exists, it will
     * // not be overwritten, so it is safe to call this every time the app starts.
     * Realm.copyBundledRealmFiles();
     *
     * const realm = await Realm.open({
     * // This will open example.realm from the documents directory, with the bundled data in.
     * path: "example.realm"
     * });
     * ```
     *
     * This is only implemented for React Native.
     * @throws an {@link Error} If an I/O error occurred or method is not implemented.
     */
    static copyBundledRealmFiles() {
        fs.copyBundledRealmFiles();
    }
    /**
     * TODO: Consider breaking this by ensuring a ".realm" suffix (coordinating with other SDK teams in the process)
     */
    static normalizePath(path) {
        if (typeof path === "undefined") {
            return Realm.defaultPath;
        }
        else if (path.length === 0) {
            throw new Error("Unexpected empty path");
        }
        else if (fs.isAbsolutePath(path)) {
            return path;
        }
        else {
            return fs.joinPaths(fs.getDefaultDirectoryPath(), path);
        }
    }
    /**
     * @note When the path is relative and the config contains a sync object, Core will replace any existing file extension
     * or add the ".realm" suffix.
     */
    static determinePath(config) {
        if (config.sync && !config.openSyncedRealmLocally) {
            if (config.path && fs.isAbsolutePath(config.path)) {
                return Realm.normalizePath(config.path);
            }
            else {
                const bindingSyncConfig = toBindingSyncConfig(config.sync);
                return config.sync.user.internal.syncManager.pathForRealm(bindingSyncConfig, config.path);
            }
        }
        else {
            return Realm.normalizePath(config.path);
        }
    }
    static determineEncryptionKey(encryptionKey) {
        if (typeof encryptionKey === "undefined") {
            return encryptionKey;
        }
        else {
            return toArrayBuffer(encryptionKey, false);
        }
    }
    static extractSchemaExtras(schemas) {
        return Object.fromEntries(schemas.map((schema) => {
            const defaults = Object.fromEntries(Object.entries(schema.properties).map(([name, property]) => {
                return [name, property.default];
            }));
            return [schema.name, { defaults, constructor: schema.ctor }];
        }));
    }
    /** @internal */
    static transformConfig(config) {
        const normalizedSchema = config.schema && normalizeRealmSchema(config.schema);
        const schemaExtras = Realm.extractSchemaExtras(normalizedSchema || []);
        const path = Realm.determinePath(config);
        const { fifoFilesFallbackPath, shouldCompact, inMemory } = config;
        const bindingSchema = normalizedSchema && toBindingSchema(normalizedSchema);
        return {
            schemaExtras,
            bindingConfig: {
                path,
                cache: true,
                fifoFilesFallbackPath,
                schema: bindingSchema,
                inMemory: inMemory === true,
                schemaMode: Realm.determineSchemaMode(config),
                schemaVersion: config.schema
                    ? Int64.numToInt(typeof config.schemaVersion === "number" ? config.schemaVersion : 0)
                    : undefined,
                migrationFunction: config.onMigration ? Realm.wrapMigration(schemaExtras, config.onMigration) : undefined,
                shouldCompactOnLaunchFunction: shouldCompact
                    ? (totalBytes, usedBytes) => {
                        return shouldCompact(Number(totalBytes), Number(usedBytes));
                    }
                    : undefined,
                disableFormatUpgrade: config.disableFormatUpgrade,
                encryptionKey: Realm.determineEncryptionKey(config.encryptionKey),
                syncConfig: config.sync ? toBindingSyncConfig(config.sync) : undefined,
                forceSyncHistory: config.openSyncedRealmLocally,
                automaticallyHandleBacklinksInMigrations: config.migrationOptions?.resolveEmbeddedConstraints ?? false,
            },
        };
    }
    static determineSchemaMode(config) {
        const { readOnly, deleteRealmIfMigrationNeeded, onMigration, sync } = config;
        assert(!readOnly || !deleteRealmIfMigrationNeeded, "Cannot set 'deleteRealmIfMigrationNeeded' when 'readOnly' is set.");
        assert(!onMigration || !deleteRealmIfMigrationNeeded, "Cannot set 'deleteRealmIfMigrationNeeded' when 'onMigration' is set.");
        if (readOnly) {
            return 1 /* binding.SchemaMode.Immutable */;
        }
        else if (deleteRealmIfMigrationNeeded) {
            return 3 /* binding.SchemaMode.SoftResetFile */;
        }
        else if (sync) {
            return 6 /* binding.SchemaMode.AdditiveExplicit */;
        }
        else {
            return undefined;
        }
    }
    static wrapMigration(schemaExtras, onMigration) {
        return (oldRealmInternal, newRealmInternal) => {
            try {
                const oldRealm = new Realm(null, { internal: oldRealmInternal, schemaExtras });
                const newRealm = new Realm(null, { internal: newRealmInternal, schemaExtras });
                onMigration(oldRealm, newRealm);
            }
            finally {
                oldRealmInternal.close();
                oldRealmInternal.$resetSharedPtr();
                newRealmInternal.$resetSharedPtr();
            }
        };
    }
    /**
     * The Realms's representation in the binding.
     * @internal
     */
    internal;
    /**
     * The sync session if this is a synced Realm
     */
    syncSession;
    schemaExtras = {};
    classes;
    changeListeners = new RealmListeners(this, RealmEvent.Change);
    beforeNotifyListeners = new RealmListeners(this, RealmEvent.BeforeNotify);
    schemaListeners = new RealmListeners(this, RealmEvent.Schema);
    /** @internal */
    currentUpdateMode;
    constructor(arg, internalConfig = {}) {
        const config = typeof arg === "string" ? { path: arg } : arg || {};
        // Calling `Realm.exists()` before `binding.Realm.getSharedRealm()` is necessary to capture
        // the correct value when this constructor was called since `binding.Realm.getSharedRealm()`
        // will open the realm. This is needed when deciding whether to update initial subscriptions.
        const realmExists = internalConfig.realmExists ?? Realm.exists(config);
        if (arg !== null) {
            assert(!internalConfig.schemaExtras, "Expected either a configuration or schemaExtras");
            validateConfiguration(config);
            const { bindingConfig, schemaExtras } = Realm.transformConfig(config);
            debug("open", bindingConfig);
            this.schemaExtras = schemaExtras;
            fs.ensureDirectoryForFile(bindingConfig.path);
            this.internal = internalConfig.internal ?? Realm$1.getSharedRealm(bindingConfig);
            if (flags.ALLOW_CLEAR_TEST_STATE) {
                Realm.internals.add(new WeakRef(this.internal));
            }
            Helpers.setBindingContext(this.internal, {
                didChange: (r) => {
                    r.verifyOpen();
                    this.changeListeners.notify();
                },
                schemaDidChange: (r) => {
                    r.verifyOpen();
                    this.classes = new ClassMap(this, this.internal.schema, this.schema);
                    this.schemaListeners.notify(this.schema);
                },
                beforeNotify: (r) => {
                    r.verifyOpen();
                    this.beforeNotifyListeners.notify();
                },
            });
        }
        else {
            const { internal, schemaExtras } = internalConfig;
            assert.instanceOf(internal, Realm$1, "internal");
            this.internal = internal;
            this.schemaExtras = schemaExtras || {};
        }
        Object.defineProperty(this, "classes", {
            enumerable: false,
            configurable: false,
            writable: true,
        });
        Object.defineProperty(this, "internal", {
            enumerable: false,
            configurable: false,
            writable: false,
        });
        this.classes = new ClassMap(this, this.internal.schema, this.schema);
        const syncSession = this.internal.syncSession;
        this.syncSession = syncSession ? new SyncSession(syncSession) : null;
        const initialSubscriptions = config.sync?.initialSubscriptions;
        if (initialSubscriptions && !config.openSyncedRealmLocally) {
            // Do not call `Realm.exists()` here in case the realm has been opened by this point in time.
            this.handleInitialSubscriptions(initialSubscriptions, realmExists);
        }
    }
    /**
     * Indicates if this Realm contains any objects.
     * @returns `true` if empty, `false` otherwise.
     * @readonly
     * @since 1.10.0
     */
    get isEmpty() {
        return Helpers.isEmptyRealm(this.internal);
    }
    /**
     * The path to the file where this Realm is stored.
     * @returns A string containing the path to the file where this Realm is stored.
     * @readonly
     * @since 0.12.0
     */
    get path() {
        return this.internal.config.path;
    }
    /**
     * Indicates if this Realm was opened as read-only.
     * @returns `true` if this Realm is read-only, `false` otherwise.
     * @readonly
     * @since 0.12.0
     */
    get isReadOnly() {
        return this.internal.config.schemaMode === 1 /* binding.SchemaMode.Immutable */;
    }
    /**
     * Indicates if this Realm was opened in-memory.
     * @returns `true` if this Realm is in-memory, `false` otherwise.
     * @readonly
     */
    get isInMemory() {
        return this.internal.config.inMemory;
    }
    /**
     * A normalized representation of the schema provided in the {@link Configuration} when this Realm was constructed.
     * @returns An array of {@link CanonicalObjectSchema} describing all objects in this Realm.
     * @readonly
     * @since 0.12.0
     */
    get schema() {
        const schemas = fromBindingRealmSchema(this.internal.schema);
        // Stitch in the constructors and defaults stored in this.schemaExtras
        for (const objectSchema of schemas) {
            const extras = this.schemaExtras[objectSchema.name];
            if (extras) {
                objectSchema.ctor = extras.constructor;
            }
            for (const property of Object.values(objectSchema.properties)) {
                property.default = extras ? extras.defaults[property.name] : undefined;
            }
        }
        return schemas;
    }
    /**
     * The current schema version of the Realm.
     * @returns The schema version of this Realm, as a `number`.
     * @readonly
     * @since 0.12.0
     */
    get schemaVersion() {
        return Number(this.internal.schemaVersion);
    }
    /**
     * Indicates if this Realm is in a write transaction.
     * @returns `true` if in a write transaction, `false` otherwise.
     * @readonly
     * @since 1.10.3
     */
    get isInTransaction() {
        // TODO: Consider keeping a local state in JS for this
        return this.internal.isInTransaction;
    }
    /**
     * Indicates if this Realm has been closed.
     * @returns `true` if closed, `false` otherwise.
     * @readonly
     * @since 2.1.0
     */
    get isClosed() {
        // TODO: Consider keeping a local state in JS for this
        return this.internal.isClosed;
    }
    /**
     * The latest set of flexible sync subscriptions.
     * @returns A {@link SubscriptionSet} object.
     * @throws An {@link Error} if flexible sync is not enabled for this app.
     */
    get subscriptions() {
        const { syncConfig } = this.internal.config;
        assert(syncConfig, "`subscriptions` can only be accessed if flexible sync is enabled, but sync is " +
            "currently disabled for your app. Add a flexible sync config when opening the " +
            "Realm, for example: { sync: { user, flexible: true } }.");
        assert(syncConfig.flxSyncRequested, "`subscriptions` can only be accessed if flexible sync is enabled, but partition " +
            "based sync is currently enabled for your Realm. Modify your sync config to remove any `partitionValue` " +
            "and enable flexible sync, for example: { sync: { user, flexible: true } }");
        return new SubscriptionSet(this, this.internal.latestSubscriptionSet);
    }
    /**
     * Closes this Realm so it may be re-opened with a newer schema version.
     * All objects and collections from this Realm are no longer valid after calling this method.
     * The method is idempotent.
     */
    close() {
        this.internal.close();
    }
    create(type, values, mode = exports.UpdateMode.Never) {
        // Supporting a boolean overload for mode
        if (mode === true) {
            mode = exports.UpdateMode.All;
        }
        else if (mode === false) {
            mode = exports.UpdateMode.Never;
        }
        // Implements https://github.com/realm/realm-js/blob/v11/src/js_realm.hpp#L1260-L1321
        if (values instanceof RealmObject && !values[INTERNAL$1]) {
            throw new Error("Cannot create an object from a detached RealmObject instance");
        }
        if (!Object.values(exports.UpdateMode).includes(mode)) {
            throw new Error(`Unsupported 'updateMode'. Only '${exports.UpdateMode.Never}', '${exports.UpdateMode.Modified}' or '${exports.UpdateMode.All}' is supported.`);
        }
        this.internal.verifyOpen();
        const helpers = this.classes.getHelpers(type);
        this.currentUpdateMode = mode;
        let realmObject;
        try {
            realmObject = RealmObject.create(this, values, mode, { helpers });
        }
        finally {
            this.currentUpdateMode = undefined;
        }
        return isAsymmetric(helpers.objectSchema) ? undefined : realmObject;
    }
    //FIXME: any should not be used, but we are staying compatible with previous versions
    /**
     * Deletes the provided Realm object, or each one inside the provided collection.
     * @param subject - The Realm object to delete, or a collection containing multiple Realm objects to delete.
     */
    delete(subject) {
        assert.inTransaction(this, "Can only delete objects within a transaction.");
        assert.object(subject, "subject");
        if (subject instanceof RealmObject) {
            assert.isSameRealm(subject[REALM$1].internal, this.internal, "Can't delete an object from another Realm");
            const { objectSchema } = this.classes.getHelpers(subject);
            const obj = subject[INTERNAL$1];
            assert.isValid(obj, "Object is invalid. Either it has been previously deleted or the Realm it belongs to has been closed.");
            const table = Helpers.getTable(this.internal, objectSchema.tableKey);
            table.removeObject(obj.key);
        }
        else if (subject instanceof List) {
            subject.internal.deleteAll();
        }
        else if (subject instanceof Results) {
            subject.internal.clear();
        }
        else if (Array.isArray(subject) || Symbol.iterator in subject) {
            //@ts-expect-error the above check is good enough
            for (const object of subject) {
                assert.instanceOf(object, RealmObject);
                assert.isSameRealm(object[REALM$1].internal, this.internal, "Can't delete an object from another Realm");
                const { objectSchema } = this.classes.getHelpers(object);
                const table = Helpers.getTable(this.internal, objectSchema.tableKey);
                table.removeObject(object[INTERNAL$1].key);
            }
        }
        else {
            throw new Error("Can only delete objects, lists and results.");
        }
    }
    /**
     * Deletes a Realm model, including all of its objects.
     * If called outside a migration function, {@link schema} and {@link schemaVersion} are updated.
     * @param name - The model name.
     */
    deleteModel(name) {
        assert.inTransaction(this, "Can only delete objects within a transaction.");
        Helpers.deleteDataForObject(this.internal, name);
        if (!this.internal.isInMigration) {
            const newSchema = this.internal.schema.filter((objectSchema) => objectSchema.name !== name);
            this.internal.updateSchema(newSchema, Int64.add(this.internal.schemaVersion, Int64.numToInt(1)), null, null, true);
        }
    }
    /**
     * **WARNING:** This will delete **all** objects in the Realm!
     */
    deleteAll() {
        assert.inTransaction(this, "Can only delete objects within a transaction.");
        for (const objectSchema of this.internal.schema) {
            const table = Helpers.getTable(this.internal, objectSchema.tableKey);
            table.clear();
        }
    }
    objectForPrimaryKey(type, primaryKey) {
        // Implements https://github.com/realm/realm-js/blob/v11/src/js_realm.hpp#L1240-L1258
        const { objectSchema, properties, wrapObject } = this.classes.getHelpers(type);
        if (!objectSchema.primaryKey) {
            throw new Error(`Expected a primary key on '${objectSchema.name}'`);
        }
        if (isAsymmetric(objectSchema)) {
            throw new Error("You cannot query an asymmetric object.");
        }
        const table = Helpers.getTable(this.internal, objectSchema.tableKey);
        const value = properties.get(objectSchema.primaryKey).toBinding(primaryKey);
        try {
            const objKey = table.findPrimaryKey(value);
            if (isEmptyObjKey(objKey)) {
                return null;
            }
            else {
                const obj = table.getObject(objKey);
                return wrapObject(obj);
            }
        }
        catch (err) {
            // TODO: Match on something else than the error message, when exposed by the binding
            if (err instanceof Error && err.message.startsWith("No object with key")) {
                throw new Error(`No '${objectSchema.name}' with key '${primaryKey}'`);
            }
            else {
                throw err;
            }
        }
    }
    _objectForObjectKey(type, objectKey) {
        const { objectSchema, wrapObject } = this.classes.getHelpers(type);
        if (isEmbedded(objectSchema)) {
            throw new Error("You cannot query an embedded object.");
        }
        else if (isAsymmetric(objectSchema)) {
            throw new Error("You cannot query an asymmetric object.");
        }
        assert.numericString(objectKey);
        const table = Helpers.getTable(this.internal, objectSchema.tableKey);
        try {
            const objKey = stringToObjKey(objectKey);
            const obj = table.tryGetObject(objKey);
            const result = obj && wrapObject(obj);
            return result === null ? undefined : result;
        }
        catch (err) {
            if (err instanceof InvalidObjKey) {
                return undefined;
            }
            else {
                throw err;
            }
        }
    }
    objects(type) {
        const { objectSchema, wrapObject } = this.classes.getHelpers(type);
        if (isEmbedded(objectSchema)) {
            throw new Error("You cannot query an embedded object.");
        }
        else if (isAsymmetric(objectSchema)) {
            throw new Error("You cannot query an asymmetric object.");
        }
        const table = Helpers.getTable(this.internal, objectSchema.tableKey);
        const results = Results$1.fromTable(this.internal, table);
        return new Results(this, results, {
            get(results, index) {
                return results.getObj(index);
            },
            fromBinding: wrapObject,
            toBinding(value) {
                assert.instanceOf(value, RealmObject);
                return value[INTERNAL$1];
            },
        });
    }
    /**
     * Add a listener {@link callback} for the specified {@link eventName}.
     * @param eventName - The name of event that should cause the callback to be called.
     * @param callback - Function to be called when a change event occurs.
     * Each callback will only be called once per event, regardless of the number of times
     * it was added.
     * @param callback.realm - The Realm in which the change event occurred.
     * @param callback.name - The name of the event that occurred.
     * @param callback.schema - The schema of the Realm file when the event occurred.
     * @throws An {@link Error} if an invalid event {@link eventName} is supplied, if Realm is closed or if {@link callback} is not a function.
     */
    addListener(eventName, callback) {
        assert.open(this);
        assert.function(callback);
        if (eventName === "change") {
            this.changeListeners.add(callback);
        }
        else if (eventName === "schema") {
            this.schemaListeners.add(callback);
        }
        else if (eventName === "beforenotify") {
            this.beforeNotifyListeners.add(callback);
        }
        else {
            throw new Error(`Unknown event name '${eventName}': only 'change', 'schema' and 'beforenotify' are supported.`);
        }
    }
    /**
     * Remove the listener {@link callback} for the specified event {@link eventName}.
     * @param eventName - The event name.
     * @param callback - Function that was previously added as a listener for this event through the {@link addListener} method.
     * @throws an {@link Error} If an invalid event {@link eventName} is supplied, if Realm is closed or if {@link callback} is not a function.
     */
    removeListener(eventName, callback) {
        assert.open(this);
        assert.function(callback);
        assertRealmEvent(eventName);
        if (eventName === RealmEvent.Change) {
            this.changeListeners.remove(callback);
        }
        else if (eventName === RealmEvent.Schema) {
            this.schemaListeners.remove(callback);
        }
        else if (eventName === RealmEvent.BeforeNotify) {
            this.beforeNotifyListeners.remove(callback);
        }
        else {
            assert.never(eventName, "eventName");
        }
    }
    /**
     * Remove all event listeners (restricted to the event {@link eventName}, if provided).
     * @param eventName - The name of the event whose listeners should be removed.
     * @throws An {@link Error} when invalid event {@link eventName} is supplied.
     */
    removeAllListeners(eventName) {
        assert.open(this);
        if (typeof eventName === "undefined") {
            this.changeListeners.removeAll();
            this.schemaListeners.removeAll();
            this.beforeNotifyListeners.removeAll();
        }
        else {
            assert.string(eventName, "eventName");
            assertRealmEvent(eventName);
            if (eventName === RealmEvent.Change) {
                this.changeListeners.removeAll();
            }
            else if (eventName === RealmEvent.Schema) {
                this.schemaListeners.removeAll();
            }
            else if (eventName === RealmEvent.BeforeNotify) {
                this.beforeNotifyListeners.removeAll();
            }
            else {
                assert.never(eventName, "eventName");
            }
        }
    }
    /**
     * Synchronously call the provided {@link callback} inside a write transaction. If an exception happens inside a transaction,
     * youll lose the changes in that transaction, but the Realm itself wont be affected (or corrupted).
     * More precisely, {@link beginTransaction} and {@link commitTransaction} will be called
     * automatically. If any exception is thrown during the transaction {@link cancelTransaction} will
     * be called instead of {@link commitTransaction} and the exception will be re-thrown to the caller of {@link write}.
     *
     * Nested transactions (calling {@link write} within {@link write}) is not possible.
     * @param callback - Function to be called inside a write transaction.
     * @returns Returned value from the callback.
     */
    write(callback) {
        let result = undefined;
        this.internal.beginTransaction();
        try {
            result = callback();
        }
        catch (err) {
            this.internal.cancelTransaction();
            throw err;
        }
        this.internal.commitTransaction();
        return result;
    }
    /**
     * Initiate a write transaction.
     *
     * When doing a transaction, it is highly recommended to do error handling.
     * If you don't handle errors, your data might become inconsistent. Error handling
     * will often involve canceling the transaction.
     * @throws An {@link Error} if already in write transaction
     * @see {@link cancelTransaction}
     * @see {@link commitTransaction}
     * @example
     * realm.beginTransaction();
     * try {
     *   realm.create('Person', { name: 'Arthur Dent',  origin: 'Earth' });
     *   realm.create('Person', { name: 'Ford Prefect', origin: 'Betelgeuse Five' });
     *   realm.commitTransaction();
     * } catch (e) {
     *   realm.cancelTransaction();
     *   throw e;
     * }
     */
    beginTransaction() {
        this.internal.beginTransaction();
    }
    /**
     * Commit a write transaction.
     * @see {@link beginTransaction}
     */
    commitTransaction() {
        this.internal.commitTransaction();
    }
    /**
     * Cancel a write transaction.
     * @see {@link beginTransaction}
     */
    cancelTransaction() {
        this.internal.cancelTransaction();
    }
    /**
     * Replaces all string columns in this Realm with a string enumeration column and compacts the
     * database file.
     *
     * Cannot be called from a write transaction.
     *
     * Compaction will not occur if other {@link Realm} instances exist.
     *
     * While compaction is in progress, attempts by other threads or processes to open the database will
     * wait.
     *
     * Be warned that resource requirements for compaction is proportional to the amount of live data in
     * the database. Compaction works by writing the database contents to a temporary database file and
     * then replacing the database with the temporary one.
     * @returns `true` if compaction succeeds, `false` if not.
     */
    compact() {
        assert.outTransaction(this, "Cannot compact a Realm within a transaction.");
        return this.internal.compact();
    }
    /**
     * Writes a compacted copy of the Realm with the given configuration.
     *
     * The destination file cannot already exist.
     * All conversions between synced and non-synced Realms are supported, and will be
     * performed according to the {@link config} parameter, which describes the desired output.
     *
     * Note that if this method is called from within a write transaction, the current data is written,
     * not the data from the point when the previous write transaction was committed.
     * @param config - Realm configuration that describes the output realm.
     */
    writeCopyTo(config) {
        assert.outTransaction(this, "Can only convert Realms outside a transaction.");
        validateConfiguration(config);
        const { bindingConfig } = Realm.transformConfig(config);
        this.internal.convert(bindingConfig);
    }
    /**
     * Update the schema of the Realm.
     * @param schema The schema which the Realm should be updated to use.
     * @internal
     */
    _updateSchema(schema) {
        validateRealmSchema(schema);
        const normalizedSchema = normalizeRealmSchema(schema);
        const bindingSchema = toBindingSchema(normalizedSchema);
        if (!this.isInTransaction) {
            throw new Error("Can only create object schema within a transaction.");
        }
        this.internal.updateSchema(bindingSchema, Int64.add(this.internal.schemaVersion, Int64.numToInt(1)), null, null, true);
        // Note: The schema change listener is fired immediately after the call to
        //       `this.internal.updateSchema()` (thus before `_updateSchema()` has
        //       returned). Therefore, `this.classes` is updated in the `schemaDidChange`
        //       callback and not here.
    }
    /** @internal */
    getClassHelpers(arg) {
        return this.classes.getHelpers(arg);
    }
    /**
     * Update subscriptions with the initial subscriptions if needed.
     * @param initialSubscriptions The initial subscriptions.
     * @param realmExists Whether the realm already exists.
     */
    handleInitialSubscriptions(initialSubscriptions, realmExists) {
        const shouldUpdateSubscriptions = initialSubscriptions.rerunOnOpen || !realmExists;
        if (shouldUpdateSubscriptions) {
            debug("handling initial subscriptions, %O", { rerunOnOpen: initialSubscriptions.rerunOnOpen, realmExists });
            this.subscriptions.updateNoWait(initialSubscriptions.update);
        }
    }
}
/**
 * @param objectSchema - The schema of the object.
 * @returns `true` if the object is marked for asymmetric sync, otherwise `false`.
 */
function isAsymmetric(objectSchema) {
    return objectSchema.tableType === 2 /* binding.TableType.TopLevelAsymmetric */;
}
/**
 * @param objectSchema - The schema of the object.
 * @returns `true` if the object is marked as embedded, otherwise `false`.
 */
function isEmbedded(objectSchema) {
    return objectSchema.tableType === 1 /* binding.TableType.Embedded */;
}
// Exporting a deprecated global for backwards compatibility
const RealmConstructor = Realm;
//Set default logger and log level.
Realm.setLogger(defaultLogger);
Realm.setLogLevel(defaultLoggerLevel);
// Patch the global at runtime
let warnedAboutGlobalRealmUse = false;
Object.defineProperty(safeGlobalThis, "Realm", {
    get() {
        if (flags.THROW_ON_GLOBAL_REALM) {
            throw new Error("Accessed global Realm, please update your code to ensure you import Realm:\nimport Realm from 'realm';");
        }
        else if (!warnedAboutGlobalRealmUse) {
            // eslint-disable-next-line no-console
            console.warn("Your app is relying on a Realm global, which will be removed in realm-js v13, please update your code to ensure you import Realm:\n\n", 'import Realm from "realm"; // For ES Modules\n', 'const Realm = require("realm"); // For CommonJS\n\n', "To determine where, put this in the top of your index file:\n", `import Realm from "realm";\n`, `Realm.flags.THROW_ON_GLOBAL_REALM = true`);
            warnedAboutGlobalRealmUse = true;
        }
        return RealmConstructor;
    },
    configurable: false,
});

////////////////////////////////////////////////////////////////////////////
//
// Copyright 2022 Realm Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////
var RealmEvent;
(function (RealmEvent) {
    RealmEvent["Change"] = "change";
    RealmEvent["Schema"] = "schema";
    RealmEvent["BeforeNotify"] = "beforenotify";
})(RealmEvent || (RealmEvent = {}));
// Temporary functions to work between event names and corresponding enums
// TODO: We should update the external API to take a `RealmEvent` instead of a string.
class RealmListeners {
    realm;
    eventType;
    /**
     * Keeps tracked of registered listener callbacks for Realm class notifications.
     */
    constructor(realm, eventType) {
        this.realm = realm;
        this.eventType = eventType;
        this.eventType = eventType;
    }
    listeners = new Set();
    // Combined callback which runs all listener callbacks in one call.
    notify(schema) {
        // Spreading to an array to avoid firing listeners that gets added from another listener
        for (const callback of [...this.listeners]) {
            callback(this.realm, this.eventType, schema);
        }
    }
    add(callback) {
        if (this.listeners.has(callback)) {
            // No need to add a listener twice
            return;
        }
        // Store the listener.
        this.listeners.add(callback);
    }
    remove(callback) {
        this.listeners.delete(callback);
    }
    removeAll() {
        this.listeners.clear();
    }
}

////////////////////////////////////////////////////////////////////////////
/**
 * Validate the fields of a user-provided Realm configuration.
 * @internal
 */
function validateConfiguration(config) {
    assert.object(config, "realm configuration", { allowArrays: false });
    const { path, schema, schemaVersion, inMemory, readOnly, fifoFilesFallbackPath, sync, openSyncedRealmLocally, shouldCompact, deleteRealmIfMigrationNeeded, disableFormatUpgrade, encryptionKey, onMigration, migrationOptions, } = config;
    if (path !== undefined) {
        assert.string(path, "'path' on realm configuration");
        assert(path.length > 0, "The path cannot be empty. Provide a path or remove the field.");
    }
    if (schema !== undefined) {
        validateRealmSchema(schema);
    }
    if (schemaVersion !== undefined) {
        assert.number(schemaVersion, "'schemaVersion' on realm configuration");
        assert(schemaVersion >= 0 && Number.isInteger(schemaVersion), "'schemaVersion' on realm configuration must be 0 or a positive integer.");
    }
    if (inMemory !== undefined) {
        assert.boolean(inMemory, "'inMemory' on realm configuration");
    }
    if (readOnly !== undefined) {
        assert.boolean(readOnly, "'readOnly' on realm configuration");
    }
    if (fifoFilesFallbackPath !== undefined) {
        assert.string(fifoFilesFallbackPath, "'fifoFilesFallbackPath' on realm configuration");
    }
    if (onMigration !== undefined) {
        assert.function(onMigration, "'onMigration' on realm configuration");
    }
    if (sync !== undefined) {
        assert(!onMigration, "The realm configuration options 'onMigration' and 'sync' cannot both be defined.");
        assert(!migrationOptions, "The realm configuration options 'migrationOptions' and 'sync' cannot both be defined.");
        assert(inMemory === undefined, "The realm configuration options 'inMemory' and 'sync' cannot both be defined.");
        assert(deleteRealmIfMigrationNeeded === undefined, "The realm configuration options 'deleteRealmIfMigrationNeeded' and 'sync' cannot both be defined.");
        validateSyncConfiguration(sync);
    }
    if (openSyncedRealmLocally !== undefined) {
        // Internal use
        assert(openSyncedRealmLocally === true, "'openSyncedRealmLocally' on realm configuration is only used internally and must be true if defined.");
    }
    if (shouldCompact !== undefined) {
        assert.function(shouldCompact, "'shouldCompact' on realm configuration");
    }
    if (deleteRealmIfMigrationNeeded !== undefined) {
        assert.boolean(deleteRealmIfMigrationNeeded, "'deleteRealmIfMigrationNeeded' on realm configuration");
    }
    if (disableFormatUpgrade !== undefined) {
        assert.boolean(disableFormatUpgrade, "'disableFormatUpgrade' on realm configuration");
    }
    if (encryptionKey !== undefined) {
        assert(encryptionKey instanceof ArrayBuffer || ArrayBuffer.isView(encryptionKey) || encryptionKey instanceof Int8Array, `Expected 'encryptionKey' on realm configuration to be an ArrayBuffer, ArrayBufferView (Uint8Array), or Int8Array, got ${TypeAssertionError.deriveType(encryptionKey)}.`);
    }
    if (migrationOptions) {
        validateMigrationOptions(migrationOptions);
    }
}
function validateMigrationOptions(options) {
    assert.object(options, "'migrationOptions'", { allowArrays: false });
    const { resolveEmbeddedConstraints } = options;
    if (resolveEmbeddedConstraints !== undefined) {
        assert.boolean(resolveEmbeddedConstraints, "'resolveEmbeddedConstraints' on 'migrationOptions'");
    }
}

////////////////////////////////////////////////////////////////////////////
function determineBehavior(config, realmExists) {
    const { sync, openSyncedRealmLocally } = config;
    if (!sync || openSyncedRealmLocally) {
        return { openBehavior: exports.OpenRealmBehaviorType.OpenImmediately };
    }
    else {
        const configProperty = realmExists ? "existingRealmFileBehavior" : "newRealmFileBehavior";
        const configBehavior = sync[configProperty];
        if (configBehavior) {
            const { type, timeOut, timeOutBehavior } = configBehavior;
            if (typeof timeOut !== "undefined") {
                assert.number(timeOut, "timeOut");
            }
            return { openBehavior: type, timeOut, timeOutBehavior };
        }
        else {
            return {
                openBehavior: exports.OpenRealmBehaviorType.DownloadBeforeOpen,
                timeOut: 30 * 1000,
                timeOutBehavior: exports.OpenRealmTimeOutBehavior.ThrowException,
            };
        }
    }
}
class ProgressRealmPromise {
    /** @internal */
    static instances = new Set();
    /**
     * Cancels all unresolved `ProgressRealmPromise` instances.
     * @internal
     */
    static cancelAll() {
        assert(flags.ALLOW_CLEAR_TEST_STATE, "Set the flags.ALLOW_CLEAR_TEST_STATE = true before calling this.");
        for (const promiseRef of ProgressRealmPromise.instances) {
            promiseRef.deref()?.cancel();
        }
        ProgressRealmPromise.instances.clear();
    }
    /** @internal */
    task = null;
    /** @internal */
    listeners = new Set();
    /** @internal */
    handle = new PromiseHandle();
    /** @internal */
    timeoutPromise = null;
    /** @internal */
    constructor(config) {
        if (flags.ALLOW_CLEAR_TEST_STATE) {
            ProgressRealmPromise.instances.add(new WeakRef(this));
        }
        try {
            validateConfiguration(config);
            // Calling `Realm.exists()` before `binding.Realm.getSynchronizedRealm()` is necessary to capture
            // the correct value when this constructor was called since `binding.Realm.getSynchronizedRealm()`
            // will open the realm. This is needed when calling the Realm constructor.
            const realmExists = Realm.exists(config);
            const { openBehavior, timeOut, timeOutBehavior } = determineBehavior(config, realmExists);
            if (openBehavior === exports.OpenRealmBehaviorType.OpenImmediately) {
                const realm = new Realm(config);
                this.handle.resolve(realm);
            }
            else if (openBehavior === exports.OpenRealmBehaviorType.DownloadBeforeOpen) {
                const { bindingConfig } = Realm.transformConfig(config);
                // Construct an async open task
                this.task = Realm$1.getSynchronizedRealm(bindingConfig);
                // If the promise handle gets rejected, we should cancel the open task
                // to avoid consuming a thread safe reference which is no longer registered
                this.handle.promise.catch(() => this.task?.cancel());
                this.createTimeoutPromise(config, { openBehavior, timeOut, timeOutBehavior });
                this.task
                    .start()
                    .then(async (tsr) => {
                    const realm = new Realm(config, {
                        internal: Helpers.consumeThreadSafeReferenceToSharedRealm(tsr),
                        // Do not call `Realm.exists()` here in case the realm has been opened by this point in time.
                        realmExists,
                    });
                    if (config.sync?.flexible && !config.openSyncedRealmLocally) {
                        const { subscriptions } = realm;
                        if (subscriptions.state === exports.SubscriptionSetState.Pending) {
                            await subscriptions.waitForSynchronization();
                        }
                    }
                    return realm;
                })
                    .then(this.handle.resolve, (err) => {
                    assert.undefined(err.code, "Update this to use the error code instead of matching on message");
                    if (err instanceof Error && err.message === "Sync session became inactive") {
                        // This can happen when two async tasks are opened for the same Realm and one gets canceled
                        this.rejectAsCanceled();
                    }
                    else {
                        this.handle.reject(err);
                    }
                });
                // TODO: Consider storing the token returned here to unregister when the task gets cancelled,
                // if for some reason, that doesn't happen internally
                this.task.registerDownloadProgressNotifier(this.emitProgress);
            }
            else {
                throw new Error(`Unexpected open behavior '${openBehavior}'`);
            }
        }
        catch (err) {
            this.handle.reject(err);
        }
    }
    /**
     * Cancels the download of the Realm
     * If multiple `ProgressRealmPromise` instances are in progress for the same Realm, then canceling one of them
     * will cancel all of them.
     */
    cancel() {
        this.cancelAndResetTask();
        this.timeoutPromise?.cancel();
        // Clearing all listeners to avoid accidental progress notifications
        this.listeners.clear();
        // Tell anything awaiting the promise
        this.rejectAsCanceled();
    }
    /**
     * Register to receive progress notifications while the download is in progress.
     * @param callback Called multiple times as the client receives data, with two arguments:
     * 1. `transferred` The current number of bytes already transferred
     * 2. `transferable` The total number of transferable bytes (i.e. the number of bytes already transferred plus the number of bytes pending transfer)
     */
    progress(callback) {
        this.listeners.add(callback);
        return this;
    }
    then = this.handle.promise.then.bind(this.handle.promise);
    catch = this.handle.promise.catch.bind(this.handle.promise);
    finally = this.handle.promise.finally.bind(this.handle.promise);
    emitProgress = (transferredArg, transferableArg) => {
        const transferred = Int64.intToNum(transferredArg);
        const transferable = Int64.intToNum(transferableArg);
        for (const listener of this.listeners) {
            listener(transferred, transferable);
        }
    };
    createTimeoutPromise(config, { timeOut, timeOutBehavior }) {
        if (typeof timeOut === "number") {
            this.timeoutPromise = new TimeoutPromise(this.handle.promise, // Ensures the timeout gets cancelled when the realm opens
            {
                ms: timeOut,
                message: `Realm could not be downloaded in the allocated time: ${timeOut} ms.`,
            });
            if (timeOutBehavior === exports.OpenRealmTimeOutBehavior.ThrowException) {
                // Make failing the timeout, reject the promise
                this.timeoutPromise.catch(this.handle.reject);
            }
            else if (timeOutBehavior === exports.OpenRealmTimeOutBehavior.OpenLocalRealm) {
                // Make failing the timeout, resolve the promise
                this.timeoutPromise.catch((err) => {
                    if (err instanceof TimeoutError) {
                        this.cancelAndResetTask();
                        const realm = new Realm(config);
                        this.handle.resolve(realm);
                    }
                    else {
                        this.handle.reject(err);
                    }
                });
            }
            else {
                throw new Error(`Invalid 'timeOutBehavior': '${timeOutBehavior}'. Only 'throwException' and 'openLocalRealm' is allowed.`);
            }
        }
    }
    cancelAndResetTask() {
        if (this.task) {
            this.task.cancel();
            this.task.$resetSharedPtr();
            this.task = null;
        }
    }
    rejectAsCanceled() {
        const err = new Error("Async open canceled");
        this.handle.reject(err);
    }
    get [Symbol.toStringTag]() {
        return ProgressRealmPromise.name;
    }
}

////////////////////////////////////////////////////////////////////////////
const TYPE_MAPPINGS$1 = {
    [0 /* BindingPropertyType.Int */]: "int",
    [1 /* BindingPropertyType.Bool */]: "bool",
    [2 /* BindingPropertyType.String */]: "string",
    [3 /* BindingPropertyType.Data */]: "data",
    [4 /* BindingPropertyType.Date */]: "date",
    [5 /* BindingPropertyType.Float */]: "float",
    [6 /* BindingPropertyType.Double */]: "double",
    [9 /* BindingPropertyType.Mixed */]: "mixed",
    [10 /* BindingPropertyType.ObjectId */]: "objectId",
    [11 /* BindingPropertyType.Decimal */]: "decimal128",
    [12 /* BindingPropertyType.Uuid */]: "uuid",
    [128 /* BindingPropertyType.Array */]: "list",
    [256 /* BindingPropertyType.Set */]: "set",
    [512 /* BindingPropertyType.Dictionary */]: "dictionary",
    [8 /* BindingPropertyType.LinkingObjects */]: "linkingObjects",
    [7 /* BindingPropertyType.Object */]: "object",
    // These have no direct
    [64 /* BindingPropertyType.Nullable */]: null,
    //
    [896 /* BindingPropertyType.Collection */]: null,
    [960 /* BindingPropertyType.Flags */]: null,
};
/**
 * Get the string representation of a property type's base type (not including flags)
 * @internal
 */
function getTypeName(type, objectType) {
    const baseType = type & ~960 /* BindingPropertyType.Flags */;
    if (type & 128 /* BindingPropertyType.Array */) {
        if (baseType === 7 /* BindingPropertyType.Object */) {
            return `list<${objectType}>`;
        }
        else {
            return `list<${getTypeName(baseType, objectType)}>`;
        }
    }
    else if (type & 256 /* BindingPropertyType.Set */) {
        return `set<${getTypeName(baseType, objectType)}>`;
    }
    else if (type & 512 /* BindingPropertyType.Dictionary */) {
        return `dictionary<${getTypeName(baseType, objectType)}>`;
    }
    else if (baseType === 7 /* BindingPropertyType.Object */ && objectType) {
        assert.string(objectType, "objectType");
        return `<${objectType}>`;
    }
    else {
        const result = TYPE_MAPPINGS$1[baseType];
        assert(result, `Unexpected type ${type}`);
        return result;
    }
}
const COLLECTION_TYPES$1 = [128 /* BindingPropertyType.Array */, 256 /* BindingPropertyType.Set */, 512 /* BindingPropertyType.Dictionary */];
/**
 * Implements https://github.com/realm/realm-js/blob/v11/src/js_schema.hpp#L433-L478
 * @internal
 */
function fromBindingObjectSchema({ name, computedProperties, persistedProperties, primaryKey, tableType, }) {
    const properties = [...computedProperties, ...persistedProperties];
    const result = {
        ctor: undefined,
        name,
        properties: Object.fromEntries(properties.map((property) => [property.publicName || property.name, fromBindingPropertySchema(property)])),
        embedded: tableType === 1 /* TableType.Embedded */,
        asymmetric: tableType === 2 /* TableType.TopLevelAsymmetric */,
    };
    // The primary key from the binding is an empty string when not set
    if (primaryKey) {
        result.primaryKey = primaryKey;
    }
    return result;
}
/**
 * Implements https://github.com/realm/realm-js/blob/v11/src/js_schema.hpp#L480-L530
 * @internal
 */
function fromBindingPropertySchema(propertySchema) {
    const { name, isIndexed, isFulltextIndexed, publicName } = propertySchema;
    const result = {
        name,
        indexed: isFulltextIndexed ? "full-text" : isIndexed,
        mapTo: name,
        ...fromBindingPropertyTypeName(propertySchema),
    };
    if (publicName) {
        result.name = publicName;
    }
    return result;
}
/** @internal */
function fromBindingPropertyTypeName(propertySchema) {
    const { type, objectType, linkOriginPropertyName } = propertySchema;
    const itemType = type & ~896 /* BindingPropertyType.Collection */;
    if (type & 64 /* BindingPropertyType.Nullable */) {
        const item = fromBindingPropertyTypeName({ ...propertySchema, type: type & ~64 /* BindingPropertyType.Nullable */ });
        return { ...item, optional: true };
    }
    if (itemType === 8 /* BindingPropertyType.LinkingObjects */) {
        assert(type & 128 /* BindingPropertyType.Array */);
        assert.string(linkOriginPropertyName, "linkOriginPropertyName");
        return {
            type: "linkingObjects",
            optional: false,
            objectType,
            property: linkOriginPropertyName,
        };
    }
    for (const collectionType of COLLECTION_TYPES$1) {
        if (type & collectionType) {
            const item = fromBindingPropertyTypeName({ ...propertySchema, type: itemType });
            return {
                type: TYPE_MAPPINGS$1[collectionType],
                objectType: item.type === "object" ? item.objectType : item.type,
                optional: item.type === "object" ? false : item.optional,
            };
        }
    }
    if (type === 7 /* BindingPropertyType.Object */) {
        if (!objectType) {
            throw new Error("Expected property with 'object' type to declare an objectType");
        }
        // TODO: Decide if this change is reasonable
        return { type: "object", objectType, optional: true }; // Implicitly nullable
    }
    else if (type === 8 /* BindingPropertyType.LinkingObjects */) {
        if (!objectType) {
            throw new Error("Expected property with 'object' type to declare an objectType");
        }
        return { type: "linkingObjects", objectType, optional: false };
    }
    const mappedType = TYPE_MAPPINGS$1[type];
    if (mappedType) {
        return { type: mappedType, optional: false };
    }
    else {
        throw new Error(`Unexpected type '${type}'`);
    }
}
/** @internal */
function fromBindingRealmSchema(schema) {
    return schema.map(fromBindingObjectSchema);
}

////////////////////////////////////////////////////////////////////////////
/** @internal */
const TYPE_MAPPINGS = {
    int: 0 /* BindingPropertyType.Int */,
    bool: 1 /* BindingPropertyType.Bool */,
    string: 2 /* BindingPropertyType.String */,
    data: 3 /* BindingPropertyType.Data */,
    date: 4 /* BindingPropertyType.Date */,
    float: 5 /* BindingPropertyType.Float */,
    double: 6 /* BindingPropertyType.Double */,
    mixed: 9 /* BindingPropertyType.Mixed */,
    objectId: 10 /* BindingPropertyType.ObjectId */,
    decimal128: 11 /* BindingPropertyType.Decimal */,
    uuid: 12 /* BindingPropertyType.Uuid */,
    list: 128 /* BindingPropertyType.Array */,
    set: 256 /* BindingPropertyType.Set */,
    dictionary: 512 /* BindingPropertyType.Dictionary */,
    linkingObjects: 8 /* BindingPropertyType.LinkingObjects */,
    object: 7 /* BindingPropertyType.Object */,
};
function deriveTableType(schema) {
    if (schema.embedded) {
        assert.boolean(schema.asymmetric, `'${schema.name}' cannot be both embedded and asymmetric`);
        return 1 /* TableType.Embedded */;
    }
    else if (schema.asymmetric) {
        return 2 /* TableType.TopLevelAsymmetric */;
    }
    else {
        return 0 /* TableType.TopLevel */;
    }
}
/** @internal */
function toBindingSchema(schema) {
    return schema.map(toBindingObjectSchema);
}
/** @internal */
function toBindingObjectSchema(schema) {
    // TODO: Enable declaring the alias of the object schema
    // TODO: Enable declaring computed properties
    const properties = Object.entries(schema.properties)
        .map(([name, property]) => toBindingPropertySchema(name, property))
        .map((property) => {
        // Ensure the primary property is marked accordingly
        if (property.name === schema.primaryKey) {
            property.isPrimary = true;
        }
        return property;
    });
    const result = {
        name: schema.name,
        tableType: deriveTableType(schema),
        persistedProperties: properties.filter((p) => (p.type & ~960 /* BindingPropertyType.Flags */) !== 8 /* BindingPropertyType.LinkingObjects */),
        computedProperties: properties.filter((p) => (p.type & ~960 /* BindingPropertyType.Flags */) === 8 /* BindingPropertyType.LinkingObjects */),
    };
    // The object schema itself must also know the name of the primary key
    if (schema.primaryKey) {
        result.primaryKey = schema.primaryKey;
    }
    return result;
}
/** @internal */
function toBindingPropertySchema(name, schema) {
    if (name !== schema.name) {
        // TODO: Consider if this API should be used to support declaring an alias?
        throw new Error("The key of a property must match its name property");
    }
    const result = {
        name,
        type: toBindingPropertyType(schema),
        objectType: schema.objectType && schema.objectType in TYPE_MAPPINGS ? undefined : schema.objectType,
        linkOriginPropertyName: schema.property,
    };
    if (schema.indexed === "full-text") {
        result.isFulltextIndexed = true;
    }
    else {
        result.isIndexed = schema.indexed;
    }
    if (schema.mapTo && schema.mapTo !== schema.name) {
        result.publicName = result.name;
        result.name = schema.mapTo;
    }
    return result;
}
/** @internal */
function toBindingPropertyType(schema) {
    let type = TYPE_MAPPINGS[schema.type];
    let isNullable = schema.optional;
    if (type === 8 /* BindingPropertyType.LinkingObjects */) {
        return type | 128 /* BindingPropertyType.Array */;
    }
    else if (schema.objectType) {
        if (schema.objectType in TYPE_MAPPINGS) {
            type |= TYPE_MAPPINGS[schema.objectType];
            if (schema.objectType === "mixed") {
                // Implicitly nullable - will throw if not sat
                isNullable = true;
            }
        }
        else {
            type |= 7 /* BindingPropertyType.Object */;
            // Implicitly nullable - will throw if sat
            if (!(type & 512 /* BindingPropertyType.Dictionary */)) {
                isNullable = false;
            }
        }
    }
    if (schema.type === "object" || schema.type === "mixed") {
        // Implicitly nullable - will throw if not sat
        isNullable = true;
    }
    if (isNullable) {
        type |= 64 /* BindingPropertyType.Nullable */;
    }
    return type;
}

////////////////////////////////////////////////////////////////////////////
const PRIMITIVE_TYPES = new Set([
    "bool",
    "int",
    "float",
    "double",
    "decimal128",
    "objectId",
    "string",
    "data",
    "date",
    "mixed",
    "uuid",
]);
const COLLECTION_TYPES = new Set(["list", "dictionary", "set"]);
const COLLECTION_SHORTHAND_TO_NAME = {
    "[]": "list",
    "{}": "dictionary",
    "<>": "set",
};
const COLLECTION_SUFFIX_LENGTH = "[]".length;
function isPrimitive(type) {
    return PRIMITIVE_TYPES.has(type);
}
function isCollection(type) {
    return COLLECTION_TYPES.has(type);
}
function isUserDefined(type) {
    return !!type && !(isPrimitive(type) || isCollection(type) || type === "object" || type === "linkingObjects");
}
/**
 * Transform a validated user-provided Realm schema into its canonical form.
 */
function normalizeRealmSchema(realmSchema) {
    return realmSchema.map(normalizeObjectSchema);
}
/**
 * Transform a validated user-provided object schema into its canonical form.
 */
function normalizeObjectSchema(arg) {
    if (typeof arg === "function") {
        assert(arg.schema, () => new SchemaParseError("A static schema must be specified on this class."));
        const objectSchema = normalizeObjectSchema(arg.schema);
        objectSchema.ctor = arg;
        return objectSchema;
    }
    // ---- THIS IF BLOCK HAS NOT YET BEEN REWRITTEN ----
    // TODO: Determine if we still want to support this (should show warning to users of future deprecation)
    if (Array.isArray(arg.properties)) {
        if (flags.ALLOW_VALUES_ARRAYS) {
            return normalizeObjectSchema({
                ...arg,
                // Build the PropertiesTypes object
                properties: Object.fromEntries(arg.properties.map(({ name, ...rest }) => [name, rest])),
            });
        }
        throw new Error("Array of properties are no longer supported. Use an object instead.");
    }
    // --------------------------------------------------
    const { name, primaryKey, asymmetric, embedded, properties } = arg;
    assert(name.length > 0, objectError("", "'name' must be specified."));
    const primaryKeyFieldIsMissing = primaryKey && !Object.prototype.hasOwnProperty.call(properties, primaryKey);
    assert(!primaryKeyFieldIsMissing, objectError(name, `'${primaryKey}' is set as the primary key field but was not found in 'properties'.`));
    assert(!asymmetric || !embedded, objectError(name, "Cannot be both asymmetric and embedded."));
    return {
        name,
        primaryKey,
        asymmetric: !!asymmetric,
        embedded: !!embedded,
        properties: normalizePropertySchemas(name, properties, primaryKey),
    };
}
/**
 * Transform user-provided property schemas into their canonical forms.
 */
function normalizePropertySchemas(objectName, propertiesSchemas, primaryKey) {
    const normalizedSchemas = {};
    for (const propertyName in propertiesSchemas) {
        normalizedSchemas[propertyName] = normalizePropertySchema({
            objectName,
            propertyName,
            propertySchema: propertiesSchemas[propertyName],
            isPrimaryKey: primaryKey === propertyName,
        });
    }
    return normalizedSchemas;
}
/**
 * Transform a user-provided property schema into its canonical form.
 */
function normalizePropertySchema(info) {
    const isUsingShorthand = typeof info.propertySchema === "string";
    const normalizedSchema = isUsingShorthand
        ? normalizePropertySchemaShorthand(info)
        : normalizePropertySchemaObject(info);
    return normalizedSchema;
}
/**
 * Transform a validated user-provided property schema that is using
 * the shorthand string notation into its canonical form.
 */
function normalizePropertySchemaShorthand(info) {
    let { propertySchema } = info;
    assert(propertySchema.length > 0, propError(info, "The type must be specified."));
    let type = "";
    let objectType;
    let optional;
    if (hasCollectionSuffix(propertySchema)) {
        const suffix = propertySchema.substring(propertySchema.length - COLLECTION_SUFFIX_LENGTH);
        type = COLLECTION_SHORTHAND_TO_NAME[suffix];
        propertySchema = propertySchema.substring(0, propertySchema.length - COLLECTION_SUFFIX_LENGTH);
        assert(propertySchema.length > 0, propError(info, `The element type must be specified (Example: 'int${suffix}')`));
        const isNestedCollection = hasCollectionSuffix(propertySchema);
        assert(!isNestedCollection, propError(info, "Nested collections are not supported."));
    }
    if (propertySchema.endsWith("?")) {
        optional = true;
        propertySchema = propertySchema.substring(0, propertySchema.length - 1);
        assert(propertySchema.length > 0, propError(info, "The type must be specified. (Examples: 'int?' and 'int?[]')"));
        const usingOptionalOnCollection = hasCollectionSuffix(propertySchema);
        assert(!usingOptionalOnCollection, propError(info, "Collections cannot be optional. To allow elements of the collection to be optional, use '?' after the element type. (Examples: 'int?[]', 'int?{}', and 'int?<>')"));
    }
    if (isPrimitive(propertySchema)) {
        if (isCollection(type)) {
            objectType = propertySchema;
        }
        else {
            type = propertySchema;
        }
    }
    else if (isCollection(propertySchema)) {
        throw new PropertySchemaParseError(`Cannot use the collection name ${propertySchema}. (Examples: 'int[]' (list), 'int{}' (dictionary), and 'int<>' (set))`, info);
    }
    else if (propertySchema === "object") {
        throw new PropertySchemaParseError("To define a relationship, use either 'MyObjectType' or { type: 'object', objectType: 'MyObjectType' }", info);
    }
    else if (propertySchema === "linkingObjects") {
        throw new PropertySchemaParseError("To define an inverse relationship, use { type: 'linkingObjects', objectType: 'MyObjectType', property: 'myObjectTypesProperty' }", info);
    }
    else {
        // User-defined types
        objectType = propertySchema;
        if (!isCollection(type)) {
            type = "object";
        }
    }
    if (isAlwaysOptional(type, objectType)) {
        optional = true;
    }
    else if (isNeverOptional(type, objectType)) {
        assert(!optional, propError(info, "User-defined types in lists and sets are always non-optional and cannot be made optional. Remove '?' or change the type."));
        optional = false;
    }
    const normalizedSchema = {
        name: info.propertyName,
        type: type,
        optional: !!optional,
        indexed: !!info.isPrimaryKey,
        mapTo: info.propertyName,
    };
    // Add optional properties only if defined (tests expect no 'undefined' properties)
    if (objectType !== undefined)
        normalizedSchema.objectType = objectType;
    return normalizedSchema;
}
/**
 * Transform a validated user-provided property schema that is using
 * the relaxed object notation into its canonical form.
 */
function normalizePropertySchemaObject(info) {
    const { propertySchema } = info;
    const { type, objectType, property, default: defaultValue } = propertySchema;
    let { optional, indexed } = propertySchema;
    assert(type.length > 0, propError(info, "'type' must be specified."));
    assertNotUsingShorthand(type, info);
    assertNotUsingShorthand(objectType, info);
    if (isPrimitive(type)) {
        assert(objectType === undefined, propError(info, `'objectType' cannot be defined when 'type' is '${type}'.`));
    }
    else if (isCollection(type)) {
        assert(isPrimitive(objectType) || isUserDefined(objectType), propError(info, `A ${type} must contain only primitive or user-defined types specified through 'objectType'.`));
    }
    else if (type === "object") {
        assert(isUserDefined(objectType), propError(info, "A user-defined type must be specified through 'objectType'."));
    }
    else if (type === "linkingObjects") {
        assert(isUserDefined(objectType), propError(info, "A user-defined type must be specified through 'objectType'."));
        assert(!!property, propError(info, "The linking object's property name must be specified through 'property'."));
    }
    else {
        // 'type' is a user-defined type
        throw new PropertySchemaParseError(`If you meant to define a relationship, use { type: 'object', objectType: '${type}' } or { type: 'linkingObjects', objectType: '${type}', property: 'The ${type} property' }`, info);
    }
    if (type !== "linkingObjects") {
        assert(property === undefined, propError(info, "'property' can only be specified if 'type' is 'linkingObjects'."));
    }
    if (isAlwaysOptional(type, objectType)) {
        const displayed = type === "mixed" || objectType === "mixed"
            ? "'mixed' types"
            : "User-defined types as standalone objects and in dictionaries";
        assert(optional !== false, propError(info, `${displayed} are always optional and cannot be made non-optional.`));
        optional = true;
    }
    else if (isNeverOptional(type, objectType)) {
        assert(optional !== true, propError(info, "User-defined types in lists and sets are always non-optional and cannot be made optional."));
        optional = false;
    }
    if (info.isPrimaryKey) {
        assert(indexed !== false, propError(info, "Primary keys must always be indexed."));
        assert(indexed !== "full-text", propError(info, "Primary keys cannot be full-text indexed."));
        indexed = true;
    }
    const normalizedSchema = {
        name: info.propertyName,
        type: type,
        optional: !!optional,
        indexed: indexed !== undefined ? indexed : false,
        mapTo: propertySchema.mapTo || info.propertyName,
    };
    // Add optional properties only if defined (tests expect no 'undefined' properties)
    if (objectType !== undefined)
        normalizedSchema.objectType = objectType;
    if (property !== undefined)
        normalizedSchema.property = property;
    if (defaultValue !== undefined)
        normalizedSchema.default = defaultValue;
    return normalizedSchema;
}
/**
 * Determine whether a property always is implicitly optional (nullable).
 */
function isAlwaysOptional(type, objectType) {
    return (type === "mixed" ||
        objectType === "mixed" ||
        type === "object" ||
        (type === "dictionary" && isUserDefined(objectType)));
}
/**
 * Determine whether a property always is implicitly non-optional (non-nullable).
 */
function isNeverOptional(type, objectType) {
    return (type === "list" || type === "set" || type === "linkingObjects") && isUserDefined(objectType);
}
/**
 * Determine whether a string ends with a shorthand collection ('[]' or '{}' or '<>').
 */
function hasCollectionSuffix(input) {
    const suffix = input.substring(input.length - COLLECTION_SUFFIX_LENGTH);
    return !!COLLECTION_SHORTHAND_TO_NAME[suffix];
}
/**
 * Assert that shorthand notation is not being used.
 */
function assertNotUsingShorthand(input, info) {
    if (!input) {
        return;
    }
    const shorthands = extractShorthands(input);
    assert(shorthands.length === 0, propError(info, `Cannot use shorthand '${shorthands.join("' and '")}' in 'type' or 'objectType' when defining property objects.`));
}
/**
 * Extract the shorthand markers used in the input.
 */
function extractShorthands(input) {
    const shorthands = [];
    if (hasCollectionSuffix(input)) {
        shorthands.push(input.substring(input.length - COLLECTION_SUFFIX_LENGTH));
        input = input.substring(0, input.length - COLLECTION_SUFFIX_LENGTH);
    }
    if (input.endsWith("?")) {
        shorthands.push("?");
    }
    return shorthands;
}
/**
 * Generate an error caused by an invalid property schema.
 * (Returning a function rather than the Error itself in order
 * for the Error to only be created if needed.)
 */
function propError(info, message) {
    return () => new PropertySchemaParseError(message, info);
}
/**
 * Generate an error caused by an invalid object schema.
 */
function objectError(objectName, message) {
    return () => new ObjectSchemaParseError(message, { objectName });
}

////////////////////////////////////////////////////////////////////////////
// Need to use `CanonicalObjectSchema` rather than `ObjectSchema` due to some
// integration tests using `openRealmHook()`. That function sets `this.realm`
// to the opened realm whose schema is a `CanonicalObjectSchema[]`. Consequently,
// the key `"ctor"` (which doesn't exist on `ObjectSchema`) also needs to be allowed.
const OBJECT_SCHEMA_KEYS = new Set([
    "name",
    "primaryKey",
    "embedded",
    "asymmetric",
    "properties",
    // Not part of `ObjectSchema`
    "ctor",
]);
// Need to use `CanonicalPropertySchema` rather than `PropertySchema`
// due to the same reasons as above.
const PROPERTY_SCHEMA_KEYS = new Set([
    "type",
    "objectType",
    "property",
    "default",
    "optional",
    "indexed",
    "mapTo",
    // Not part of `PropertySchema`
    "name",
]);
/**
 * Validate the data types of the fields of a user-provided realm schema.
 */
function validateRealmSchema(realmSchema) {
    assert.array(realmSchema, "realm schema");
    for (const objectSchema of realmSchema) {
        validateObjectSchema(objectSchema);
    }
    // TODO: Assert that backlinks point to object schemas that are actually declared
}
/**
 * Validate the data types of the fields of a user-provided object schema.
 */
function validateObjectSchema(objectSchema) {
    try {
        // Schema is passed via a class based model (RealmObjectConstructor)
        if (typeof objectSchema === "function") {
            const clazz = objectSchema;
            // We assert this later, but want a custom error message
            if (!(objectSchema.prototype instanceof RealmObject)) {
                const schemaName = clazz.schema && clazz.schema.name;
                if (typeof schemaName === "string" && schemaName !== objectSchema.name) {
                    throw new TypeError(`Class '${objectSchema.name}' (declaring '${schemaName}' schema) must extend Realm.Object`);
                }
                else {
                    throw new TypeError(`Class '${objectSchema.name}' must extend Realm.Object`);
                }
            }
            assert.object(clazz.schema, "schema static");
            validateObjectSchema(clazz.schema);
        }
        // Schema is passed as an object (ObjectSchema)
        else {
            assert.object(objectSchema, "object schema", { allowArrays: false });
            const { name: objectName, properties, primaryKey, asymmetric, embedded } = objectSchema;
            assert.string(objectName, "'name' on object schema");
            assert.object(properties, `'properties' on '${objectName}'`, { allowArrays: false });
            if (primaryKey !== undefined) {
                assert.string(primaryKey, `'primaryKey' on '${objectName}'`);
            }
            if (embedded !== undefined) {
                assert.boolean(embedded, `'embedded' on '${objectName}'`);
            }
            if (asymmetric !== undefined) {
                assert.boolean(asymmetric, `'asymmetric' on '${objectName}'`);
            }
            const invalidKeysUsed = filterInvalidKeys(objectSchema, OBJECT_SCHEMA_KEYS);
            assert(!invalidKeysUsed.length, `Unexpected field(s) found on the schema for object '${objectName}': '${invalidKeysUsed.join("', '")}'.`);
            for (const propertyName in properties) {
                const propertySchema = properties[propertyName];
                const isUsingShorthand = typeof propertySchema === "string";
                if (!isUsingShorthand) {
                    validatePropertySchema(objectName, propertyName, propertySchema);
                }
            }
        }
    }
    catch (err) {
        // Rethrow as SchemaParseError(s) rather than a mix of Error, TypeError,
        // TypeAssertionError, or AssertionError.
        if (err instanceof PropertySchemaParseError) {
            throw err;
        }
        else if (err instanceof Error) {
            // This first line is a workaround to satisfy TS. Runtime check needs to be
            // `const objectName = objectSchema?.name || ""` where either `objectSchema`
            // or `objectSchema.name` can be undefined or an incorrect type.
            const objectName = objectSchema?.name || "";
            throw new ObjectSchemaParseError(err.message, { objectName });
        }
        throw err;
    }
}
/**
 * Validate the data types of a user-provided property schema that ought to use the
 * relaxed object notation.
 */
function validatePropertySchema(objectName, propertyName, propertySchema) {
    try {
        assert.object(propertySchema, `'${propertyName}' on '${objectName}'`, { allowArrays: false });
        const { type, objectType, optional, property, indexed, mapTo } = propertySchema;
        assert.string(type, `'${propertyName}.type' on '${objectName}'`);
        if (objectType !== undefined) {
            assert.string(objectType, `'${propertyName}.objectType' on '${objectName}'`);
        }
        if (optional !== undefined) {
            assert.boolean(optional, `'${propertyName}.optional' on '${objectName}'`);
        }
        if (property !== undefined) {
            assert.string(property, `'${propertyName}.property' on '${objectName}'`);
        }
        if (indexed !== undefined) {
            assert(typeof indexed === "boolean" || indexed === "full-text", `Expected '${propertyName}.indexed' on '${objectName}' to be a boolean or 'full-text'.`);
        }
        if (mapTo !== undefined) {
            assert.string(mapTo, `'${propertyName}.mapTo' on '${objectName}'`);
        }
        const invalidKeysUsed = filterInvalidKeys(propertySchema, PROPERTY_SCHEMA_KEYS);
        assert(!invalidKeysUsed.length, `Unexpected field(s) found on the schema for property '${propertyName}' on '${objectName}': '${invalidKeysUsed.join("', '")}'.`);
    }
    catch (err) {
        if (err instanceof Error) {
            throw new PropertySchemaParseError(err.message, { objectName, propertyName });
        }
        throw err;
    }
}
/**
 * Get the keys of an object that are not part of the provided valid keys.
 */
function filterInvalidKeys(object, validKeys) {
    return Object.keys(object).filter((key) => !validKeys.has(key));
}

exports.ApiKeyAuth = ApiKeyAuth;
exports.App = App;
exports.AssertionError = AssertionError;
exports.BaseSubscriptionSet = BaseSubscriptionSet;
exports.Collection = Collection;
exports.CompensatingWriteError = CompensatingWriteError;
exports.Credentials = Credentials;
exports.Dictionary = Dictionary;
exports.EmailPasswordAuth = EmailPasswordAuth;
exports.List = List;
exports.MongoDBCollection = MongoDBCollection;
exports.MutableSubscriptionSet = MutableSubscriptionSet;
exports.Object = RealmObject;
exports.ObjectSchemaParseError = ObjectSchemaParseError;
exports.OrderedCollection = OrderedCollection;
exports.ProgressRealmPromise = ProgressRealmPromise;
exports.PropertySchemaParseError = PropertySchemaParseError;
exports.Realm = Realm;
exports.Results = Results;
exports.SchemaParseError = SchemaParseError;
exports.Session = SyncSession;
exports.Set = RealmSet;
exports.Subscription = Subscription;
exports.SubscriptionSet = SubscriptionSet;
exports.Sync = Sync;
exports.SyncError = SyncError;
exports.SyncSession = SyncSession;
exports.TypeAssertionError = TypeAssertionError;
exports.User = User;
exports.flags = flags;
exports.index = index;
exports.kmToRadians = kmToRadians;
exports.mapTo = mapTo;
exports.miToRadians = miToRadians;
//# sourceMappingURL=bundle.node.js.map
